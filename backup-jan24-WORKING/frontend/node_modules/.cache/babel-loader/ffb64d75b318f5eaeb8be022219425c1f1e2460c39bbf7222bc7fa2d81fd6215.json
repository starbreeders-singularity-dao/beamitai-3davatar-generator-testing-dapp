{"ast":null,"code":"import { defineProperties, concat, getBytesCopy, getNumber, hexlify, toBeArray, toBigInt, toNumber, assert, assertArgument\n/*, isError*/ } from \"../../utils/index.js\";\n/**\n * @_ignore:\n */\nexport const WordSize = 32;\nconst Padding = new Uint8Array(WordSize);\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [\"then\"];\nconst _guard = {};\nconst resultNames = new WeakMap();\nfunction getNames(result) {\n  return resultNames.get(result);\n}\nfunction setNames(result, names) {\n  resultNames.set(result, names);\n}\nfunction throwError(name, error) {\n  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);\n  wrapped.error = error;\n  throw wrapped;\n}\nfunction toObject(names, items, deep) {\n  if (names.indexOf(null) >= 0) {\n    return items.map((item, index) => {\n      if (item instanceof Result) {\n        return toObject(getNames(item), item, deep);\n      }\n      return item;\n    });\n  }\n  return names.reduce((accum, name, index) => {\n    let item = items.getValue(name);\n    if (!(name in accum)) {\n      if (deep && item instanceof Result) {\n        item = toObject(getNames(item), item, deep);\n      }\n      accum[name] = item;\n    }\n    return accum;\n  }, {});\n}\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */\nexport class Result extends Array {\n  // No longer used; but cannot be removed as it will remove the\n  // #private field from the .d.ts which may break backwards\n  // compatibility\n  #names;\n  /**\n   *  @private\n   */\n  constructor(...args) {\n    // To properly sub-class Array so the other built-in\n    // functions work, the constructor has to behave fairly\n    // well. So, in the event we are created via fromItems()\n    // we build the read-only Result object we want, but on\n    // any other input, we use the default constructor\n    // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n    const guard = args[0];\n    let items = args[1];\n    let names = (args[2] || []).slice();\n    let wrap = true;\n    if (guard !== _guard) {\n      items = args;\n      names = [];\n      wrap = false;\n    }\n    // Can't just pass in ...items since an array of length 1\n    // is a special case in the super.\n    super(items.length);\n    items.forEach((item, index) => {\n      this[index] = item;\n    });\n    // Find all unique keys\n    const nameCounts = names.reduce((accum, name) => {\n      if (typeof name === \"string\") {\n        accum.set(name, (accum.get(name) || 0) + 1);\n      }\n      return accum;\n    }, new Map());\n    // Remove any key thats not unique\n    setNames(this, Object.freeze(items.map((item, index) => {\n      const name = names[index];\n      if (name != null && nameCounts.get(name) === 1) {\n        return name;\n      }\n      return null;\n    })));\n    // Dummy operations to prevent TypeScript from complaining\n    this.#names = [];\n    if (this.#names == null) {\n      void this.#names;\n    }\n    if (!wrap) {\n      return;\n    }\n    // A wrapped Result is immutable\n    Object.freeze(this);\n    // Proxy indices and names so we can trap deferred errors\n    const proxy = new Proxy(this, {\n      get: (target, prop, receiver) => {\n        if (typeof prop === \"string\") {\n          // Index accessor\n          if (prop.match(/^[0-9]+$/)) {\n            const index = getNumber(prop, \"%index\");\n            if (index < 0 || index >= this.length) {\n              throw new RangeError(\"out of result range\");\n            }\n            const item = target[index];\n            if (item instanceof Error) {\n              throwError(`index ${index}`, item);\n            }\n            return item;\n          }\n          // Pass important checks (like `then` for Promise) through\n          if (passProperties.indexOf(prop) >= 0) {\n            return Reflect.get(target, prop, receiver);\n          }\n          const value = target[prop];\n          if (value instanceof Function) {\n            // Make sure functions work with private variables\n            // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n            return function (...args) {\n              return value.apply(this === receiver ? target : this, args);\n            };\n          } else if (!(prop in target)) {\n            // Possible name accessor\n            return target.getValue.apply(this === receiver ? target : this, [prop]);\n          }\n        }\n        return Reflect.get(target, prop, receiver);\n      }\n    });\n    setNames(proxy, getNames(this));\n    return proxy;\n  }\n  /**\n   *  Returns the Result as a normal Array. If %%deep%%, any children\n   *  which are Result objects are also converted to a normal Array.\n   *\n   *  This will throw if there are any outstanding deferred\n   *  errors.\n   */\n  toArray(deep) {\n    const result = [];\n    this.forEach((item, index) => {\n      if (item instanceof Error) {\n        throwError(`index ${index}`, item);\n      }\n      if (deep && item instanceof Result) {\n        item = item.toArray(deep);\n      }\n      result.push(item);\n    });\n    return result;\n  }\n  /**\n   *  Returns the Result as an Object with each name-value pair. If\n   *  %%deep%%, any children which are Result objects are also\n   *  converted to an Object.\n   *\n   *  This will throw if any value is unnamed, or if there are\n   *  any outstanding deferred errors.\n   */\n  toObject(deep) {\n    const names = getNames(this);\n    return names.reduce((accum, name, index) => {\n      assert(name != null, `value at index ${index} unnamed`, \"UNSUPPORTED_OPERATION\", {\n        operation: \"toObject()\"\n      });\n      return toObject(names, this, deep);\n    }, {});\n  }\n  /**\n   *  @_ignore\n   */\n  slice(start, end) {\n    if (start == null) {\n      start = 0;\n    }\n    if (start < 0) {\n      start += this.length;\n      if (start < 0) {\n        start = 0;\n      }\n    }\n    if (end == null) {\n      end = this.length;\n    }\n    if (end < 0) {\n      end += this.length;\n      if (end < 0) {\n        end = 0;\n      }\n    }\n    if (end > this.length) {\n      end = this.length;\n    }\n    const _names = getNames(this);\n    const result = [],\n      names = [];\n    for (let i = start; i < end; i++) {\n      result.push(this[i]);\n      names.push(_names[i]);\n    }\n    return new Result(_guard, result, names);\n  }\n  /**\n   *  @_ignore\n   */\n  filter(callback, thisArg) {\n    const _names = getNames(this);\n    const result = [],\n      names = [];\n    for (let i = 0; i < this.length; i++) {\n      const item = this[i];\n      if (item instanceof Error) {\n        throwError(`index ${i}`, item);\n      }\n      if (callback.call(thisArg, item, i, this)) {\n        result.push(item);\n        names.push(_names[i]);\n      }\n    }\n    return new Result(_guard, result, names);\n  }\n  /**\n   *  @_ignore\n   */\n  map(callback, thisArg) {\n    const result = [];\n    for (let i = 0; i < this.length; i++) {\n      const item = this[i];\n      if (item instanceof Error) {\n        throwError(`index ${i}`, item);\n      }\n      result.push(callback.call(thisArg, item, i, this));\n    }\n    return result;\n  }\n  /**\n   *  Returns the value for %%name%%.\n   *\n   *  Since it is possible to have a key whose name conflicts with\n   *  a method on a [[Result]] or its superclass Array, or any\n   *  JavaScript keyword, this ensures all named values are still\n   *  accessible by name.\n   */\n  getValue(name) {\n    const index = getNames(this).indexOf(name);\n    if (index === -1) {\n      return undefined;\n    }\n    const value = this[index];\n    if (value instanceof Error) {\n      throwError(`property ${JSON.stringify(name)}`, value.error);\n    }\n    return value;\n  }\n  /**\n   *  Creates a new [[Result]] for %%items%% with each entry\n   *  also accessible by its corresponding name in %%keys%%.\n   */\n  static fromItems(items, keys) {\n    return new Result(_guard, items, keys);\n  }\n}\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */\nexport function checkResultErrors(result) {\n  // Find the first error (if any)\n  const errors = [];\n  const checkErrors = function (path, object) {\n    if (!Array.isArray(object)) {\n      return;\n    }\n    for (let key in object) {\n      const childPath = path.slice();\n      childPath.push(key);\n      try {\n        checkErrors(childPath, object[key]);\n      } catch (error) {\n        errors.push({\n          path: childPath,\n          error: error\n        });\n      }\n    }\n  };\n  checkErrors([], result);\n  return errors;\n}\nfunction getValue(value) {\n  let bytes = toBeArray(value);\n  assert(bytes.length <= WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", {\n    buffer: bytes,\n    length: WordSize,\n    offset: bytes.length\n  });\n  if (bytes.length !== WordSize) {\n    bytes = getBytesCopy(concat([Padding.slice(bytes.length % WordSize), bytes]));\n  }\n  return bytes;\n}\n/**\n *  @_ignore\n */\nexport class Coder {\n  // The coder name:\n  //   - address, uint256, tuple, array, etc.\n  name;\n  // The fully expanded type, including composite types:\n  //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n  type;\n  // The localName bound in the signature, in this example it is \"baz\":\n  //   - tuple(address foo, uint bar) baz\n  localName;\n  // Whether this type is dynamic:\n  //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n  //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n  dynamic;\n  constructor(name, type, localName, dynamic) {\n    defineProperties(this, {\n      name,\n      type,\n      localName,\n      dynamic\n    }, {\n      name: \"string\",\n      type: \"string\",\n      localName: \"string\",\n      dynamic: \"boolean\"\n    });\n  }\n  _throwError(message, value) {\n    assertArgument(false, message, this.localName, value);\n  }\n}\n/**\n *  @_ignore\n */\nexport class Writer {\n  // An array of WordSize lengthed objects to concatenation\n  #data;\n  #dataLength;\n  constructor() {\n    this.#data = [];\n    this.#dataLength = 0;\n  }\n  get data() {\n    return concat(this.#data);\n  }\n  get length() {\n    return this.#dataLength;\n  }\n  #writeData(data) {\n    this.#data.push(data);\n    this.#dataLength += data.length;\n    return data.length;\n  }\n  appendWriter(writer) {\n    return this.#writeData(getBytesCopy(writer.data));\n  }\n  // Arrayish item; pad on the right to *nearest* WordSize\n  writeBytes(value) {\n    let bytes = getBytesCopy(value);\n    const paddingOffset = bytes.length % WordSize;\n    if (paddingOffset) {\n      bytes = getBytesCopy(concat([bytes, Padding.slice(paddingOffset)]));\n    }\n    return this.#writeData(bytes);\n  }\n  // Numeric item; pad on the left *to* WordSize\n  writeValue(value) {\n    return this.#writeData(getValue(value));\n  }\n  // Inserts a numeric place-holder, returning a callback that can\n  // be used to asjust the value later\n  writeUpdatableValue() {\n    const offset = this.#data.length;\n    this.#data.push(Padding);\n    this.#dataLength += WordSize;\n    return value => {\n      this.#data[offset] = getValue(value);\n    };\n  }\n}\n/**\n *  @_ignore\n */\nexport class Reader {\n  // Allows incomplete unpadded data to be read; otherwise an error\n  // is raised if attempting to overrun the buffer. This is required\n  // to deal with an old Solidity bug, in which event data for\n  // external (not public thoguh) was tightly packed.\n  allowLoose;\n  #data;\n  #offset;\n  #bytesRead;\n  #parent;\n  #maxInflation;\n  constructor(data, allowLoose, maxInflation) {\n    defineProperties(this, {\n      allowLoose: !!allowLoose\n    });\n    this.#data = getBytesCopy(data);\n    this.#bytesRead = 0;\n    this.#parent = null;\n    this.#maxInflation = maxInflation != null ? maxInflation : 1024;\n    this.#offset = 0;\n  }\n  get data() {\n    return hexlify(this.#data);\n  }\n  get dataLength() {\n    return this.#data.length;\n  }\n  get consumed() {\n    return this.#offset;\n  }\n  get bytes() {\n    return new Uint8Array(this.#data);\n  }\n  #incrementBytesRead(count) {\n    if (this.#parent) {\n      return this.#parent.#incrementBytesRead(count);\n    }\n    this.#bytesRead += count;\n    // Check for excessive inflation (see: #4537)\n    assert(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https:/\\/github.com/ethers-io/ethers.js/issues/4537 )`, \"BUFFER_OVERRUN\", {\n      buffer: getBytesCopy(this.#data),\n      offset: this.#offset,\n      length: count,\n      info: {\n        bytesRead: this.#bytesRead,\n        dataLength: this.dataLength\n      }\n    });\n  }\n  #peekBytes(offset, length, loose) {\n    let alignedLength = Math.ceil(length / WordSize) * WordSize;\n    if (this.#offset + alignedLength > this.#data.length) {\n      if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {\n        alignedLength = length;\n      } else {\n        assert(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n          buffer: getBytesCopy(this.#data),\n          length: this.#data.length,\n          offset: this.#offset + alignedLength\n        });\n      }\n    }\n    return this.#data.slice(this.#offset, this.#offset + alignedLength);\n  }\n  // Create a sub-reader with the same underlying data, but offset\n  subReader(offset) {\n    const reader = new Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);\n    reader.#parent = this;\n    return reader;\n  }\n  // Read bytes\n  readBytes(length, loose) {\n    let bytes = this.#peekBytes(0, length, !!loose);\n    this.#incrementBytesRead(length);\n    this.#offset += bytes.length;\n    // @TODO: Make sure the length..end bytes are all 0?\n    return bytes.slice(0, length);\n  }\n  // Read a numeric values\n  readValue() {\n    return toBigInt(this.readBytes(WordSize));\n  }\n  readIndex() {\n    return toNumber(this.readBytes(WordSize));\n  }\n}\n//# sourceMappingURL=abstract-coder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}