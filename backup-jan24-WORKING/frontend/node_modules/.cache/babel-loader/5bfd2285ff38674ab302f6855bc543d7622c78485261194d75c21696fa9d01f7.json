{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { AbiError } from 'web3-errors';\nimport { isNullish, isUint8Array, leftPad, rightPad, toHex } from 'web3-utils';\nexport const isAbiFragment = item => !isNullish(item) && typeof item === 'object' && !isNullish(item.type) && ['function', 'event', 'constructor', 'error'].includes(item.type);\nexport const isAbiErrorFragment = item => !isNullish(item) && typeof item === 'object' && !isNullish(item.type) && item.type === 'error';\nexport const isAbiEventFragment = item => !isNullish(item) && typeof item === 'object' && !isNullish(item.type) && item.type === 'event';\nexport const isAbiFunctionFragment = item => !isNullish(item) && typeof item === 'object' && !isNullish(item.type) && item.type === 'function';\nexport const isAbiConstructorFragment = item => !isNullish(item) && typeof item === 'object' && !isNullish(item.type) && item.type === 'constructor';\n/**\n * Check if type is simplified struct format\n */\nexport const isSimplifiedStructFormat = type => typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n */\nexport const mapStructNameAndType = structName => structName.includes('[]') ? {\n  type: 'tuple[]',\n  name: structName.slice(0, -2)\n} : {\n  type: 'tuple',\n  name: structName\n};\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n */\nexport const mapStructToCoderFormat = struct => {\n  const components = [];\n  for (const key of Object.keys(struct)) {\n    const item = struct[key];\n    if (typeof item === 'object') {\n      components.push(Object.assign(Object.assign({}, mapStructNameAndType(key)), {\n        components: mapStructToCoderFormat(item)\n      }));\n    } else {\n      components.push({\n        name: key,\n        type: struct[key]\n      });\n    }\n  }\n  return components;\n};\n/**\n * Map types if simplified format is used\n */\nexport const mapTypes = types => {\n  const mappedTypes = [];\n  for (const type of types) {\n    let modifiedType = type;\n    // Clone object\n    if (typeof type === 'object') {\n      modifiedType = Object.assign({}, type);\n    }\n    // Remap `function` type params to bytes24 since Ethers does not\n    // recognize former type. Solidity docs say `Function` is a bytes24\n    // encoding the contract address followed by the function selector hash.\n    if (typeof type === 'object' && type.type === 'function') {\n      modifiedType = Object.assign(Object.assign({}, type), {\n        type: 'bytes24'\n      });\n    }\n    if (isSimplifiedStructFormat(modifiedType)) {\n      const structName = Object.keys(modifiedType)[0];\n      mappedTypes.push(Object.assign(Object.assign({}, mapStructNameAndType(structName)), {\n        components: mapStructToCoderFormat(modifiedType[structName])\n      }));\n    } else {\n      mappedTypes.push(modifiedType);\n    }\n  }\n  return mappedTypes;\n};\n/**\n * returns true if input is a hexstring and is odd-lengthed\n */\nexport const isOddHexstring = param => typeof param === 'string' && /^(-)?0x[0-9a-f]*$/i.test(param) && param.length % 2 === 1;\n/**\n * format odd-length bytes to even-length\n */\nexport const formatOddHexstrings = param => isOddHexstring(param) ? `0x0${param.substring(2)}` : param;\nconst paramTypeBytes = /^bytes([0-9]*)$/;\nconst paramTypeBytesArray = /^bytes([0-9]*)\\[\\]$/;\nconst paramTypeNumber = /^(u?int)([0-9]*)$/;\nconst paramTypeNumberArray = /^(u?int)([0-9]*)\\[\\]$/;\n/**\n * Handle some formatting of params for backwards compatibility with Ethers V4\n */\nexport const formatParam = (type, _param) => {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  // clone if _param is an object\n  const param = typeof _param === 'object' && !Array.isArray(_param) ? Object.assign({}, _param) : _param;\n  // Format BN to string\n  if (param instanceof BigInt || typeof param === 'bigint') {\n    return param.toString(10);\n  }\n  if (paramTypeBytesArray.exec(type) || paramTypeNumberArray.exec(type)) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    const paramClone = [...param];\n    return paramClone.map(p => formatParam(type.replace('[]', ''), p));\n  }\n  // Format correct width for u?int[0-9]*\n  let match = paramTypeNumber.exec(type);\n  if (match) {\n    const size = parseInt(match[2] ? match[2] : '256', 10);\n    if (size / 8 < param.length) {\n      // pad to correct bit width\n      return leftPad(param, size);\n    }\n  }\n  // Format correct length for bytes[0-9]+\n  match = paramTypeBytes.exec(type);\n  if (match) {\n    const hexParam = isUint8Array(param) ? toHex(param) : param;\n    // format to correct length\n    const size = parseInt(match[1], 10);\n    if (size) {\n      let maxSize = size * 2;\n      if (param.startsWith('0x')) {\n        maxSize += 2;\n      }\n      // pad to correct length\n      const paddedParam = hexParam.length < maxSize ? rightPad(param, size * 2) : hexParam;\n      return formatOddHexstrings(paddedParam);\n    }\n    return formatOddHexstrings(hexParam);\n  }\n  return param;\n};\n/**\n *  used to flatten json abi inputs/outputs into an array of type-representing-strings\n */\nexport const flattenTypes = (includeTuple, puts) => {\n  const types = [];\n  puts.forEach(param => {\n    if (typeof param.components === 'object') {\n      if (!param.type.startsWith('tuple')) {\n        throw new AbiError(`Invalid value given \"${param.type}\". Error: components found but type is not tuple.`);\n      }\n      const arrayBracket = param.type.indexOf('[');\n      const suffix = arrayBracket >= 0 ? param.type.substring(arrayBracket) : '';\n      const result = flattenTypes(includeTuple, param.components);\n      if (Array.isArray(result) && includeTuple) {\n        types.push(`tuple(${result.join(',')})${suffix}`);\n      } else if (!includeTuple) {\n        types.push(`(${result.join(',')})${suffix}`);\n      } else {\n        types.push(`(${result.join()})`);\n      }\n    } else {\n      types.push(param.type);\n    }\n  });\n  return types;\n};\n/**\n * Should be used to create full function/event name from json abi\n * returns a string\n */\nexport const jsonInterfaceMethodToString = json => {\n  var _a, _b, _c, _d;\n  // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n  if (isAbiErrorFragment(json) || isAbiEventFragment(json) || isAbiFunctionFragment(json)) {\n    if ((_a = json.name) === null || _a === void 0 ? void 0 : _a.includes('(')) {\n      return json.name;\n    }\n    return `${(_b = json.name) !== null && _b !== void 0 ? _b : ''}(${flattenTypes(false, (_c = json.inputs) !== null && _c !== void 0 ? _c : []).join(',')})`;\n  }\n  // Constructor fragment\n  return `(${flattenTypes(false, (_d = json.inputs) !== null && _d !== void 0 ? _d : []).join(',')})`;\n};\n//# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}