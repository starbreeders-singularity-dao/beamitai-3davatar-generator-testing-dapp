{"ast":null,"code":"import { bytesRegex, execTyped, integerRegex, isTupleRegex } from \"./chunk-WP7KDV47.mjs\";\nimport { __publicField } from \"./chunk-NHABU752.mjs\";\n\n// package.json\nvar name = \"abitype\";\nvar version = \"0.7.1\";\n\n// src/errors.ts\nvar BaseError = class extends Error {\n  constructor(shortMessage, args = {}) {\n    const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;\n    const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;\n    const message = [shortMessage || \"An error occurred.\", \"\", ...(args.metaMessages ? [...args.metaMessages, \"\"] : []), ...(docsPath ? [`Docs: https://abitype.dev${docsPath}`] : []), ...(details ? [`Details: ${details}`] : []), `Version: ${name}@${version}`].join(\"\\n\");\n    super(message);\n    __publicField(this, \"details\");\n    __publicField(this, \"docsPath\");\n    __publicField(this, \"metaMessages\");\n    __publicField(this, \"shortMessage\");\n    __publicField(this, \"name\", \"AbiTypeError\");\n    if (args.cause) this.cause = args.cause;\n    this.details = details;\n    this.docsPath = docsPath;\n    this.metaMessages = args.metaMessages;\n    this.shortMessage = shortMessage;\n  }\n};\n\n// src/narrow.ts\nfunction narrow(value) {\n  return value;\n}\n\n// src/human-readable/runtime/signatures.ts\nvar errorSignatureRegex = /^error (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)$/;\nfunction isErrorSignature(signature) {\n  return errorSignatureRegex.test(signature);\n}\nfunction execErrorSignature(signature) {\n  return execTyped(errorSignatureRegex, signature);\n}\nvar eventSignatureRegex = /^event (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)$/;\nfunction isEventSignature(signature) {\n  return eventSignatureRegex.test(signature);\n}\nfunction execEventSignature(signature) {\n  return execTyped(eventSignatureRegex, signature);\n}\nvar functionSignatureRegex = /^function (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns \\((?<returns>.*?)\\))?$/;\nfunction isFunctionSignature(signature) {\n  return functionSignatureRegex.test(signature);\n}\nfunction execFunctionSignature(signature) {\n  return execTyped(functionSignatureRegex, signature);\n}\nvar structSignatureRegex = /^struct (?<name>[a-zA-Z0-9_]+) \\{(?<properties>.*?)\\}$/;\nfunction isStructSignature(signature) {\n  return structSignatureRegex.test(signature);\n}\nfunction execStructSignature(signature) {\n  return execTyped(structSignatureRegex, signature);\n}\nvar constructorSignatureRegex = /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/;\nfunction isConstructorSignature(signature) {\n  return constructorSignatureRegex.test(signature);\n}\nfunction execConstructorSignature(signature) {\n  return execTyped(constructorSignatureRegex, signature);\n}\nvar fallbackSignatureRegex = /^fallback\\(\\)$/;\nfunction isFallbackSignature(signature) {\n  return fallbackSignatureRegex.test(signature);\n}\nvar receiveSignatureRegex = /^receive\\(\\) external payable$/;\nfunction isReceiveSignature(signature) {\n  return receiveSignatureRegex.test(signature);\n}\nvar modifiers = /* @__PURE__ */new Set([\"memory\", \"indexed\", \"storage\", \"calldata\"]);\nvar eventModifiers = /* @__PURE__ */new Set([\"indexed\"]);\nvar functionModifiers = /* @__PURE__ */new Set([\"calldata\", \"memory\", \"storage\"]);\n\n// src/human-readable/runtime/cache.ts\nfunction getParameterCacheKey(param, type) {\n  if (type) return `${type}:${param}`;\n  return param;\n}\nvar parameterCache = /* @__PURE__ */new Map([\n// Unnamed\n[\"address\", {\n  type: \"address\"\n}], [\"bool\", {\n  type: \"bool\"\n}], [\"bytes\", {\n  type: \"bytes\"\n}], [\"bytes32\", {\n  type: \"bytes32\"\n}], [\"int\", {\n  type: \"int256\"\n}], [\"int256\", {\n  type: \"int256\"\n}], [\"string\", {\n  type: \"string\"\n}], [\"uint\", {\n  type: \"uint256\"\n}], [\"uint8\", {\n  type: \"uint8\"\n}], [\"uint16\", {\n  type: \"uint16\"\n}], [\"uint24\", {\n  type: \"uint24\"\n}], [\"uint32\", {\n  type: \"uint32\"\n}], [\"uint64\", {\n  type: \"uint64\"\n}], [\"uint96\", {\n  type: \"uint96\"\n}], [\"uint112\", {\n  type: \"uint112\"\n}], [\"uint160\", {\n  type: \"uint160\"\n}], [\"uint192\", {\n  type: \"uint192\"\n}], [\"uint256\", {\n  type: \"uint256\"\n}],\n// Named\n[\"address owner\", {\n  type: \"address\",\n  name: \"owner\"\n}], [\"address to\", {\n  type: \"address\",\n  name: \"to\"\n}], [\"bool approved\", {\n  type: \"bool\",\n  name: \"approved\"\n}], [\"bytes _data\", {\n  type: \"bytes\",\n  name: \"_data\"\n}], [\"bytes data\", {\n  type: \"bytes\",\n  name: \"data\"\n}], [\"bytes signature\", {\n  type: \"bytes\",\n  name: \"signature\"\n}], [\"bytes32 hash\", {\n  type: \"bytes32\",\n  name: \"hash\"\n}], [\"bytes32 r\", {\n  type: \"bytes32\",\n  name: \"r\"\n}], [\"bytes32 root\", {\n  type: \"bytes32\",\n  name: \"root\"\n}], [\"bytes32 s\", {\n  type: \"bytes32\",\n  name: \"s\"\n}], [\"string name\", {\n  type: \"string\",\n  name: \"name\"\n}], [\"string symbol\", {\n  type: \"string\",\n  name: \"symbol\"\n}], [\"string tokenURI\", {\n  type: \"string\",\n  name: \"tokenURI\"\n}], [\"uint tokenId\", {\n  type: \"uint256\",\n  name: \"tokenId\"\n}], [\"uint8 v\", {\n  type: \"uint8\",\n  name: \"v\"\n}], [\"uint256 balance\", {\n  type: \"uint256\",\n  name: \"balance\"\n}], [\"uint256 tokenId\", {\n  type: \"uint256\",\n  name: \"tokenId\"\n}], [\"uint256 value\", {\n  type: \"uint256\",\n  name: \"value\"\n}],\n// Indexed\n[\"event:address indexed from\", {\n  type: \"address\",\n  name: \"from\",\n  indexed: true\n}], [\"event:address indexed to\", {\n  type: \"address\",\n  name: \"to\",\n  indexed: true\n}], [\"event:uint indexed tokenId\", {\n  type: \"uint256\",\n  name: \"tokenId\",\n  indexed: true\n}], [\"event:uint256 indexed tokenId\", {\n  type: \"uint256\",\n  name: \"tokenId\",\n  indexed: true\n}]]);\n\n// src/human-readable/runtime/utils.ts\nfunction parseSignature(signature, structs = {}) {\n  if (isFunctionSignature(signature)) {\n    const match = execFunctionSignature(signature);\n    if (!match) throw new BaseError(\"Invalid function signature.\", {\n      details: signature\n    });\n    const inputParams = splitParameters(match.parameters);\n    const inputs = [];\n    const inputLength = inputParams.length;\n    for (let i = 0; i < inputLength; i++) {\n      inputs.push(parseAbiParameter(inputParams[i], {\n        modifiers: functionModifiers,\n        structs,\n        type: \"function\"\n      }));\n    }\n    const outputs = [];\n    if (match.returns) {\n      const outputParams = splitParameters(match.returns);\n      const outputLength = outputParams.length;\n      for (let i = 0; i < outputLength; i++) {\n        outputs.push(parseAbiParameter(outputParams[i], {\n          modifiers: functionModifiers,\n          structs,\n          type: \"function\"\n        }));\n      }\n    }\n    return {\n      name: match.name,\n      type: \"function\",\n      stateMutability: match.stateMutability ?? \"nonpayable\",\n      inputs,\n      outputs\n    };\n  }\n  if (isEventSignature(signature)) {\n    const match = execEventSignature(signature);\n    if (!match) throw new BaseError(\"Invalid event signature.\", {\n      details: signature\n    });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter(params[i], {\n        modifiers: eventModifiers,\n        structs,\n        type: \"event\"\n      }));\n    }\n    return {\n      name: match.name,\n      type: \"event\",\n      inputs: abiParameters\n    };\n  }\n  if (isErrorSignature(signature)) {\n    const match = execErrorSignature(signature);\n    if (!match) throw new BaseError(\"Invalid error signature.\", {\n      details: signature\n    });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter(params[i], {\n        structs,\n        type: \"error\"\n      }));\n    }\n    return {\n      name: match.name,\n      type: \"error\",\n      inputs: abiParameters\n    };\n  }\n  if (isConstructorSignature(signature)) {\n    const match = execConstructorSignature(signature);\n    if (!match) throw new BaseError(\"Invalid constructor signature.\", {\n      details: signature\n    });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter(params[i], {\n        structs,\n        type: \"constructor\"\n      }));\n    }\n    return {\n      type: \"constructor\",\n      stateMutability: match.stateMutability ?? \"nonpayable\",\n      inputs: abiParameters\n    };\n  }\n  if (isFallbackSignature(signature)) return {\n    type: \"fallback\"\n  };\n  if (isReceiveSignature(signature)) return {\n    type: \"receive\",\n    stateMutability: \"payable\"\n  };\n  throw new BaseError(\"Unknown signature.\", {\n    details: signature\n  });\n}\nvar abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z0-9_]+))?$/;\nvar abiParameterWithTupleRegex = /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z0-9_]+))?$/;\nvar dynamicIntegerRegex = /^u?int$/;\nfunction parseAbiParameter(param, options) {\n  const parameterCacheKey = getParameterCacheKey(param, options?.type);\n  if (parameterCache.has(parameterCacheKey)) return parameterCache.get(parameterCacheKey);\n  const isTuple = isTupleRegex.test(param);\n  const match = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);\n  if (!match) throw new BaseError(\"Invalid ABI parameter.\", {\n    details: param\n  });\n  if (match.name && isSolidityKeyword(match.name)) throw new BaseError(\"Invalid ABI parameter.\", {\n    details: param,\n    metaMessages: [`\"${match.name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`]\n  });\n  const name2 = match.name ? {\n    name: match.name\n  } : {};\n  const indexed = match.modifier === \"indexed\" ? {\n    indexed: true\n  } : {};\n  const structs = options?.structs ?? {};\n  let type;\n  let components = {};\n  if (isTuple) {\n    type = \"tuple\";\n    const params = splitParameters(match.type);\n    const components_ = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      components_.push(parseAbiParameter(params[i], {\n        structs\n      }));\n    }\n    components = {\n      components: components_\n    };\n  } else if (match.type in structs) {\n    type = \"tuple\";\n    components = {\n      components: structs[match.type]\n    };\n  } else if (dynamicIntegerRegex.test(match.type)) {\n    type = `${match.type}256`;\n  } else {\n    type = match.type;\n    if (!(options?.type === \"struct\") && !isSolidityType(type)) throw new BaseError(\"Unknown type.\", {\n      metaMessages: [`Type \"${type}\" is not a valid ABI type.`]\n    });\n  }\n  if (match.modifier) {\n    if (!options?.modifiers?.has?.(match.modifier)) throw new BaseError(\"Invalid ABI parameter.\", {\n      details: param,\n      metaMessages: [`Modifier \"${match.modifier}\" not allowed${options?.type ? ` in \"${options.type}\" type` : \"\"}.`]\n    });\n    if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array)) throw new BaseError(\"Invalid ABI parameter.\", {\n      details: param,\n      metaMessages: [`Modifier \"${match.modifier}\" not allowed${options?.type ? ` in \"${options.type}\" type` : \"\"}.`, `Data location can only be specified for array, struct, or mapping types, but \"${match.modifier}\" was given.`]\n    });\n  }\n  const abiParameter = {\n    type: `${type}${match.array ?? \"\"}`,\n    ...name2,\n    ...indexed,\n    ...components\n  };\n  parameterCache.set(parameterCacheKey, abiParameter);\n  return abiParameter;\n}\nfunction splitParameters(params, result = [], current = \"\", depth = 0) {\n  if (params === \"\") {\n    if (current === \"\") return result;\n    if (depth !== 0) throw new BaseError(\"Unbalanced parentheses.\", {\n      metaMessages: [`\"${current.trim()}\" has too many ${depth > 0 ? \"opening\" : \"closing\"} parentheses.`],\n      details: `Depth \"${depth}\"`\n    });\n    return [...result, current.trim()];\n  }\n  const length = params.length;\n  for (let i = 0; i < length; i++) {\n    const char = params[i];\n    const tail = params.slice(i + 1);\n    switch (char) {\n      case \",\":\n        return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);\n      case \"(\":\n        return splitParameters(tail, result, `${current}${char}`, depth + 1);\n      case \")\":\n        return splitParameters(tail, result, `${current}${char}`, depth - 1);\n      default:\n        return splitParameters(tail, result, `${current}${char}`, depth);\n    }\n  }\n  return [];\n}\nfunction isSolidityType(type) {\n  return type === \"address\" || type === \"bool\" || type === \"function\" || type === \"string\" || bytesRegex.test(type) || integerRegex.test(type);\n}\nvar protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\nfunction isSolidityKeyword(name2) {\n  return name2 === \"address\" || name2 === \"bool\" || name2 === \"function\" || name2 === \"string\" || name2 === \"tuple\" || bytesRegex.test(name2) || integerRegex.test(name2) || protectedKeywordsRegex.test(name2);\n}\nfunction isValidDataLocation(type, isArray) {\n  return isArray || type === \"bytes\" || type === \"string\" || type === \"tuple\";\n}\n\n// src/human-readable/runtime/structs.ts\nfunction parseStructs(signatures) {\n  const shallowStructs = {};\n  const signaturesLength = signatures.length;\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i];\n    if (!isStructSignature(signature)) continue;\n    const match = execStructSignature(signature);\n    if (!match) throw new BaseError(\"Invalid struct signature.\", {\n      details: signature\n    });\n    const properties = match.properties.split(\";\");\n    const components = [];\n    const propertiesLength = properties.length;\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k];\n      const trimmed = property.trim();\n      if (!trimmed) continue;\n      const abiParameter = parseAbiParameter(trimmed, {\n        type: \"struct\"\n      });\n      components.push(abiParameter);\n    }\n    if (!components.length) throw new BaseError(\"Invalid struct signature.\", {\n      details: signature,\n      metaMessages: [\"No properties exist.\"]\n    });\n    shallowStructs[match.name] = components;\n  }\n  const resolvedStructs = {};\n  const entries = Object.entries(shallowStructs);\n  const entriesLength = entries.length;\n  for (let i = 0; i < entriesLength; i++) {\n    const [name2, parameters] = entries[i];\n    resolvedStructs[name2] = resolveStructs(parameters, shallowStructs);\n  }\n  return resolvedStructs;\n}\nvar typeWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\\[\\d*?\\])+?)?$/;\nfunction resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */new Set()) {\n  const components = [];\n  const length = abiParameters.length;\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i];\n    const isTuple = isTupleRegex.test(abiParameter.type);\n    if (isTuple) components.push(abiParameter);else {\n      const match = execTyped(typeWithoutTupleRegex, abiParameter.type);\n      if (!match?.type) throw new BaseError(\"Invalid ABI parameter.\", {\n        details: JSON.stringify(abiParameter, null, 2),\n        metaMessages: [\"ABI parameter type is invalid.\"]\n      });\n      const {\n        array,\n        type\n      } = match;\n      if (type in structs) {\n        if (ancestors.has(type)) throw new BaseError(\"Circular reference detected.\", {\n          metaMessages: [`Struct \"${type}\" is a circular reference.`]\n        });\n        components.push({\n          ...abiParameter,\n          type: `tuple${array ?? \"\"}`,\n          components: resolveStructs(structs[type] ?? [], structs, /* @__PURE__ */new Set([...ancestors, type]))\n        });\n      } else {\n        if (isSolidityType(type)) components.push(abiParameter);else throw new BaseError(\"Unknown type.\", {\n          metaMessages: [`Type \"${type}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`]\n        });\n      }\n    }\n  }\n  return components;\n}\n\n// src/human-readable/parseAbi.ts\nfunction parseAbi(signatures) {\n  const structs = parseStructs(signatures);\n  const abi = [];\n  const length = signatures.length;\n  for (let i = 0; i < length; i++) {\n    const signature = signatures[i];\n    if (isStructSignature(signature)) continue;\n    abi.push(parseSignature(signature, structs));\n  }\n  return abi;\n}\n\n// src/human-readable/parseAbiItem.ts\nfunction parseAbiItem(signature) {\n  let abiItem;\n  if (typeof signature === \"string\") abiItem = parseSignature(signature);else {\n    const structs = parseStructs(signature);\n    const length = signature.length;\n    for (let i = 0; i < length; i++) {\n      const signature_ = signature[i];\n      if (isStructSignature(signature_)) continue;\n      abiItem = parseSignature(signature_, structs);\n      break;\n    }\n  }\n  if (!abiItem) throw new BaseError(\"Failed to parse ABI item.\", {\n    details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,\n    docsPath: \"/api/human.html#parseabiitem-1\"\n  });\n  return abiItem;\n}\n\n// src/human-readable/parseAbiParameter.ts\nfunction parseAbiParameter2(param) {\n  let abiParameter;\n  if (typeof param === \"string\") abiParameter = parseAbiParameter(param, {\n    modifiers\n  });else {\n    const structs = parseStructs(param);\n    const length = param.length;\n    for (let i = 0; i < length; i++) {\n      const signature = param[i];\n      if (isStructSignature(signature)) continue;\n      abiParameter = parseAbiParameter(signature, {\n        modifiers,\n        structs\n      });\n      break;\n    }\n  }\n  if (!abiParameter) throw new BaseError(\"Failed to parse ABI parameter.\", {\n    details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,\n    docsPath: \"/api/human.html#parseabiparameter-1\"\n  });\n  return abiParameter;\n}\n\n// src/human-readable/parseAbiParameters.ts\nfunction parseAbiParameters(params) {\n  const abiParameters = [];\n  if (typeof params === \"string\") {\n    const parameters = splitParameters(params);\n    const length = parameters.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter(parameters[i], {\n        modifiers\n      }));\n    }\n  } else {\n    const structs = parseStructs(params);\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      const signature = params[i];\n      if (isStructSignature(signature)) continue;\n      const parameters = splitParameters(signature);\n      const length2 = parameters.length;\n      for (let k = 0; k < length2; k++) {\n        abiParameters.push(parseAbiParameter(parameters[k], {\n          modifiers,\n          structs\n        }));\n      }\n    }\n  }\n  if (abiParameters.length === 0) throw new BaseError(\"Failed to parse ABI parameters.\", {\n    details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,\n    docsPath: \"/api/human.html#parseabiparameters-1\"\n  });\n  return abiParameters;\n}\nexport { BaseError, narrow, parseAbi, parseAbiItem, parseAbiParameter2 as parseAbiParameter, parseAbiParameters };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}