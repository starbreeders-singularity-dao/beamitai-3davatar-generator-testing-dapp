{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { decodeParameter, decodeParametersWith } from './parameters_api.js';\nconst STATIC_TYPES = ['bool', 'string', 'int', 'uint', 'address', 'fixed', 'ufixed'];\nconst _decodeParameter = (inputType, clonedTopic) => inputType === 'string' ? clonedTopic : decodeParameter(inputType, clonedTopic);\n/**\n * Decodes ABI-encoded log data and indexed topic data.\n * @param inputs - A {@link AbiParameter} input array. See the [Solidity documentation](https://docs.soliditylang.org/en/develop/types.html) for a list of types.\n * @param data - The ABI byte code in the `data` field of a log.\n * @param topics - An array with the index parameter topics of the log, without the topic[0] if its a non-anonymous event, otherwise with topic[0]\n * @returns - The result object containing the decoded parameters.\n *\n * @example\n * ```ts\n * let res = web3.eth.abi.decodeLog(\n *    [\n *      {\n *        type: \"string\",\n *        name: \"myString\",\n *      },\n *      {\n *        type: \"uint256\",\n *        name: \"myNumber\",\n *        indexed: true,\n *      },\n *      {\n *        type: \"uint8\",\n *        name: \"mySmallNumber\",\n *        indexed: true,\n *      },\n *    ],\n *    \"0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000748656c6c6f252100000000000000000000000000000000000000000000000000\",\n *    [\n *      \"0x000000000000000000000000000000000000000000000000000000000000f310\",\n *      \"0x0000000000000000000000000000000000000000000000000000000000000010\",\n *    ]\n *  );\n * > {\n *  '0': 'Hello%!',\n *  '1': 62224n,\n *  '2': 16n,\n *  __length__: 3,\n *  myString: 'Hello%!',\n *  myNumber: 62224n,\n *  mySmallNumber: 16n\n * }\n * ```\n */\nexport const decodeLog = (inputs, data, topics) => {\n  const clonedTopics = Array.isArray(topics) ? topics : [topics];\n  const indexedInputs = {};\n  const nonIndexedInputs = {};\n  for (const [i, input] of inputs.entries()) {\n    if (input.indexed) {\n      indexedInputs[i] = input;\n    } else {\n      nonIndexedInputs[i] = input;\n    }\n  }\n  const decodedNonIndexedInputs = data ? decodeParametersWith(Object.values(nonIndexedInputs), data, true) : {\n    __length__: 0\n  };\n  // If topics are more than indexed inputs, that means first topic is the event signature\n  const offset = clonedTopics.length - Object.keys(indexedInputs).length;\n  const decodedIndexedInputs = Object.values(indexedInputs).map((input, index) => STATIC_TYPES.some(s => input.type.startsWith(s)) ? _decodeParameter(input.type, clonedTopics[index + offset]) : clonedTopics[index + offset]);\n  const returnValues = {\n    __length__: 0\n  };\n  let indexedCounter = 0;\n  let nonIndexedCounter = 0;\n  for (const [i, res] of inputs.entries()) {\n    returnValues[i] = res.type === 'string' ? '' : undefined;\n    if (indexedInputs[i]) {\n      returnValues[i] = decodedIndexedInputs[indexedCounter];\n      indexedCounter += 1;\n    }\n    if (nonIndexedInputs[i]) {\n      returnValues[i] = decodedNonIndexedInputs[String(nonIndexedCounter)];\n      nonIndexedCounter += 1;\n    }\n    if (res.name) {\n      returnValues[res.name] = returnValues[i];\n    }\n    returnValues.__length__ += 1;\n  }\n  return returnValues;\n};\n//# sourceMappingURL=logs_api.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}