{"ast":null,"code":"/**\n *  The available providers should suffice for most developers purposes,\n *  but the [[AbstractProvider]] class has many features which enable\n *  sub-classing it for specific purposes.\n *\n *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]\n */\n// @TODO\n// Event coalescence\n//   When we register an event with an async value (e.g. address is a Signer\n//   or ENS name), we need to add it immeidately for the Event API, but also\n//   need time to resolve the address. Upon resolving the address, we need to\n//   migrate the listener to the static event. We also need to maintain a map\n//   of Signer/ENS name to address so we can sync respond to listenerCount.\nimport { getAddress, resolveAddress } from \"../address/index.js\";\nimport { ZeroAddress } from \"../constants/index.js\";\nimport { Contract } from \"../contract/index.js\";\nimport { namehash } from \"../hash/index.js\";\nimport { Transaction } from \"../transaction/index.js\";\nimport { concat, dataLength, dataSlice, hexlify, isHexString, getBigInt, getBytes, getNumber, isCallException, isError, makeError, assert, assertArgument, FetchRequest, toBeArray, toQuantity, defineProperties, EventPayload, resolveProperties, toUtf8String } from \"../utils/index.js\";\nimport { EnsResolver } from \"./ens-resolver.js\";\nimport { formatBlock, formatLog, formatTransactionReceipt, formatTransactionResponse } from \"./format.js\";\nimport { Network } from \"./network.js\";\nimport { copyRequest, Block, FeeData, Log, TransactionReceipt, TransactionResponse } from \"./provider.js\";\nimport { PollingBlockSubscriber, PollingBlockTagSubscriber, PollingEventSubscriber, PollingOrphanSubscriber, PollingTransactionSubscriber } from \"./subscriber-polling.js\";\n// Constants\nconst BN_2 = BigInt(2);\nconst MAX_CCIP_REDIRECTS = 10;\nfunction isPromise(value) {\n  return value && typeof value.then === \"function\";\n}\nfunction getTag(prefix, value) {\n  return prefix + \":\" + JSON.stringify(value, (k, v) => {\n    if (v == null) {\n      return \"null\";\n    }\n    if (typeof v === \"bigint\") {\n      return `bigint:${v.toString()}`;\n    }\n    if (typeof v === \"string\") {\n      return v.toLowerCase();\n    }\n    // Sort object keys\n    if (typeof v === \"object\" && !Array.isArray(v)) {\n      const keys = Object.keys(v);\n      keys.sort();\n      return keys.reduce((accum, key) => {\n        accum[key] = v[key];\n        return accum;\n      }, {});\n    }\n    return v;\n  });\n}\n/**\n *  An **UnmanagedSubscriber** is useful for events which do not require\n *  any additional management, such as ``\"debug\"`` which only requires\n *  emit in synchronous event loop triggered calls.\n */\nexport class UnmanagedSubscriber {\n  /**\n   *  The name fof the event.\n   */\n  name;\n  /**\n   *  Create a new UnmanagedSubscriber with %%name%%.\n   */\n  constructor(name) {\n    defineProperties(this, {\n      name\n    });\n  }\n  start() {}\n  stop() {}\n  pause(dropWhilePaused) {}\n  resume() {}\n}\nfunction copy(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction concisify(items) {\n  items = Array.from(new Set(items).values());\n  items.sort();\n  return items;\n}\nasync function getSubscription(_event, provider) {\n  if (_event == null) {\n    throw new Error(\"invalid event\");\n  }\n  // Normalize topic array info an EventFilter\n  if (Array.isArray(_event)) {\n    _event = {\n      topics: _event\n    };\n  }\n  if (typeof _event === \"string\") {\n    switch (_event) {\n      case \"block\":\n      case \"debug\":\n      case \"error\":\n      case \"finalized\":\n      case \"network\":\n      case \"pending\":\n      case \"safe\":\n        {\n          return {\n            type: _event,\n            tag: _event\n          };\n        }\n    }\n  }\n  if (isHexString(_event, 32)) {\n    const hash = _event.toLowerCase();\n    return {\n      type: \"transaction\",\n      tag: getTag(\"tx\", {\n        hash\n      }),\n      hash\n    };\n  }\n  if (_event.orphan) {\n    const event = _event;\n    // @TODO: Should lowercase and whatnot things here instead of copy...\n    return {\n      type: \"orphan\",\n      tag: getTag(\"orphan\", event),\n      filter: copy(event)\n    };\n  }\n  if (_event.address || _event.topics) {\n    const event = _event;\n    const filter = {\n      topics: (event.topics || []).map(t => {\n        if (t == null) {\n          return null;\n        }\n        if (Array.isArray(t)) {\n          return concisify(t.map(t => t.toLowerCase()));\n        }\n        return t.toLowerCase();\n      })\n    };\n    if (event.address) {\n      const addresses = [];\n      const promises = [];\n      const addAddress = addr => {\n        if (isHexString(addr)) {\n          addresses.push(addr);\n        } else {\n          promises.push((async () => {\n            addresses.push(await resolveAddress(addr, provider));\n          })());\n        }\n      };\n      if (Array.isArray(event.address)) {\n        event.address.forEach(addAddress);\n      } else {\n        addAddress(event.address);\n      }\n      if (promises.length) {\n        await Promise.all(promises);\n      }\n      filter.address = concisify(addresses.map(a => a.toLowerCase()));\n    }\n    return {\n      filter,\n      tag: getTag(\"event\", filter),\n      type: \"event\"\n    };\n  }\n  assertArgument(false, \"unknown ProviderEvent\", \"event\", _event);\n}\nfunction getTime() {\n  return new Date().getTime();\n}\nconst defaultOptions = {\n  cacheTimeout: 250,\n  pollingInterval: 4000\n};\n/**\n *  An **AbstractProvider** provides a base class for other sub-classes to\n *  implement the [[Provider]] API by normalizing input arguments and\n *  formatting output results as well as tracking events for consistent\n *  behaviour on an eventually-consistent network.\n */\nexport class AbstractProvider {\n  #subs;\n  #plugins;\n  // null=unpaused, true=paused+dropWhilePaused, false=paused\n  #pausedState;\n  #destroyed;\n  #networkPromise;\n  #anyNetwork;\n  #performCache;\n  // The most recent block number if running an event or -1 if no \"block\" event\n  #lastBlockNumber;\n  #nextTimer;\n  #timers;\n  #disableCcipRead;\n  #options;\n  /**\n   *  Create a new **AbstractProvider** connected to %%network%%, or\n   *  use the various network detection capabilities to discover the\n   *  [[Network]] if necessary.\n   */\n  constructor(_network, options) {\n    this.#options = Object.assign({}, defaultOptions, options || {});\n    if (_network === \"any\") {\n      this.#anyNetwork = true;\n      this.#networkPromise = null;\n    } else if (_network) {\n      const network = Network.from(_network);\n      this.#anyNetwork = false;\n      this.#networkPromise = Promise.resolve(network);\n      setTimeout(() => {\n        this.emit(\"network\", network, null);\n      }, 0);\n    } else {\n      this.#anyNetwork = false;\n      this.#networkPromise = null;\n    }\n    this.#lastBlockNumber = -1;\n    this.#performCache = new Map();\n    this.#subs = new Map();\n    this.#plugins = new Map();\n    this.#pausedState = null;\n    this.#destroyed = false;\n    this.#nextTimer = 1;\n    this.#timers = new Map();\n    this.#disableCcipRead = false;\n  }\n  get pollingInterval() {\n    return this.#options.pollingInterval;\n  }\n  /**\n   *  Returns ``this``, to allow an **AbstractProvider** to implement\n   *  the [[ContractRunner]] interface.\n   */\n  get provider() {\n    return this;\n  }\n  /**\n   *  Returns all the registered plug-ins.\n   */\n  get plugins() {\n    return Array.from(this.#plugins.values());\n  }\n  /**\n   *  Attach a new plug-in.\n   */\n  attachPlugin(plugin) {\n    if (this.#plugins.get(plugin.name)) {\n      throw new Error(`cannot replace existing plugin: ${plugin.name} `);\n    }\n    this.#plugins.set(plugin.name, plugin.connect(this));\n    return this;\n  }\n  /**\n   *  Get a plugin by name.\n   */\n  getPlugin(name) {\n    return this.#plugins.get(name) || null;\n  }\n  /**\n   *  Prevent any CCIP-read operation, regardless of whether requested\n   *  in a [[call]] using ``enableCcipRead``.\n   */\n  get disableCcipRead() {\n    return this.#disableCcipRead;\n  }\n  set disableCcipRead(value) {\n    this.#disableCcipRead = !!value;\n  }\n  // Shares multiple identical requests made during the same 250ms\n  async #perform(req) {\n    const timeout = this.#options.cacheTimeout;\n    // Caching disabled\n    if (timeout < 0) {\n      return await this._perform(req);\n    }\n    // Create a tag\n    const tag = getTag(req.method, req);\n    let perform = this.#performCache.get(tag);\n    if (!perform) {\n      perform = this._perform(req);\n      this.#performCache.set(tag, perform);\n      setTimeout(() => {\n        if (this.#performCache.get(tag) === perform) {\n          this.#performCache.delete(tag);\n        }\n      }, timeout);\n    }\n    return await perform;\n  }\n  /**\n   *  Resolves to the data for executing the CCIP-read operations.\n   */\n  async ccipReadFetch(tx, calldata, urls) {\n    if (this.disableCcipRead || urls.length === 0 || tx.to == null) {\n      return null;\n    }\n    const sender = tx.to.toLowerCase();\n    const data = calldata.toLowerCase();\n    const errorMessages = [];\n    for (let i = 0; i < urls.length; i++) {\n      const url = urls[i];\n      // URL expansion\n      const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n      // If no {data} is present, use POST; otherwise GET\n      //const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n      //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n      //    value.status = response.statusCode;\n      //    return value;\n      //});\n      const request = new FetchRequest(href);\n      if (url.indexOf(\"{data}\") === -1) {\n        request.body = {\n          data,\n          sender\n        };\n      }\n      this.emit(\"debug\", {\n        action: \"sendCcipReadFetchRequest\",\n        request,\n        index: i,\n        urls\n      });\n      let errorMessage = \"unknown error\";\n      const resp = await request.send();\n      try {\n        const result = resp.bodyJson;\n        if (result.data) {\n          this.emit(\"debug\", {\n            action: \"receiveCcipReadFetchResult\",\n            request,\n            result\n          });\n          return result.data;\n        }\n        if (result.message) {\n          errorMessage = result.message;\n        }\n        this.emit(\"debug\", {\n          action: \"receiveCcipReadFetchError\",\n          request,\n          result\n        });\n      } catch (error) {}\n      // 4xx indicates the result is not present; stop\n      assert(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, \"OFFCHAIN_FAULT\", {\n        reason: \"404_MISSING_RESOURCE\",\n        transaction: tx,\n        info: {\n          url,\n          errorMessage\n        }\n      });\n      // 5xx indicates server issue; try the next url\n      errorMessages.push(errorMessage);\n    }\n    assert(false, `error encountered during CCIP fetch: ${errorMessages.map(m => JSON.stringify(m)).join(\", \")}`, \"OFFCHAIN_FAULT\", {\n      reason: \"500_SERVER_ERROR\",\n      transaction: tx,\n      info: {\n        urls,\n        errorMessages\n      }\n    });\n  }\n  /**\n   *  Provides the opportunity for a sub-class to wrap a block before\n   *  returning it, to add additional properties or an alternate\n   *  sub-class of [[Block]].\n   */\n  _wrapBlock(value, network) {\n    return new Block(formatBlock(value), this);\n  }\n  /**\n   *  Provides the opportunity for a sub-class to wrap a log before\n   *  returning it, to add additional properties or an alternate\n   *  sub-class of [[Log]].\n   */\n  _wrapLog(value, network) {\n    return new Log(formatLog(value), this);\n  }\n  /**\n   *  Provides the opportunity for a sub-class to wrap a transaction\n   *  receipt before returning it, to add additional properties or an\n   *  alternate sub-class of [[TransactionReceipt]].\n   */\n  _wrapTransactionReceipt(value, network) {\n    return new TransactionReceipt(formatTransactionReceipt(value), this);\n  }\n  /**\n   *  Provides the opportunity for a sub-class to wrap a transaction\n   *  response before returning it, to add additional properties or an\n   *  alternate sub-class of [[TransactionResponse]].\n   */\n  _wrapTransactionResponse(tx, network) {\n    return new TransactionResponse(formatTransactionResponse(tx), this);\n  }\n  /**\n   *  Resolves to the Network, forcing a network detection using whatever\n   *  technique the sub-class requires.\n   *\n   *  Sub-classes **must** override this.\n   */\n  _detectNetwork() {\n    assert(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"_detectNetwork\"\n    });\n  }\n  /**\n   *  Sub-classes should use this to perform all built-in operations. All\n   *  methods sanitizes and normalizes the values passed into this.\n   *\n   *  Sub-classes **must** override this.\n   */\n  async _perform(req) {\n    assert(false, `unsupported method: ${req.method}`, \"UNSUPPORTED_OPERATION\", {\n      operation: req.method,\n      info: req\n    });\n  }\n  // State\n  async getBlockNumber() {\n    const blockNumber = getNumber(await this.#perform({\n      method: \"getBlockNumber\"\n    }), \"%response\");\n    if (this.#lastBlockNumber >= 0) {\n      this.#lastBlockNumber = blockNumber;\n    }\n    return blockNumber;\n  }\n  /**\n   *  Returns or resolves to the address for %%address%%, resolving ENS\n   *  names and [[Addressable]] objects and returning if already an\n   *  address.\n   */\n  _getAddress(address) {\n    return resolveAddress(address, this);\n  }\n  /**\n   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving\n   *  negative values and returning if already a valid block tag.\n   */\n  _getBlockTag(blockTag) {\n    if (blockTag == null) {\n      return \"latest\";\n    }\n    switch (blockTag) {\n      case \"earliest\":\n        return \"0x0\";\n      case \"finalized\":\n      case \"latest\":\n      case \"pending\":\n      case \"safe\":\n        return blockTag;\n    }\n    if (isHexString(blockTag)) {\n      if (isHexString(blockTag, 32)) {\n        return blockTag;\n      }\n      return toQuantity(blockTag);\n    }\n    if (typeof blockTag === \"bigint\") {\n      blockTag = getNumber(blockTag, \"blockTag\");\n    }\n    if (typeof blockTag === \"number\") {\n      if (blockTag >= 0) {\n        return toQuantity(blockTag);\n      }\n      if (this.#lastBlockNumber >= 0) {\n        return toQuantity(this.#lastBlockNumber + blockTag);\n      }\n      return this.getBlockNumber().then(b => toQuantity(b + blockTag));\n    }\n    assertArgument(false, \"invalid blockTag\", \"blockTag\", blockTag);\n  }\n  /**\n   *  Returns or resolves to a filter for %%filter%%, resolving any ENS\n   *  names or [[Addressable]] object and returning if already a valid\n   *  filter.\n   */\n  _getFilter(filter) {\n    // Create a canonical representation of the topics\n    const topics = (filter.topics || []).map(t => {\n      if (t == null) {\n        return null;\n      }\n      if (Array.isArray(t)) {\n        return concisify(t.map(t => t.toLowerCase()));\n      }\n      return t.toLowerCase();\n    });\n    const blockHash = \"blockHash\" in filter ? filter.blockHash : undefined;\n    const resolve = (_address, fromBlock, toBlock) => {\n      let address = undefined;\n      switch (_address.length) {\n        case 0:\n          break;\n        case 1:\n          address = _address[0];\n          break;\n        default:\n          _address.sort();\n          address = _address;\n      }\n      if (blockHash) {\n        if (fromBlock != null || toBlock != null) {\n          throw new Error(\"invalid filter\");\n        }\n      }\n      const filter = {};\n      if (address) {\n        filter.address = address;\n      }\n      if (topics.length) {\n        filter.topics = topics;\n      }\n      if (fromBlock) {\n        filter.fromBlock = fromBlock;\n      }\n      if (toBlock) {\n        filter.toBlock = toBlock;\n      }\n      if (blockHash) {\n        filter.blockHash = blockHash;\n      }\n      return filter;\n    };\n    // Addresses could be async (ENS names or Addressables)\n    let address = [];\n    if (filter.address) {\n      if (Array.isArray(filter.address)) {\n        for (const addr of filter.address) {\n          address.push(this._getAddress(addr));\n        }\n      } else {\n        address.push(this._getAddress(filter.address));\n      }\n    }\n    let fromBlock = undefined;\n    if (\"fromBlock\" in filter) {\n      fromBlock = this._getBlockTag(filter.fromBlock);\n    }\n    let toBlock = undefined;\n    if (\"toBlock\" in filter) {\n      toBlock = this._getBlockTag(filter.toBlock);\n    }\n    if (address.filter(a => typeof a !== \"string\").length || fromBlock != null && typeof fromBlock !== \"string\" || toBlock != null && typeof toBlock !== \"string\") {\n      return Promise.all([Promise.all(address), fromBlock, toBlock]).then(result => {\n        return resolve(result[0], result[1], result[2]);\n      });\n    }\n    return resolve(address, fromBlock, toBlock);\n  }\n  /**\n   *  Returns or resolves to a transaction for %%request%%, resolving\n   *  any ENS names or [[Addressable]] and returning if already a valid\n   *  transaction.\n   */\n  _getTransactionRequest(_request) {\n    const request = copyRequest(_request);\n    const promises = [];\n    [\"to\", \"from\"].forEach(key => {\n      if (request[key] == null) {\n        return;\n      }\n      const addr = resolveAddress(request[key], this);\n      if (isPromise(addr)) {\n        promises.push(async function () {\n          request[key] = await addr;\n        }());\n      } else {\n        request[key] = addr;\n      }\n    });\n    if (request.blockTag != null) {\n      const blockTag = this._getBlockTag(request.blockTag);\n      if (isPromise(blockTag)) {\n        promises.push(async function () {\n          request.blockTag = await blockTag;\n        }());\n      } else {\n        request.blockTag = blockTag;\n      }\n    }\n    if (promises.length) {\n      return async function () {\n        await Promise.all(promises);\n        return request;\n      }();\n    }\n    return request;\n  }\n  async getNetwork() {\n    // No explicit network was set and this is our first time\n    if (this.#networkPromise == null) {\n      // Detect the current network (shared with all calls)\n      const detectNetwork = (async () => {\n        try {\n          const network = await this._detectNetwork();\n          this.emit(\"network\", network, null);\n          return network;\n        } catch (error) {\n          if (this.#networkPromise === detectNetwork) {\n            this.#networkPromise = null;\n          }\n          throw error;\n        }\n      })();\n      this.#networkPromise = detectNetwork;\n      return (await detectNetwork).clone();\n    }\n    const networkPromise = this.#networkPromise;\n    const [expected, actual] = await Promise.all([networkPromise, this._detectNetwork() // The actual connected network\n    ]);\n    if (expected.chainId !== actual.chainId) {\n      if (this.#anyNetwork) {\n        // The \"any\" network can change, so notify listeners\n        this.emit(\"network\", actual, expected);\n        // Update the network if something else hasn't already changed it\n        if (this.#networkPromise === networkPromise) {\n          this.#networkPromise = Promise.resolve(actual);\n        }\n      } else {\n        // Otherwise, we do not allow changes to the underlying network\n        assert(false, `network changed: ${expected.chainId} => ${actual.chainId} `, \"NETWORK_ERROR\", {\n          event: \"changed\"\n        });\n      }\n    }\n    return expected.clone();\n  }\n  async getFeeData() {\n    const network = await this.getNetwork();\n    const getFeeDataFunc = async () => {\n      const {\n        _block,\n        gasPrice,\n        priorityFee\n      } = await resolveProperties({\n        _block: this.#getBlock(\"latest\", false),\n        gasPrice: (async () => {\n          try {\n            const value = await this.#perform({\n              method: \"getGasPrice\"\n            });\n            return getBigInt(value, \"%response\");\n          } catch (error) {}\n          return null;\n        })(),\n        priorityFee: (async () => {\n          try {\n            const value = await this.#perform({\n              method: \"getPriorityFee\"\n            });\n            return getBigInt(value, \"%response\");\n          } catch (error) {}\n          return null;\n        })()\n      });\n      let maxFeePerGas = null;\n      let maxPriorityFeePerGas = null;\n      // These are the recommended EIP-1559 heuristics for fee data\n      const block = this._wrapBlock(_block, network);\n      if (block && block.baseFeePerGas) {\n        maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt(\"1000000000\");\n        maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;\n      }\n      return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);\n    };\n    // Check for a FeeDataNetWorkPlugin\n    const plugin = network.getPlugin(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n    if (plugin) {\n      const req = new FetchRequest(plugin.url);\n      const feeData = await plugin.processFunc(getFeeDataFunc, this, req);\n      return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);\n    }\n    return await getFeeDataFunc();\n  }\n  async estimateGas(_tx) {\n    let tx = this._getTransactionRequest(_tx);\n    if (isPromise(tx)) {\n      tx = await tx;\n    }\n    return getBigInt(await this.#perform({\n      method: \"estimateGas\",\n      transaction: tx\n    }), \"%response\");\n  }\n  async #call(tx, blockTag, attempt) {\n    assert(attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n      reason: \"TOO_MANY_REDIRECTS\",\n      transaction: Object.assign({}, tx, {\n        blockTag,\n        enableCcipRead: true\n      })\n    });\n    // This came in as a PerformActionTransaction, so to/from are safe; we can cast\n    const transaction = copyRequest(tx);\n    try {\n      return hexlify(await this._perform({\n        method: \"call\",\n        transaction,\n        blockTag\n      }));\n    } catch (error) {\n      // CCIP Read OffchainLookup\n      if (!this.disableCcipRead && isCallException(error) && error.data && attempt >= 0 && blockTag === \"latest\" && transaction.to != null && dataSlice(error.data, 0, 4) === \"0x556f1830\") {\n        const data = error.data;\n        const txSender = await resolveAddress(transaction.to, this);\n        // Parse the CCIP Read Arguments\n        let ccipArgs;\n        try {\n          ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));\n        } catch (error) {\n          assert(false, error.message, \"OFFCHAIN_FAULT\", {\n            reason: \"BAD_DATA\",\n            transaction,\n            info: {\n              data\n            }\n          });\n        }\n        // Check the sender of the OffchainLookup matches the transaction\n        assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), \"CCIP Read sender mismatch\", \"CALL_EXCEPTION\", {\n          action: \"call\",\n          data,\n          reason: \"OffchainLookup\",\n          transaction: transaction,\n          invocation: null,\n          revert: {\n            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n            name: \"OffchainLookup\",\n            args: ccipArgs.errorArgs\n          }\n        });\n        const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);\n        assert(ccipResult != null, \"CCIP Read failed to fetch data\", \"OFFCHAIN_FAULT\", {\n          reason: \"FETCH_FAILED\",\n          transaction,\n          info: {\n            data: error.data,\n            errorArgs: ccipArgs.errorArgs\n          }\n        });\n        const tx = {\n          to: txSender,\n          data: concat([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])\n        };\n        this.emit(\"debug\", {\n          action: \"sendCcipReadCall\",\n          transaction: tx\n        });\n        try {\n          const result = await this.#call(tx, blockTag, attempt + 1);\n          this.emit(\"debug\", {\n            action: \"receiveCcipReadCallResult\",\n            transaction: Object.assign({}, tx),\n            result\n          });\n          return result;\n        } catch (error) {\n          this.emit(\"debug\", {\n            action: \"receiveCcipReadCallError\",\n            transaction: Object.assign({}, tx),\n            error\n          });\n          throw error;\n        }\n      }\n      throw error;\n    }\n  }\n  async #checkNetwork(promise) {\n    const {\n      value\n    } = await resolveProperties({\n      network: this.getNetwork(),\n      value: promise\n    });\n    return value;\n  }\n  async call(_tx) {\n    const {\n      tx,\n      blockTag\n    } = await resolveProperties({\n      tx: this._getTransactionRequest(_tx),\n      blockTag: this._getBlockTag(_tx.blockTag)\n    });\n    return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));\n  }\n  // Account\n  async #getAccountValue(request, _address, _blockTag) {\n    let address = this._getAddress(_address);\n    let blockTag = this._getBlockTag(_blockTag);\n    if (typeof address !== \"string\" || typeof blockTag !== \"string\") {\n      [address, blockTag] = await Promise.all([address, blockTag]);\n    }\n    return await this.#checkNetwork(this.#perform(Object.assign(request, {\n      address,\n      blockTag\n    })));\n  }\n  async getBalance(address, blockTag) {\n    return getBigInt(await this.#getAccountValue({\n      method: \"getBalance\"\n    }, address, blockTag), \"%response\");\n  }\n  async getTransactionCount(address, blockTag) {\n    return getNumber(await this.#getAccountValue({\n      method: \"getTransactionCount\"\n    }, address, blockTag), \"%response\");\n  }\n  async getCode(address, blockTag) {\n    return hexlify(await this.#getAccountValue({\n      method: \"getCode\"\n    }, address, blockTag));\n  }\n  async getStorage(address, _position, blockTag) {\n    const position = getBigInt(_position, \"position\");\n    return hexlify(await this.#getAccountValue({\n      method: \"getStorage\",\n      position\n    }, address, blockTag));\n  }\n  // Write\n  async broadcastTransaction(signedTx) {\n    const {\n      blockNumber,\n      hash,\n      network\n    } = await resolveProperties({\n      blockNumber: this.getBlockNumber(),\n      hash: this._perform({\n        method: \"broadcastTransaction\",\n        signedTransaction: signedTx\n      }),\n      network: this.getNetwork()\n    });\n    const tx = Transaction.from(signedTx);\n    if (tx.hash !== hash) {\n      throw new Error(\"@TODO: the returned hash did not match\");\n    }\n    return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);\n  }\n  async #getBlock(block, includeTransactions) {\n    // @TODO: Add CustomBlockPlugin check\n    if (isHexString(block, 32)) {\n      return await this.#perform({\n        method: \"getBlock\",\n        blockHash: block,\n        includeTransactions\n      });\n    }\n    let blockTag = this._getBlockTag(block);\n    if (typeof blockTag !== \"string\") {\n      blockTag = await blockTag;\n    }\n    return await this.#perform({\n      method: \"getBlock\",\n      blockTag,\n      includeTransactions\n    });\n  }\n  // Queries\n  async getBlock(block, prefetchTxs) {\n    const {\n      network,\n      params\n    } = await resolveProperties({\n      network: this.getNetwork(),\n      params: this.#getBlock(block, !!prefetchTxs)\n    });\n    if (params == null) {\n      return null;\n    }\n    return this._wrapBlock(params, network);\n  }\n  async getTransaction(hash) {\n    const {\n      network,\n      params\n    } = await resolveProperties({\n      network: this.getNetwork(),\n      params: this.#perform({\n        method: \"getTransaction\",\n        hash\n      })\n    });\n    if (params == null) {\n      return null;\n    }\n    return this._wrapTransactionResponse(params, network);\n  }\n  async getTransactionReceipt(hash) {\n    const {\n      network,\n      params\n    } = await resolveProperties({\n      network: this.getNetwork(),\n      params: this.#perform({\n        method: \"getTransactionReceipt\",\n        hash\n      })\n    });\n    if (params == null) {\n      return null;\n    }\n    // Some backends did not backfill the effectiveGasPrice into old transactions\n    // in the receipt, so we look it up manually and inject it.\n    if (params.gasPrice == null && params.effectiveGasPrice == null) {\n      const tx = await this.#perform({\n        method: \"getTransaction\",\n        hash\n      });\n      if (tx == null) {\n        throw new Error(\"report this; could not find tx or effectiveGasPrice\");\n      }\n      params.effectiveGasPrice = tx.gasPrice;\n    }\n    return this._wrapTransactionReceipt(params, network);\n  }\n  async getTransactionResult(hash) {\n    const {\n      result\n    } = await resolveProperties({\n      network: this.getNetwork(),\n      result: this.#perform({\n        method: \"getTransactionResult\",\n        hash\n      })\n    });\n    if (result == null) {\n      return null;\n    }\n    return hexlify(result);\n  }\n  // Bloom-filter Queries\n  async getLogs(_filter) {\n    let filter = this._getFilter(_filter);\n    if (isPromise(filter)) {\n      filter = await filter;\n    }\n    const {\n      network,\n      params\n    } = await resolveProperties({\n      network: this.getNetwork(),\n      params: this.#perform({\n        method: \"getLogs\",\n        filter\n      })\n    });\n    return params.map(p => this._wrapLog(p, network));\n  }\n  // ENS\n  _getProvider(chainId) {\n    assert(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"_getProvider()\"\n    });\n  }\n  async getResolver(name) {\n    return await EnsResolver.fromName(this, name);\n  }\n  async getAvatar(name) {\n    const resolver = await this.getResolver(name);\n    if (resolver) {\n      return await resolver.getAvatar();\n    }\n    return null;\n  }\n  async resolveName(name) {\n    const resolver = await this.getResolver(name);\n    if (resolver) {\n      return await resolver.getAddress();\n    }\n    return null;\n  }\n  async lookupAddress(address) {\n    address = getAddress(address);\n    const node = namehash(address.substring(2).toLowerCase() + \".addr.reverse\");\n    try {\n      const ensAddr = await EnsResolver.getEnsAddress(this);\n      const ensContract = new Contract(ensAddr, [\"function resolver(bytes32) view returns (address)\"], this);\n      const resolver = await ensContract.resolver(node);\n      if (resolver == null || resolver === ZeroAddress) {\n        return null;\n      }\n      const resolverContract = new Contract(resolver, [\"function name(bytes32) view returns (string)\"], this);\n      const name = await resolverContract.name(node);\n      // Failed forward resolution\n      const check = await this.resolveName(name);\n      if (check !== address) {\n        return null;\n      }\n      return name;\n    } catch (error) {\n      // No data was returned from the resolver\n      if (isError(error, \"BAD_DATA\") && error.value === \"0x\") {\n        return null;\n      }\n      // Something reerted\n      if (isError(error, \"CALL_EXCEPTION\")) {\n        return null;\n      }\n      throw error;\n    }\n    return null;\n  }\n  async waitForTransaction(hash, _confirms, timeout) {\n    const confirms = _confirms != null ? _confirms : 1;\n    if (confirms === 0) {\n      return this.getTransactionReceipt(hash);\n    }\n    return new Promise(async (resolve, reject) => {\n      let timer = null;\n      const listener = async blockNumber => {\n        try {\n          const receipt = await this.getTransactionReceipt(hash);\n          if (receipt != null) {\n            if (blockNumber - receipt.blockNumber + 1 >= confirms) {\n              resolve(receipt);\n              //this.off(\"block\", listener);\n              if (timer) {\n                clearTimeout(timer);\n                timer = null;\n              }\n              return;\n            }\n          }\n        } catch (error) {\n          console.log(\"EEE\", error);\n        }\n        this.once(\"block\", listener);\n      };\n      if (timeout != null) {\n        timer = setTimeout(() => {\n          if (timer == null) {\n            return;\n          }\n          timer = null;\n          this.off(\"block\", listener);\n          reject(makeError(\"timeout\", \"TIMEOUT\", {\n            reason: \"timeout\"\n          }));\n        }, timeout);\n      }\n      listener(await this.getBlockNumber());\n    });\n  }\n  async waitForBlock(blockTag) {\n    assert(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n      operation: \"waitForBlock\"\n    });\n  }\n  /**\n   *  Clear a timer created using the [[_setTimeout]] method.\n   */\n  _clearTimeout(timerId) {\n    const timer = this.#timers.get(timerId);\n    if (!timer) {\n      return;\n    }\n    if (timer.timer) {\n      clearTimeout(timer.timer);\n    }\n    this.#timers.delete(timerId);\n  }\n  /**\n   *  Create a timer that will execute %%func%% after at least %%timeout%%\n   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute\n   *  in the next event loop.\n   *\n   *  [Pausing](AbstractProvider-paused) the provider will pause any\n   *  associated timers.\n   */\n  _setTimeout(_func, timeout) {\n    if (timeout == null) {\n      timeout = 0;\n    }\n    const timerId = this.#nextTimer++;\n    const func = () => {\n      this.#timers.delete(timerId);\n      _func();\n    };\n    if (this.paused) {\n      this.#timers.set(timerId, {\n        timer: null,\n        func,\n        time: timeout\n      });\n    } else {\n      const timer = setTimeout(func, timeout);\n      this.#timers.set(timerId, {\n        timer,\n        func,\n        time: getTime()\n      });\n    }\n    return timerId;\n  }\n  /**\n   *  Perform %%func%% on each subscriber.\n   */\n  _forEachSubscriber(func) {\n    for (const sub of this.#subs.values()) {\n      func(sub.subscriber);\n    }\n  }\n  /**\n   *  Sub-classes may override this to customize subscription\n   *  implementations.\n   */\n  _getSubscriber(sub) {\n    switch (sub.type) {\n      case \"debug\":\n      case \"error\":\n      case \"network\":\n        return new UnmanagedSubscriber(sub.type);\n      case \"block\":\n        {\n          const subscriber = new PollingBlockSubscriber(this);\n          subscriber.pollingInterval = this.pollingInterval;\n          return subscriber;\n        }\n      case \"safe\":\n      case \"finalized\":\n        return new PollingBlockTagSubscriber(this, sub.type);\n      case \"event\":\n        return new PollingEventSubscriber(this, sub.filter);\n      case \"transaction\":\n        return new PollingTransactionSubscriber(this, sub.hash);\n      case \"orphan\":\n        return new PollingOrphanSubscriber(this, sub.filter);\n    }\n    throw new Error(`unsupported event: ${sub.type}`);\n  }\n  /**\n   *  If a [[Subscriber]] fails and needs to replace itself, this\n   *  method may be used.\n   *\n   *  For example, this is used for providers when using the\n   *  ``eth_getFilterChanges`` method, which can return null if state\n   *  filters are not supported by the backend, allowing the Subscriber\n   *  to swap in a [[PollingEventSubscriber]].\n   */\n  _recoverSubscriber(oldSub, newSub) {\n    for (const sub of this.#subs.values()) {\n      if (sub.subscriber === oldSub) {\n        if (sub.started) {\n          sub.subscriber.stop();\n        }\n        sub.subscriber = newSub;\n        if (sub.started) {\n          newSub.start();\n        }\n        if (this.#pausedState != null) {\n          newSub.pause(this.#pausedState);\n        }\n        break;\n      }\n    }\n  }\n  async #hasSub(event, emitArgs) {\n    let sub = await getSubscription(event, this);\n    // This is a log that is removing an existing log; we actually want\n    // to emit an orphan event for the removed log\n    if (sub.type === \"event\" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {\n      sub = await getSubscription({\n        orphan: \"drop-log\",\n        log: emitArgs[0]\n      }, this);\n    }\n    return this.#subs.get(sub.tag) || null;\n  }\n  async #getSub(event) {\n    const subscription = await getSubscription(event, this);\n    // Prevent tampering with our tag in any subclass' _getSubscriber\n    const tag = subscription.tag;\n    let sub = this.#subs.get(tag);\n    if (!sub) {\n      const subscriber = this._getSubscriber(subscription);\n      const addressableMap = new WeakMap();\n      const nameMap = new Map();\n      sub = {\n        subscriber,\n        tag,\n        addressableMap,\n        nameMap,\n        started: false,\n        listeners: []\n      };\n      this.#subs.set(tag, sub);\n    }\n    return sub;\n  }\n  async on(event, listener) {\n    const sub = await this.#getSub(event);\n    sub.listeners.push({\n      listener,\n      once: false\n    });\n    if (!sub.started) {\n      sub.subscriber.start();\n      sub.started = true;\n      if (this.#pausedState != null) {\n        sub.subscriber.pause(this.#pausedState);\n      }\n    }\n    return this;\n  }\n  async once(event, listener) {\n    const sub = await this.#getSub(event);\n    sub.listeners.push({\n      listener,\n      once: true\n    });\n    if (!sub.started) {\n      sub.subscriber.start();\n      sub.started = true;\n      if (this.#pausedState != null) {\n        sub.subscriber.pause(this.#pausedState);\n      }\n    }\n    return this;\n  }\n  async emit(event, ...args) {\n    const sub = await this.#hasSub(event, args);\n    // If there is not subscription or if a recent emit removed\n    // the last of them (which also deleted the sub) do nothing\n    if (!sub || sub.listeners.length === 0) {\n      return false;\n    }\n    ;\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter(({\n      listener,\n      once\n    }) => {\n      const payload = new EventPayload(this, once ? null : listener, event);\n      try {\n        listener.call(this, ...args, payload);\n      } catch (error) {}\n      return !once;\n    });\n    if (sub.listeners.length === 0) {\n      if (sub.started) {\n        sub.subscriber.stop();\n      }\n      this.#subs.delete(sub.tag);\n    }\n    return count > 0;\n  }\n  async listenerCount(event) {\n    if (event) {\n      const sub = await this.#hasSub(event);\n      if (!sub) {\n        return 0;\n      }\n      return sub.listeners.length;\n    }\n    let total = 0;\n    for (const {\n      listeners\n    } of this.#subs.values()) {\n      total += listeners.length;\n    }\n    return total;\n  }\n  async listeners(event) {\n    if (event) {\n      const sub = await this.#hasSub(event);\n      if (!sub) {\n        return [];\n      }\n      return sub.listeners.map(({\n        listener\n      }) => listener);\n    }\n    let result = [];\n    for (const {\n      listeners\n    } of this.#subs.values()) {\n      result = result.concat(listeners.map(({\n        listener\n      }) => listener));\n    }\n    return result;\n  }\n  async off(event, listener) {\n    const sub = await this.#hasSub(event);\n    if (!sub) {\n      return this;\n    }\n    if (listener) {\n      const index = sub.listeners.map(({\n        listener\n      }) => listener).indexOf(listener);\n      if (index >= 0) {\n        sub.listeners.splice(index, 1);\n      }\n    }\n    if (!listener || sub.listeners.length === 0) {\n      if (sub.started) {\n        sub.subscriber.stop();\n      }\n      this.#subs.delete(sub.tag);\n    }\n    return this;\n  }\n  async removeAllListeners(event) {\n    if (event) {\n      const {\n        tag,\n        started,\n        subscriber\n      } = await this.#getSub(event);\n      if (started) {\n        subscriber.stop();\n      }\n      this.#subs.delete(tag);\n    } else {\n      for (const [tag, {\n        started,\n        subscriber\n      }] of this.#subs) {\n        if (started) {\n          subscriber.stop();\n        }\n        this.#subs.delete(tag);\n      }\n    }\n    return this;\n  }\n  // Alias for \"on\"\n  async addListener(event, listener) {\n    return await this.on(event, listener);\n  }\n  // Alias for \"off\"\n  async removeListener(event, listener) {\n    return this.off(event, listener);\n  }\n  /**\n   *  If this provider has been destroyed using the [[destroy]] method.\n   *\n   *  Once destroyed, all resources are reclaimed, internal event loops\n   *  and timers are cleaned up and no further requests may be sent to\n   *  the provider.\n   */\n  get destroyed() {\n    return this.#destroyed;\n  }\n  /**\n   *  Sub-classes may use this to shutdown any sockets or release their\n   *  resources and reject any pending requests.\n   *\n   *  Sub-classes **must** call ``super.destroy()``.\n   */\n  destroy() {\n    // Stop all listeners\n    this.removeAllListeners();\n    // Shut down all tiemrs\n    for (const timerId of this.#timers.keys()) {\n      this._clearTimeout(timerId);\n    }\n    this.#destroyed = true;\n  }\n  /**\n   *  Whether the provider is currently paused.\n   *\n   *  A paused provider will not emit any events, and generally should\n   *  not make any requests to the network, but that is up to sub-classes\n   *  to manage.\n   *\n   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,\n   *  which will buffer any events that occur while paused until the\n   *  provider is unpaused.\n   */\n  get paused() {\n    return this.#pausedState != null;\n  }\n  set paused(pause) {\n    if (!!pause === this.paused) {\n      return;\n    }\n    if (this.paused) {\n      this.resume();\n    } else {\n      this.pause(false);\n    }\n  }\n  /**\n   *  Pause the provider. If %%dropWhilePaused%%, any events that occur\n   *  while paused are dropped, otherwise all events will be emitted once\n   *  the provider is unpaused.\n   */\n  pause(dropWhilePaused) {\n    this.#lastBlockNumber = -1;\n    if (this.#pausedState != null) {\n      if (this.#pausedState == !!dropWhilePaused) {\n        return;\n      }\n      assert(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"pause\"\n      });\n    }\n    this._forEachSubscriber(s => s.pause(dropWhilePaused));\n    this.#pausedState = !!dropWhilePaused;\n    for (const timer of this.#timers.values()) {\n      // Clear the timer\n      if (timer.timer) {\n        clearTimeout(timer.timer);\n      }\n      // Remaining time needed for when we become unpaused\n      timer.time = getTime() - timer.time;\n    }\n  }\n  /**\n   *  Resume the provider.\n   */\n  resume() {\n    if (this.#pausedState == null) {\n      return;\n    }\n    this._forEachSubscriber(s => s.resume());\n    this.#pausedState = null;\n    for (const timer of this.#timers.values()) {\n      // Remaining time when we were paused\n      let timeout = timer.time;\n      if (timeout < 0) {\n        timeout = 0;\n      }\n      // Start time (in cause paused, so we con compute remaininf time)\n      timer.time = getTime();\n      // Start the timer\n      setTimeout(timer.func, timeout);\n    }\n  }\n}\nfunction _parseString(result, start) {\n  try {\n    const bytes = _parseBytes(result, start);\n    if (bytes) {\n      return toUtf8String(bytes);\n    }\n  } catch (error) {}\n  return null;\n}\nfunction _parseBytes(result, start) {\n  if (result === \"0x\") {\n    return null;\n  }\n  try {\n    const offset = getNumber(dataSlice(result, start, start + 32));\n    const length = getNumber(dataSlice(result, offset, offset + 32));\n    return dataSlice(result, offset + 32, offset + 32 + length);\n  } catch (error) {}\n  return null;\n}\nfunction numPad(value) {\n  const result = toBeArray(value);\n  if (result.length > 32) {\n    throw new Error(\"internal; should not happen\");\n  }\n  const padded = new Uint8Array(32);\n  padded.set(result, 32 - result.length);\n  return padded;\n}\nfunction bytesPad(value) {\n  if (value.length % 32 === 0) {\n    return value;\n  }\n  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n  result.set(value);\n  return result;\n}\nconst empty = new Uint8Array([]);\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n  const result = [];\n  let byteCount = 0;\n  // Add place-holders for pointers as we add items\n  for (let i = 0; i < datas.length; i++) {\n    result.push(empty);\n    byteCount += 32;\n  }\n  for (let i = 0; i < datas.length; i++) {\n    const data = getBytes(datas[i]);\n    // Update the bytes offset\n    result[i] = numPad(byteCount);\n    // The length and padded value of data\n    result.push(numPad(data.length));\n    result.push(bytesPad(data));\n    byteCount += 32 + Math.ceil(data.length / 32) * 32;\n  }\n  return concat(result);\n}\nconst zeros = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\nfunction parseOffchainLookup(data) {\n  const result = {\n    sender: \"\",\n    urls: [],\n    calldata: \"\",\n    selector: \"\",\n    extraData: \"\",\n    errorArgs: []\n  };\n  assert(dataLength(data) >= 5 * 32, \"insufficient OffchainLookup data\", \"OFFCHAIN_FAULT\", {\n    reason: \"insufficient OffchainLookup data\"\n  });\n  const sender = dataSlice(data, 0, 32);\n  assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), \"corrupt OffchainLookup sender\", \"OFFCHAIN_FAULT\", {\n    reason: \"corrupt OffchainLookup sender\"\n  });\n  result.sender = dataSlice(sender, 12);\n  // Read the URLs from the response\n  try {\n    const urls = [];\n    const urlsOffset = getNumber(dataSlice(data, 32, 64));\n    const urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));\n    const urlsData = dataSlice(data, urlsOffset + 32);\n    for (let u = 0; u < urlsLength; u++) {\n      const url = _parseString(urlsData, u * 32);\n      if (url == null) {\n        throw new Error(\"abort\");\n      }\n      urls.push(url);\n    }\n    result.urls = urls;\n  } catch (error) {\n    assert(false, \"corrupt OffchainLookup urls\", \"OFFCHAIN_FAULT\", {\n      reason: \"corrupt OffchainLookup urls\"\n    });\n  }\n  // Get the CCIP calldata to forward\n  try {\n    const calldata = _parseBytes(data, 64);\n    if (calldata == null) {\n      throw new Error(\"abort\");\n    }\n    result.calldata = calldata;\n  } catch (error) {\n    assert(false, \"corrupt OffchainLookup calldata\", \"OFFCHAIN_FAULT\", {\n      reason: \"corrupt OffchainLookup calldata\"\n    });\n  }\n  // Get the callbackSelector (bytes4)\n  assert(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), \"corrupt OffchainLookup callbaackSelector\", \"OFFCHAIN_FAULT\", {\n    reason: \"corrupt OffchainLookup callbaackSelector\"\n  });\n  result.selector = dataSlice(data, 96, 100);\n  // Get the extra data to send back to the contract as context\n  try {\n    const extraData = _parseBytes(data, 128);\n    if (extraData == null) {\n      throw new Error(\"abort\");\n    }\n    result.extraData = extraData;\n  } catch (error) {\n    assert(false, \"corrupt OffchainLookup extraData\", \"OFFCHAIN_FAULT\", {\n      reason: \"corrupt OffchainLookup extraData\"\n    });\n  }\n  result.errorArgs = \"sender,urls,calldata,selector,extraData\".split(/,/).map(k => result[k]);\n  return result;\n}\n//# sourceMappingURL=abstract-provider.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}