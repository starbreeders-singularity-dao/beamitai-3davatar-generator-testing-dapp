{"ast":null,"code":"import { crypto as cr } from \"@noble/hashes/crypto\";\nimport { concatBytes, equalsBytes } from \"./utils.js\";\nconst crypto = {\n  web: cr\n};\nfunction validateOpt(key, iv, mode) {\n  if (!mode.startsWith(\"aes-\")) {\n    throw new Error(`AES submodule doesn't support mode ${mode}`);\n  }\n  if (iv.length !== 16) {\n    throw new Error(\"AES: wrong IV length\");\n  }\n  if (mode.startsWith(\"aes-128\") && key.length !== 16 || mode.startsWith(\"aes-256\") && key.length !== 32) {\n    throw new Error(\"AES: wrong key length\");\n  }\n}\nasync function getBrowserKey(mode, key, iv) {\n  if (!crypto.web) {\n    throw new Error(\"Browser crypto not available.\");\n  }\n  let keyMode;\n  if ([\"aes-128-cbc\", \"aes-256-cbc\"].includes(mode)) {\n    keyMode = \"cbc\";\n  }\n  if ([\"aes-128-ctr\", \"aes-256-ctr\"].includes(mode)) {\n    keyMode = \"ctr\";\n  }\n  if (!keyMode) {\n    throw new Error(\"AES: unsupported mode\");\n  }\n  const wKey = await crypto.web.subtle.importKey(\"raw\", key, {\n    name: `AES-${keyMode.toUpperCase()}`,\n    length: key.length * 8\n  }, true, [\"encrypt\", \"decrypt\"]);\n  // node.js uses whole 128 bit as a counter, without nonce, instead of 64 bit\n  // recommended by NIST SP800-38A\n  return [wKey, {\n    name: `aes-${keyMode}`,\n    iv,\n    counter: iv,\n    length: 128\n  }];\n}\nexport async function encrypt(msg, key, iv, mode = \"aes-128-ctr\", pkcs7PaddingEnabled = true) {\n  validateOpt(key, iv, mode);\n  if (crypto.web) {\n    const [wKey, wOpt] = await getBrowserKey(mode, key, iv);\n    const cipher = await crypto.web.subtle.encrypt(wOpt, wKey, msg);\n    // Remove PKCS7 padding on cbc mode by stripping end of message\n    let res = new Uint8Array(cipher);\n    if (!pkcs7PaddingEnabled && wOpt.name === \"aes-cbc\" && !(msg.length % 16)) {\n      res = res.slice(0, -16);\n    }\n    return res;\n  } else if (crypto.node) {\n    const cipher = crypto.node.createCipheriv(mode, key, iv);\n    cipher.setAutoPadding(pkcs7PaddingEnabled);\n    return concatBytes(cipher.update(msg), cipher.final());\n  } else {\n    throw new Error(\"The environment doesn't have AES module\");\n  }\n}\nasync function getPadding(cypherText, key, iv, mode) {\n  const lastBlock = cypherText.slice(-16);\n  for (let i = 0; i < 16; i++) {\n    // Undo xor of iv and fill with lastBlock ^ padding (16)\n    lastBlock[i] ^= iv[i] ^ 16;\n  }\n  const res = await encrypt(lastBlock, key, iv, mode);\n  return res.slice(0, 16);\n}\nexport async function decrypt(cypherText, key, iv, mode = \"aes-128-ctr\", pkcs7PaddingEnabled = true) {\n  validateOpt(key, iv, mode);\n  if (crypto.web) {\n    const [wKey, wOpt] = await getBrowserKey(mode, key, iv);\n    // Add empty padding so Chrome will correctly decrypt message\n    if (!pkcs7PaddingEnabled && wOpt.name === \"aes-cbc\") {\n      const padding = await getPadding(cypherText, key, iv, mode);\n      cypherText = concatBytes(cypherText, padding);\n    }\n    const msg = await crypto.web.subtle.decrypt(wOpt, wKey, cypherText);\n    const msgBytes = new Uint8Array(msg);\n    // Safari always ignores padding (if no padding -> broken message)\n    if (wOpt.name === \"aes-cbc\") {\n      const encrypted = await encrypt(msgBytes, key, iv, mode);\n      if (!equalsBytes(encrypted, cypherText)) {\n        throw new Error(\"AES: wrong padding\");\n      }\n    }\n    return msgBytes;\n  } else if (crypto.node) {\n    const decipher = crypto.node.createDecipheriv(mode, key, iv);\n    decipher.setAutoPadding(pkcs7PaddingEnabled);\n    return concatBytes(decipher.update(cypherText), decipher.final());\n  } else {\n    throw new Error(\"The environment doesn't have AES module\");\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}