{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { ContractExecutionError, InvalidResponseError, ProviderError, ResponseError, rpcErrorsMap, RpcError } from 'web3-errors';\nimport HttpProvider from 'web3-providers-http';\nimport WSProvider from 'web3-providers-ws';\nimport { isNullish, isPromise, jsonRpc, isResponseRpcError } from 'web3-utils';\nimport { isEIP1193Provider, isLegacyRequestProvider, isLegacySendAsyncProvider, isLegacySendProvider, isWeb3Provider } from './utils.js';\nimport { Web3EventEmitter } from './web3_event_emitter.js';\nexport var Web3RequestManagerEvent;\n(function (Web3RequestManagerEvent) {\n  Web3RequestManagerEvent[\"PROVIDER_CHANGED\"] = \"PROVIDER_CHANGED\";\n  Web3RequestManagerEvent[\"BEFORE_PROVIDER_CHANGE\"] = \"BEFORE_PROVIDER_CHANGE\";\n})(Web3RequestManagerEvent || (Web3RequestManagerEvent = {}));\nconst availableProviders = {\n  HttpProvider: HttpProvider,\n  WebsocketProvider: WSProvider\n};\nexport class Web3RequestManager extends Web3EventEmitter {\n  constructor(provider, useRpcCallSpecification, requestManagerMiddleware) {\n    super();\n    if (!isNullish(provider)) {\n      this.setProvider(provider);\n    }\n    this.useRpcCallSpecification = useRpcCallSpecification;\n    if (!isNullish(requestManagerMiddleware)) this.middleware = requestManagerMiddleware;\n  }\n  /**\n   * Will return all available providers\n   */\n  static get providers() {\n    return availableProviders;\n  }\n  /**\n   * Will return the current provider.\n   *\n   * @returns Returns the current provider\n   */\n  get provider() {\n    return this._provider;\n  }\n  /**\n   * Will return all available providers\n   */\n  // eslint-disable-next-line class-methods-use-this\n  get providers() {\n    return availableProviders;\n  }\n  /**\n   * Use to set provider. Provider can be a provider instance or a string.\n   *\n   * @param provider - The provider to set\n   */\n  setProvider(provider) {\n    let newProvider;\n    // autodetect provider\n    if (provider && typeof provider === 'string' && this.providers) {\n      // HTTP\n      if (/^http(s)?:\\/\\//i.test(provider)) {\n        newProvider = new this.providers.HttpProvider(provider);\n        // WS\n      } else if (/^ws(s)?:\\/\\//i.test(provider)) {\n        newProvider = new this.providers.WebsocketProvider(provider);\n      } else {\n        throw new ProviderError(`Can't autodetect provider for \"${provider}\"`);\n      }\n    } else if (isNullish(provider)) {\n      // In case want to unset the provider\n      newProvider = undefined;\n    } else {\n      newProvider = provider;\n    }\n    this.emit(Web3RequestManagerEvent.BEFORE_PROVIDER_CHANGE, this._provider);\n    this._provider = newProvider;\n    this.emit(Web3RequestManagerEvent.PROVIDER_CHANGED, this._provider);\n    return true;\n  }\n  setMiddleware(requestManagerMiddleware) {\n    this.middleware = requestManagerMiddleware;\n  }\n  /**\n   *\n   * Will execute a request\n   *\n   * @param request - {@link Web3APIRequest} The request to send\n   *\n   * @returns The response of the request {@link ResponseType}. If there is error\n   * in the response, will throw an error\n   */\n  send(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const requestObj = Object.assign({}, request);\n      let response = yield this._sendRequest(requestObj);\n      if (!isNullish(this.middleware)) response = yield this.middleware.processResponse(response);\n      if (jsonRpc.isResponseWithResult(response)) {\n        return response.result;\n      }\n      throw new ResponseError(response);\n    });\n  }\n  /**\n   * Same as send, but, will execute a batch of requests\n   *\n   * @param request {@link JsonRpcBatchRequest} The batch request to send\n   */\n  sendBatch(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const response = yield this._sendRequest(request);\n      return response;\n    });\n  }\n  _sendRequest(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        provider\n      } = this;\n      if (isNullish(provider)) {\n        throw new ProviderError('Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.');\n      }\n      let payload = jsonRpc.isBatchRequest(request) ? jsonRpc.toBatchPayload(request) : jsonRpc.toPayload(request);\n      if (!isNullish(this.middleware)) {\n        payload = yield this.middleware.processRequest(payload);\n      }\n      if (isWeb3Provider(provider)) {\n        let response;\n        try {\n          response = yield provider.request(payload);\n        } catch (error) {\n          // Check if the provider throw an error instead of reject with error\n          response = error;\n        }\n        return this._processJsonRpcResponse(payload, response, {\n          legacy: false,\n          error: false\n        });\n      }\n      if (isEIP1193Provider(provider)) {\n        return provider.request(payload).then(res => this._processJsonRpcResponse(payload, res, {\n          legacy: true,\n          error: false\n        })).catch(error => this._processJsonRpcResponse(payload, error, {\n          legacy: true,\n          error: true\n        }));\n      }\n      // TODO: This could be deprecated and removed.\n      if (isLegacyRequestProvider(provider)) {\n        return new Promise((resolve, reject) => {\n          const rejectWithError = err => {\n            reject(this._processJsonRpcResponse(payload, err, {\n              legacy: true,\n              error: true\n            }));\n          };\n          const resolveWithResponse = response => resolve(this._processJsonRpcResponse(payload, response, {\n            legacy: true,\n            error: false\n          }));\n          const result = provider.request(payload,\n          // a callback that is expected to be called after getting the response:\n          (err, response) => {\n            if (err) {\n              return rejectWithError(err);\n            }\n            return resolveWithResponse(response);\n          });\n          // Some providers, that follow a previous drafted version of EIP1193, has a `request` function\n          //\tthat is not defined as `async`, but it returns a promise.\n          // Such providers would not be picked with if(isEIP1193Provider(provider)) above\n          //\tbecause the `request` function was not defined with `async` and so the function definition is not `AsyncFunction`.\n          // Like this provider: https://github.dev/NomicFoundation/hardhat/blob/62bea2600785595ba36f2105564076cf5cdf0fd8/packages/hardhat-core/src/internal/core/providers/backwards-compatibility.ts#L19\n          // So check if the returned result is a Promise, and resolve with it accordingly.\n          // Note: in this case we expect the callback provided above to never be called.\n          if (isPromise(result)) {\n            const responsePromise = result;\n            responsePromise.then(resolveWithResponse).catch(error => {\n              try {\n                // Attempt to process the error response\n                const processedError = this._processJsonRpcResponse(payload, error, {\n                  legacy: true,\n                  error: true\n                });\n                reject(processedError);\n              } catch (processingError) {\n                // Catch any errors that occur during the error processing\n                reject(processingError);\n              }\n            });\n          }\n        });\n      }\n      // TODO: This could be deprecated and removed.\n      if (isLegacySendProvider(provider)) {\n        return new Promise((resolve, reject) => {\n          provider.send(payload, (err, response) => {\n            if (err) {\n              return reject(this._processJsonRpcResponse(payload, err, {\n                legacy: true,\n                error: true\n              }));\n            }\n            if (isNullish(response)) {\n              throw new ResponseError({}, 'Got a \"nullish\" response from provider.');\n            }\n            return resolve(this._processJsonRpcResponse(payload, response, {\n              legacy: true,\n              error: false\n            }));\n          });\n        });\n      }\n      // TODO: This could be deprecated and removed.\n      if (isLegacySendAsyncProvider(provider)) {\n        return provider.sendAsync(payload).then(response => this._processJsonRpcResponse(payload, response, {\n          legacy: true,\n          error: false\n        })).catch(error => this._processJsonRpcResponse(payload, error, {\n          legacy: true,\n          error: true\n        }));\n      }\n      throw new ProviderError('Provider does not have a request or send method to use.');\n    });\n  }\n  // eslint-disable-next-line class-methods-use-this\n  _processJsonRpcResponse(payload, response, {\n    legacy,\n    error\n  }) {\n    if (isNullish(response)) {\n      return this._buildResponse(payload,\n      // Some providers uses \"null\" as valid empty response\n      // eslint-disable-next-line no-null/no-null\n      null, error);\n    }\n    // This is the majority of the cases so check these first\n    // A valid JSON-RPC response with error object\n    if (jsonRpc.isResponseWithError(response)) {\n      // check if its an rpc error\n      if (this.useRpcCallSpecification && isResponseRpcError(response)) {\n        const rpcErrorResponse = response;\n        // check if rpc error flag is on and response error code match an EIP-1474 or a standard rpc error code\n        if (rpcErrorsMap.get(rpcErrorResponse.error.code)) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const Err = rpcErrorsMap.get(rpcErrorResponse.error.code).error;\n          throw new Err(rpcErrorResponse);\n        } else {\n          throw new RpcError(rpcErrorResponse);\n        }\n      } else if (!Web3RequestManager._isReverted(response)) {\n        throw new InvalidResponseError(response, payload);\n      }\n    }\n    // This is the majority of the cases so check these first\n    // A valid JSON-RPC response with result object\n    if (jsonRpc.isResponseWithResult(response)) {\n      return response;\n    }\n    if (response instanceof Error) {\n      Web3RequestManager._isReverted(response);\n      throw response;\n    }\n    if (!legacy && jsonRpc.isBatchRequest(payload) && jsonRpc.isBatchResponse(response)) {\n      return response;\n    }\n    if (legacy && !error && jsonRpc.isBatchRequest(payload)) {\n      return response;\n    }\n    if (legacy && error && jsonRpc.isBatchRequest(payload)) {\n      // In case of error batch response we don't want to throw Invalid response\n      throw response;\n    }\n    if (legacy && !jsonRpc.isResponseWithError(response) && !jsonRpc.isResponseWithResult(response)) {\n      return this._buildResponse(payload, response, error);\n    }\n    if (jsonRpc.isBatchRequest(payload) && !Array.isArray(response)) {\n      throw new ResponseError(response, 'Got normal response for a batch request.');\n    }\n    if (!jsonRpc.isBatchRequest(payload) && Array.isArray(response)) {\n      throw new ResponseError(response, 'Got batch response for a normal request.');\n    }\n    throw new ResponseError(response, 'Invalid response');\n  }\n  static _isReverted(response) {\n    let error;\n    if (jsonRpc.isResponseWithError(response)) {\n      error = response.error;\n    } else if (response instanceof Error) {\n      error = response;\n    }\n    // This message means that there was an error while executing the code of the smart contract\n    // However, more processing will happen at a higher level to decode the error data,\n    //\taccording to the Error ABI, if it was available as of EIP-838.\n    if (error === null || error === void 0 ? void 0 : error.message.includes('revert')) throw new ContractExecutionError(error);\n    return false;\n  }\n  // Need to use same types as _processJsonRpcResponse so have to declare as instance method\n  // eslint-disable-next-line class-methods-use-this\n  _buildResponse(payload, response, error) {\n    const res = {\n      jsonrpc: '2.0',\n      // eslint-disable-next-line no-nested-ternary\n      id: jsonRpc.isBatchRequest(payload) ? payload[0].id : 'id' in payload ? payload.id :\n      // Have to use the null here explicitly\n      // eslint-disable-next-line no-null/no-null\n      null\n    };\n    if (error) {\n      return Object.assign(Object.assign({}, res), {\n        error: response\n      });\n    }\n    return Object.assign(Object.assign({}, res), {\n      result: response\n    });\n  }\n}\n//# sourceMappingURL=web3_request_manager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}