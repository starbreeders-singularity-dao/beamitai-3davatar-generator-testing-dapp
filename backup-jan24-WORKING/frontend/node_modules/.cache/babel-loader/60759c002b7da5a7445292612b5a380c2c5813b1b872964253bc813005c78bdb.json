{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { rejectIfConditionAtInterval } from 'web3-utils';\nimport { TransactionBlockTimeoutError } from 'web3-errors';\nimport { NUMBER_DATA_FORMAT } from '../constants.js';\n// eslint-disable-next-line import/no-cycle\nimport { getBlockNumber } from '../rpc_method_wrappers.js';\nfunction resolveByPolling(web3Context, starterBlockNumber, transactionHash) {\n  const pollingInterval = web3Context.transactionPollingInterval;\n  const [intervalId, promiseToError] = rejectIfConditionAtInterval(() => __awaiter(this, void 0, void 0, function* () {\n    let lastBlockNumber;\n    try {\n      lastBlockNumber = yield getBlockNumber(web3Context, NUMBER_DATA_FORMAT);\n    } catch (error) {\n      console.warn('An error happen while trying to get the block number', error);\n      return undefined;\n    }\n    const numberOfBlocks = lastBlockNumber - starterBlockNumber;\n    if (numberOfBlocks >= web3Context.transactionBlockTimeout) {\n      return new TransactionBlockTimeoutError({\n        starterBlockNumber,\n        numberOfBlocks,\n        transactionHash\n      });\n    }\n    return undefined;\n  }), pollingInterval);\n  const clean = () => {\n    clearInterval(intervalId);\n  };\n  return [promiseToError, {\n    clean\n  }];\n}\nfunction resolveBySubscription(web3Context, starterBlockNumber, transactionHash) {\n  return __awaiter(this, void 0, void 0, function* () {\n    var _a;\n    // The following variable will stay true except if the data arrived,\n    //\tor if watching started after an error had occurred.\n    let needToWatchLater = true;\n    let subscription;\n    let resourceCleaner;\n    // internal helper function\n    function revertToPolling(reject, previousError) {\n      if (previousError) {\n        console.warn('error happened at subscription. So revert to polling...', previousError);\n      }\n      resourceCleaner.clean();\n      needToWatchLater = false;\n      const [promiseToError, newResourceCleaner] = resolveByPolling(web3Context, starterBlockNumber, transactionHash);\n      resourceCleaner.clean = newResourceCleaner.clean;\n      promiseToError.catch(error => reject(error));\n    }\n    try {\n      subscription = yield (_a = web3Context.subscriptionManager) === null || _a === void 0 ? void 0 : _a.subscribe('newHeads');\n      resourceCleaner = {\n        clean: () => {\n          var _a;\n          // Remove the subscription, if it was not removed somewhere\n          // \telse by calling, for example, subscriptionManager.clear()\n          if (subscription.id) {\n            (_a = web3Context.subscriptionManager) === null || _a === void 0 ? void 0 : _a.removeSubscription(subscription).then(() => {\n              // Subscription ended successfully\n            }).catch(() => {\n              // An error happened while ending subscription. But no need to take any action.\n            });\n          }\n        }\n      };\n    } catch (error) {\n      return resolveByPolling(web3Context, starterBlockNumber, transactionHash);\n    }\n    const promiseToError = new Promise((_, reject) => {\n      try {\n        subscription.on('data', lastBlockHeader => {\n          needToWatchLater = false;\n          if (!(lastBlockHeader === null || lastBlockHeader === void 0 ? void 0 : lastBlockHeader.number)) {\n            return;\n          }\n          const numberOfBlocks = Number(BigInt(lastBlockHeader.number) - BigInt(starterBlockNumber));\n          if (numberOfBlocks >= web3Context.transactionBlockTimeout) {\n            // Transaction Block Timeout is known to be reached by subscribing to new heads\n            reject(new TransactionBlockTimeoutError({\n              starterBlockNumber,\n              numberOfBlocks,\n              transactionHash\n            }));\n          }\n        });\n        subscription.on('error', error => {\n          revertToPolling(reject, error);\n        });\n      } catch (error) {\n        revertToPolling(reject, error);\n      }\n      // Fallback to polling if tx receipt didn't arrived in \"blockHeaderTimeout\" [10 seconds]\n      setTimeout(() => {\n        if (needToWatchLater) {\n          revertToPolling(reject);\n        }\n      }, web3Context.blockHeaderTimeout * 1000);\n    });\n    return [promiseToError, resourceCleaner];\n  });\n}\n/* TODO: After merge, there will be constant block mining time (exactly 12 second each block, except slot missed that currently happens in <1% of slots. ) so we can optimize following function\nfor POS NWs, we can skip checking getBlockNumber(); after interval and calculate only based on time  that certain num of blocked are mined after that for internal double check, can do one getBlockNumber() call and timeout.\n*/\nexport function rejectIfBlockTimeout(web3Context, transactionHash) {\n  return __awaiter(this, void 0, void 0, function* () {\n    var _a, _b;\n    const {\n      provider\n    } = web3Context.requestManager;\n    let callingRes;\n    const starterBlockNumber = yield getBlockNumber(web3Context, NUMBER_DATA_FORMAT);\n    // TODO: once https://github.com/web3/web3.js/issues/5521 is implemented, remove checking for `enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout`\n    if (((_b = (_a = provider).supportsSubscriptions) === null || _b === void 0 ? void 0 : _b.call(_a)) && web3Context.enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      callingRes = yield resolveBySubscription(web3Context, starterBlockNumber, transactionHash);\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      callingRes = resolveByPolling(web3Context, starterBlockNumber, transactionHash);\n    }\n    return callingRes;\n  });\n}\n//# sourceMappingURL=reject_if_block_timeout.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}