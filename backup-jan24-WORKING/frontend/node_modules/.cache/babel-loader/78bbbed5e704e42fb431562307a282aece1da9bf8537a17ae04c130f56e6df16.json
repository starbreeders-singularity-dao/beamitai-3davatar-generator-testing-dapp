{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { ETH_DATA_FORMAT } from 'web3-types';\nimport { isAddress, isHexStrict, isHexString32Bytes, isNullish, isUInt } from 'web3-validator';\nimport { ChainMismatchError, HardforkMismatchError, ChainIdMismatchError, CommonOrChainAndHardforkError, Eip1559GasPriceError, InvalidGasOrGasPrice, InvalidMaxPriorityFeePerGasOrMaxFeePerGas, InvalidNonceOrChainIdError, InvalidTransactionCall, InvalidTransactionObjectError, InvalidTransactionWithSender, MissingChainOrHardforkError, MissingCustomChainError, MissingCustomChainIdError, MissingGasError, TransactionGasMismatchError, UnsupportedFeeMarketError } from 'web3-errors';\nimport { formatTransaction } from './utils/format_transaction.js';\nexport function isBaseTransaction(value) {\n  if (!isNullish(value.to) && !isAddress(value.to)) return false;\n  if (!isHexStrict(value.type) && !isNullish(value.type) && value.type.length !== 2) return false;\n  if (!isHexStrict(value.nonce)) return false;\n  if (!isHexStrict(value.gas)) return false;\n  if (!isHexStrict(value.value)) return false;\n  if (!isHexStrict(value.input)) return false;\n  if (value.chainId && !isHexStrict(value.chainId)) return false;\n  return true;\n}\nexport function isAccessListEntry(value) {\n  if (!isNullish(value.address) && !isAddress(value.address)) return false;\n  if (!isNullish(value.storageKeys) && !value.storageKeys.every(storageKey => isHexString32Bytes(storageKey))) return false;\n  return true;\n}\nexport function isAccessList(value) {\n  if (!Array.isArray(value) || !value.every(accessListEntry => isAccessListEntry(accessListEntry))) return false;\n  return true;\n}\nexport function isTransaction1559Unsigned(value) {\n  if (!isBaseTransaction(value)) return false;\n  if (!isHexStrict(value.maxFeePerGas)) return false;\n  if (!isHexStrict(value.maxPriorityFeePerGas)) return false;\n  if (!isAccessList(value.accessList)) return false;\n  return true;\n}\nexport function isTransaction2930Unsigned(value) {\n  if (!isBaseTransaction(value)) return false;\n  if (!isHexStrict(value.gasPrice)) return false;\n  if (!isAccessList(value.accessList)) return false;\n  return true;\n}\nexport function isTransactionLegacyUnsigned(value) {\n  if (!isBaseTransaction(value)) return false;\n  if (!isHexStrict(value.gasPrice)) return false;\n  return true;\n}\nexport function isTransactionWithSender(value) {\n  if (!isAddress(value.from)) return false;\n  if (!isBaseTransaction(value)) return false;\n  if (!isTransaction1559Unsigned(value) && !isTransaction2930Unsigned(value) && !isTransactionLegacyUnsigned(value)) return false;\n  return true;\n}\nexport function validateTransactionWithSender(value) {\n  if (!isTransactionWithSender(value)) throw new InvalidTransactionWithSender(value);\n}\nexport function isTransactionCall(value) {\n  if (!isNullish(value.from) && !isAddress(value.from)) return false;\n  if (!isAddress(value.to)) return false;\n  if (!isNullish(value.gas) && !isHexStrict(value.gas)) return false;\n  if (!isNullish(value.gasPrice) && !isHexStrict(value.gasPrice)) return false;\n  if (!isNullish(value.value) && !isHexStrict(value.value)) return false;\n  if (!isNullish(value.data) && !isHexStrict(value.data)) return false;\n  if (!isNullish(value.input) && !isHexStrict(value.input)) return false;\n  if (!isNullish(value.type)) return false;\n  if (isTransaction1559Unsigned(value)) return false;\n  if (isTransaction2930Unsigned(value)) return false;\n  return true;\n}\nexport function validateTransactionCall(value) {\n  if (!isTransactionCall(value)) throw new InvalidTransactionCall(value);\n}\nexport const validateCustomChainInfo = transaction => {\n  if (!isNullish(transaction.common)) {\n    if (isNullish(transaction.common.customChain)) throw new MissingCustomChainError();\n    if (isNullish(transaction.common.customChain.chainId)) throw new MissingCustomChainIdError();\n    if (!isNullish(transaction.chainId) && transaction.chainId !== transaction.common.customChain.chainId) throw new ChainIdMismatchError({\n      txChainId: transaction.chainId,\n      customChainId: transaction.common.customChain.chainId\n    });\n  }\n};\nexport const validateChainInfo = transaction => {\n  if (!isNullish(transaction.common) && !isNullish(transaction.chain) && !isNullish(transaction.hardfork)) {\n    throw new CommonOrChainAndHardforkError();\n  }\n  if (!isNullish(transaction.chain) && isNullish(transaction.hardfork) || !isNullish(transaction.hardfork) && isNullish(transaction.chain)) throw new MissingChainOrHardforkError({\n    chain: transaction.chain,\n    hardfork: transaction.hardfork\n  });\n};\nexport const validateBaseChain = transaction => {\n  if (!isNullish(transaction.common)) if (!isNullish(transaction.common.baseChain)) if (!isNullish(transaction.chain) && transaction.chain !== transaction.common.baseChain) {\n    throw new ChainMismatchError({\n      txChain: transaction.chain,\n      baseChain: transaction.common.baseChain\n    });\n  }\n};\nexport const validateHardfork = transaction => {\n  if (!isNullish(transaction.common)) if (!isNullish(transaction.common.hardfork)) if (!isNullish(transaction.hardfork) && transaction.hardfork !== transaction.common.hardfork) {\n    throw new HardforkMismatchError({\n      txHardfork: transaction.hardfork,\n      commonHardfork: transaction.common.hardfork\n    });\n  }\n};\nexport const validateLegacyGas = transaction => {\n  if (\n  // This check is verifying gas and gasPrice aren't less than 0.\n  isNullish(transaction.gas) || !isUInt(transaction.gas) || isNullish(transaction.gasPrice) || !isUInt(transaction.gasPrice)) throw new InvalidGasOrGasPrice({\n    gas: transaction.gas,\n    gasPrice: transaction.gasPrice\n  });\n  if (!isNullish(transaction.maxFeePerGas) || !isNullish(transaction.maxPriorityFeePerGas)) throw new UnsupportedFeeMarketError({\n    maxFeePerGas: transaction.maxFeePerGas,\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas\n  });\n};\nexport const validateFeeMarketGas = transaction => {\n  // These errors come from 1.x, so they must be checked before\n  // InvalidMaxPriorityFeePerGasOrMaxFeePerGas to throw the same error\n  // for the same code executing in 1.x\n  if (!isNullish(transaction.gasPrice) && transaction.type === '0x2') throw new Eip1559GasPriceError(transaction.gasPrice);\n  if (transaction.type === '0x0' || transaction.type === '0x1') throw new UnsupportedFeeMarketError({\n    maxFeePerGas: transaction.maxFeePerGas,\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas\n  });\n  if (isNullish(transaction.maxFeePerGas) || !isUInt(transaction.maxFeePerGas) || isNullish(transaction.maxPriorityFeePerGas) || !isUInt(transaction.maxPriorityFeePerGas)) throw new InvalidMaxPriorityFeePerGasOrMaxFeePerGas({\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,\n    maxFeePerGas: transaction.maxFeePerGas\n  });\n};\n/**\n * This method checks if all required gas properties are present for either\n * legacy gas (type 0x0 and 0x1) OR fee market transactions (0x2)\n */\nexport const validateGas = transaction => {\n  const gasPresent = !isNullish(transaction.gas) || !isNullish(transaction.gasLimit);\n  const legacyGasPresent = gasPresent && !isNullish(transaction.gasPrice);\n  const feeMarketGasPresent = gasPresent && !isNullish(transaction.maxPriorityFeePerGas) && !isNullish(transaction.maxFeePerGas);\n  if (!legacyGasPresent && !feeMarketGasPresent) throw new MissingGasError({\n    gas: transaction.gas,\n    gasPrice: transaction.gasPrice,\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,\n    maxFeePerGas: transaction.maxFeePerGas\n  });\n  if (legacyGasPresent && feeMarketGasPresent) throw new TransactionGasMismatchError({\n    gas: transaction.gas,\n    gasPrice: transaction.gasPrice,\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,\n    maxFeePerGas: transaction.maxFeePerGas\n  });\n  (legacyGasPresent ? validateLegacyGas : validateFeeMarketGas)(transaction);\n  (!isNullish(transaction.type) && transaction.type > '0x1' ? validateFeeMarketGas : validateLegacyGas)(transaction);\n};\nexport const validateTransactionForSigning = (transaction, overrideMethod, options = {\n  transactionSchema: undefined\n}) => {\n  if (!isNullish(overrideMethod)) {\n    overrideMethod(transaction);\n    return;\n  }\n  if (typeof transaction !== 'object' || isNullish(transaction)) throw new InvalidTransactionObjectError(transaction);\n  validateCustomChainInfo(transaction);\n  validateChainInfo(transaction);\n  validateBaseChain(transaction);\n  validateHardfork(transaction);\n  const formattedTransaction = formatTransaction(transaction, ETH_DATA_FORMAT, {\n    transactionSchema: options.transactionSchema\n  });\n  validateGas(formattedTransaction);\n  if (isNullish(formattedTransaction.nonce) || isNullish(formattedTransaction.chainId) || formattedTransaction.nonce.startsWith('-') || formattedTransaction.chainId.startsWith('-')) throw new InvalidNonceOrChainIdError({\n    nonce: transaction.nonce,\n    chainId: transaction.chainId\n  });\n};\n//# sourceMappingURL=validation.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}