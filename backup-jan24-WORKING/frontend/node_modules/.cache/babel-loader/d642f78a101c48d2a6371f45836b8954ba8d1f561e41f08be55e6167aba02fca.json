{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { AbiError } from 'web3-errors';\nimport { bytesToHex, bytesToUint8Array } from 'web3-utils';\nimport { isBytes } from 'web3-validator';\nimport { alloc, WORD_SIZE } from '../utils.js';\nimport { decodeNumber, encodeNumber } from './number.js';\nconst MAX_STATIC_BYTES_COUNT = 32;\nexport function encodeBytes(param, input) {\n  // hack for odd length hex strings\n  if (typeof input === 'string' && input.length % 2 !== 0) {\n    // eslint-disable-next-line no-param-reassign\n    input += '0';\n  }\n  if (!isBytes(input)) {\n    throw new AbiError('provided input is not valid bytes value', {\n      type: param.type,\n      value: input,\n      name: param.name\n    });\n  }\n  const bytes = bytesToUint8Array(input);\n  const [, size] = param.type.split('bytes');\n  // fixed size\n  if (size) {\n    if (Number(size) > MAX_STATIC_BYTES_COUNT || Number(size) < 1) {\n      throw new AbiError('invalid bytes type. Static byte type can have between 1 and 32 bytes', {\n        type: param.type\n      });\n    }\n    if (Number(size) < bytes.length) {\n      throw new AbiError('provided input size is different than type size', {\n        type: param.type,\n        value: input,\n        name: param.name\n      });\n    }\n    const encoded = alloc(WORD_SIZE);\n    encoded.set(bytes);\n    return {\n      dynamic: false,\n      encoded\n    };\n  }\n  const partsLength = Math.ceil(bytes.length / WORD_SIZE);\n  // one word for length of data + WORD for each part of actual data\n  const encoded = alloc(WORD_SIZE + partsLength * WORD_SIZE);\n  encoded.set(encodeNumber({\n    type: 'uint32',\n    name: ''\n  }, bytes.length).encoded);\n  encoded.set(bytes, WORD_SIZE);\n  return {\n    dynamic: true,\n    encoded\n  };\n}\nexport function decodeBytes(param, bytes) {\n  const [, sizeString] = param.type.split('bytes');\n  let size = Number(sizeString);\n  let remainingBytes = bytes;\n  let partsCount = 1;\n  let consumed = 0;\n  if (!size) {\n    // dynamic bytes\n    const result = decodeNumber({\n      type: 'uint32',\n      name: ''\n    }, remainingBytes);\n    size = Number(result.result);\n    consumed += result.consumed;\n    remainingBytes = result.encoded;\n    partsCount = Math.ceil(size / WORD_SIZE);\n  }\n  if (size > bytes.length) {\n    throw new AbiError('there is not enough data to decode', {\n      type: param.type,\n      encoded: bytes,\n      size\n    });\n  }\n  return {\n    result: bytesToHex(remainingBytes.subarray(0, size)),\n    encoded: remainingBytes.subarray(partsCount * WORD_SIZE),\n    consumed: consumed + partsCount * WORD_SIZE\n  };\n}\n//# sourceMappingURL=bytes.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}