{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { jsonRpc, Web3DeferredPromise } from 'web3-utils';\nimport { OperationAbortError, OperationTimeoutError, ResponseError } from 'web3-errors';\nexport const DEFAULT_BATCH_REQUEST_TIMEOUT = 1000;\nexport class Web3BatchRequest {\n  constructor(requestManager) {\n    this._requestManager = requestManager;\n    this._requests = new Map();\n  }\n  get requests() {\n    return [...this._requests.values()].map(r => r.payload);\n  }\n  add(request) {\n    const payload = jsonRpc.toPayload(request);\n    const promise = new Web3DeferredPromise();\n    this._requests.set(payload.id, {\n      payload,\n      promise\n    });\n    return promise;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  execute(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (this.requests.length === 0) {\n        return Promise.resolve([]);\n      }\n      const request = new Web3DeferredPromise({\n        timeout: (_a = options === null || options === void 0 ? void 0 : options.timeout) !== null && _a !== void 0 ? _a : DEFAULT_BATCH_REQUEST_TIMEOUT,\n        eagerStart: true,\n        timeoutMessage: 'Batch request timeout'\n      });\n      this._processBatchRequest(request).catch(err => request.reject(err));\n      request.catch(err => {\n        if (err instanceof OperationTimeoutError) {\n          this._abortAllRequests('Batch request timeout');\n        }\n        request.reject(err);\n      });\n      return request;\n    });\n  }\n  _processBatchRequest(promise) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n      const response = yield this._requestManager.sendBatch([...this._requests.values()].map(r => r.payload));\n      if (response.length !== this._requests.size) {\n        this._abortAllRequests('Invalid batch response');\n        throw new ResponseError(response, `Batch request size mismatch the results size. Requests: ${this._requests.size}, Responses: ${response.length}`);\n      }\n      const requestIds = this.requests.map(r => r.id).map(Number).sort((a, b) => a - b);\n      const responseIds = response.map(r => r.id).map(Number).sort((a, b) => a - b);\n      if (JSON.stringify(requestIds) !== JSON.stringify(responseIds)) {\n        this._abortAllRequests('Invalid batch response');\n        throw new ResponseError(response, `Batch request mismatch the results. Requests: [${requestIds.join()}], Responses: [${responseIds.join()}]`);\n      }\n      for (const res of response) {\n        if (jsonRpc.isResponseWithResult(res)) {\n          (_a = this._requests.get(res.id)) === null || _a === void 0 ? void 0 : _a.promise.resolve(res.result);\n        } else if (jsonRpc.isResponseWithError(res)) {\n          (_b = this._requests.get(res.id)) === null || _b === void 0 ? void 0 : _b.promise.reject(res.error);\n        }\n      }\n      promise.resolve(response);\n    });\n  }\n  _abortAllRequests(msg) {\n    for (const {\n      promise\n    } of this._requests.values()) {\n      promise.reject(new OperationAbortError(msg));\n    }\n  }\n}\n//# sourceMappingURL=web3_batch_request.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}