{"ast":null,"code":"import * as React from 'react';\nimport { useState, useContext, useRef, useLayoutEffect, createContext } from 'react';\nimport { useFrame } from '@react-three/fiber';\nconst context = /* @__PURE__ */createContext(null);\nfunction PerformanceMonitor({\n  iterations = 10,\n  ms = 250,\n  threshold = 0.75,\n  step = 0.1,\n  factor: _factor = 0.5,\n  flipflops = Infinity,\n  bounds = refreshrate => refreshrate > 100 ? [60, 100] : [40, 60],\n  onIncline,\n  onDecline,\n  onChange,\n  onFallback,\n  children\n}) {\n  const decimalPlacesRatio = Math.pow(10, 0);\n  const [api, _] = useState(() => ({\n    fps: 0,\n    index: 0,\n    factor: _factor,\n    flipped: 0,\n    refreshrate: 0,\n    fallback: false,\n    frames: [],\n    averages: [],\n    subscriptions: new Map(),\n    subscribe: ref => {\n      const key = Symbol();\n      api.subscriptions.set(key, ref.current);\n      return () => void api.subscriptions.delete(key);\n    }\n  }));\n  let lastFactor = 0;\n  useFrame(() => {\n    const {\n      frames,\n      averages\n    } = api;\n\n    // If the fallback has been reached do not continue running samples\n    if (api.fallback) return;\n    if (averages.length < iterations) {\n      frames.push(performance.now());\n      const msPassed = frames[frames.length - 1] - frames[0];\n      if (msPassed >= ms) {\n        api.fps = Math.round(frames.length / msPassed * 1000 * decimalPlacesRatio) / decimalPlacesRatio;\n        api.refreshrate = Math.max(api.refreshrate, api.fps);\n        averages[api.index++ % iterations] = api.fps;\n        if (averages.length === iterations) {\n          const [lower, upper] = bounds(api.refreshrate);\n          const upperBounds = averages.filter(value => value >= upper);\n          const lowerBounds = averages.filter(value => value < lower);\n          // Trigger incline when more than -threshold- avgs exceed the upper bound\n          if (upperBounds.length > iterations * threshold) {\n            api.factor = Math.min(1, api.factor + step);\n            api.flipped++;\n            if (onIncline) onIncline(api);\n            api.subscriptions.forEach(value => value.onIncline && value.onIncline(api));\n          }\n          // Trigger decline when more than -threshold- avgs are below the lower bound\n          if (lowerBounds.length > iterations * threshold) {\n            api.factor = Math.max(0, api.factor - step);\n            api.flipped++;\n            if (onDecline) onDecline(api);\n            api.subscriptions.forEach(value => value.onDecline && value.onDecline(api));\n          }\n          if (lastFactor !== api.factor) {\n            lastFactor = api.factor;\n            if (onChange) onChange(api);\n            api.subscriptions.forEach(value => value.onChange && value.onChange(api));\n          }\n          if (api.flipped > flipflops && !api.fallback) {\n            api.fallback = true;\n            if (onFallback) onFallback(api);\n            api.subscriptions.forEach(value => value.onFallback && value.onFallback(api));\n          }\n          api.averages = [];\n\n          // Resetting the refreshrate creates more problems than it solves atm\n          // api.refreshrate = 0\n        }\n        api.frames = [];\n      }\n    }\n  });\n  return /*#__PURE__*/React.createElement(context.Provider, {\n    value: api\n  }, children);\n}\nfunction usePerformanceMonitor({\n  onIncline,\n  onDecline,\n  onChange,\n  onFallback\n}) {\n  const api = useContext(context);\n  const ref = useRef({\n    onIncline,\n    onDecline,\n    onChange,\n    onFallback\n  });\n  useLayoutEffect(() => {\n    ref.current.onIncline = onIncline;\n    ref.current.onDecline = onDecline;\n    ref.current.onChange = onChange;\n    ref.current.onFallback = onFallback;\n  }, [onIncline, onDecline, onChange, onFallback]);\n  useLayoutEffect(() => api.subscribe(ref), [api]);\n}\nexport { PerformanceMonitor, usePerformanceMonitor };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}