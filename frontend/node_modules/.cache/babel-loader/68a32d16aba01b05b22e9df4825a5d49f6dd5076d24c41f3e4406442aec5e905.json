{"ast":null,"code":"import { Box3, Vector3 } from 'three';\nimport { TRAVERSAL_COST, TRIANGLE_INTERSECT_COST } from '../core/Constants.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nconst _box1 = /* @__PURE__ */new Box3();\nconst _box2 = /* @__PURE__ */new Box3();\nconst _vec = /* @__PURE__ */new Vector3();\n\n// https://stackoverflow.com/questions/1248302/how-to-get-the-size-of-a-javascript-object\nfunction getPrimitiveSize(el) {\n  switch (typeof el) {\n    case 'number':\n      return 8;\n    case 'string':\n      return el.length * 2;\n    case 'boolean':\n      return 4;\n    default:\n      return 0;\n  }\n}\nfunction isTypedArray(arr) {\n  const regex = /(Uint|Int|Float)(8|16|32)Array/;\n  return regex.test(arr.constructor.name);\n}\nfunction getRootExtremes(bvh, group) {\n  const result = {\n    nodeCount: 0,\n    leafNodeCount: 0,\n    depth: {\n      min: Infinity,\n      max: -Infinity\n    },\n    tris: {\n      min: Infinity,\n      max: -Infinity\n    },\n    splits: [0, 0, 0],\n    surfaceAreaScore: 0\n  };\n  bvh.traverse((depth, isLeaf, boundingData, offsetOrSplit, count) => {\n    const l0 = boundingData[0 + 3] - boundingData[0];\n    const l1 = boundingData[1 + 3] - boundingData[1];\n    const l2 = boundingData[2 + 3] - boundingData[2];\n    const surfaceArea = 2 * (l0 * l1 + l1 * l2 + l2 * l0);\n    result.nodeCount++;\n    if (isLeaf) {\n      result.leafNodeCount++;\n      result.depth.min = Math.min(depth, result.depth.min);\n      result.depth.max = Math.max(depth, result.depth.max);\n      result.tris.min = Math.min(count, result.tris.min);\n      result.tris.max = Math.max(count, result.tris.max);\n      result.surfaceAreaScore += surfaceArea * TRIANGLE_INTERSECT_COST * count;\n    } else {\n      result.splits[offsetOrSplit]++;\n      result.surfaceAreaScore += surfaceArea * TRAVERSAL_COST;\n    }\n  }, group);\n\n  // If there are no leaf nodes because the tree hasn't finished generating yet.\n  if (result.tris.min === Infinity) {\n    result.tris.min = 0;\n    result.tris.max = 0;\n  }\n  if (result.depth.min === Infinity) {\n    result.depth.min = 0;\n    result.depth.max = 0;\n  }\n  return result;\n}\nfunction getBVHExtremes(bvh) {\n  return bvh._roots.map((root, i) => getRootExtremes(bvh, i));\n}\nfunction estimateMemoryInBytes(obj) {\n  const traversed = new Set();\n  const stack = [obj];\n  let bytes = 0;\n  while (stack.length) {\n    const curr = stack.pop();\n    if (traversed.has(curr)) {\n      continue;\n    }\n    traversed.add(curr);\n    for (let key in curr) {\n      if (!Object.hasOwn(curr, key)) {\n        continue;\n      }\n      bytes += getPrimitiveSize(key);\n      const value = curr[key];\n      if (value && (typeof value === 'object' || typeof value === 'function')) {\n        if (isTypedArray(value)) {\n          bytes += value.byteLength;\n        } else if (isSharedArrayBufferSupported() && value instanceof SharedArrayBuffer) {\n          bytes += value.byteLength;\n        } else if (value instanceof ArrayBuffer) {\n          bytes += value.byteLength;\n        } else {\n          stack.push(value);\n        }\n      } else {\n        bytes += getPrimitiveSize(value);\n      }\n    }\n  }\n  return bytes;\n}\nfunction validateBounds(bvh) {\n  const geometry = bvh.geometry;\n  const depthStack = [];\n  const index = geometry.index;\n  const position = geometry.getAttribute('position');\n  let passes = true;\n  bvh.traverse((depth, isLeaf, boundingData, offset, count) => {\n    const info = {\n      depth,\n      isLeaf,\n      boundingData,\n      offset,\n      count\n    };\n    depthStack[depth] = info;\n    arrayToBox(0, boundingData, _box1);\n    const parent = depthStack[depth - 1];\n    if (isLeaf) {\n      // check triangles\n      for (let i = offset, l = offset + count; i < l; i++) {\n        const triIndex = bvh.resolveTriangleIndex(i);\n        let i0 = 3 * triIndex;\n        let i1 = 3 * triIndex + 1;\n        let i2 = 3 * triIndex + 2;\n        if (index) {\n          i0 = index.getX(i0);\n          i1 = index.getX(i1);\n          i2 = index.getX(i2);\n        }\n        let isContained;\n        _vec.fromBufferAttribute(position, i0);\n        isContained = _box1.containsPoint(_vec);\n        _vec.fromBufferAttribute(position, i1);\n        isContained = isContained && _box1.containsPoint(_vec);\n        _vec.fromBufferAttribute(position, i2);\n        isContained = isContained && _box1.containsPoint(_vec);\n        console.assert(isContained, 'Leaf bounds does not fully contain triangle.');\n        passes = passes && isContained;\n      }\n    }\n    if (parent) {\n      // check if my bounds fit in my parents\n      arrayToBox(0, boundingData, _box2);\n      const isContained = _box2.containsBox(_box1);\n      console.assert(isContained, 'Parent bounds does not fully contain child.');\n      passes = passes && isContained;\n    }\n  });\n  return passes;\n}\n\n// Returns a simple, human readable object that represents the BVH.\nfunction getJSONStructure(bvh) {\n  const depthStack = [];\n  bvh.traverse((depth, isLeaf, boundingData, offset, count) => {\n    const info = {\n      bounds: arrayToBox(0, boundingData, new Box3())\n    };\n    if (isLeaf) {\n      info.count = count;\n      info.offset = offset;\n    } else {\n      info.left = null;\n      info.right = null;\n    }\n    depthStack[depth] = info;\n\n    // traversal hits the left then right node\n    const parent = depthStack[depth - 1];\n    if (parent) {\n      if (parent.left === null) {\n        parent.left = info;\n      } else {\n        parent.right = info;\n      }\n    }\n  });\n  return depthStack[0];\n}\nexport { estimateMemoryInBytes, getBVHExtremes, validateBounds, getJSONStructure };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}