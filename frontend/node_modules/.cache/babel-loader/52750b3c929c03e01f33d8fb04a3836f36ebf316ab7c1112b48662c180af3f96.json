{"ast":null,"code":"import { BufferGeometry, Vector3, Matrix4, Float32BufferAttribute } from \"three\";\nclass DecalGeometry extends BufferGeometry {\n  constructor(mesh, position, orientation, size) {\n    super();\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    const plane = new Vector3();\n    const projectorMatrix = new Matrix4();\n    projectorMatrix.makeRotationFromEuler(orientation);\n    projectorMatrix.setPosition(position);\n    const projectorMatrixInverse = new Matrix4();\n    projectorMatrixInverse.copy(projectorMatrix).invert();\n    generate();\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    function generate() {\n      let i;\n      let decalVertices = [];\n      const vertex = new Vector3();\n      const normal = new Vector3();\n      if (mesh.geometry.isGeometry === true) {\n        console.error(\"THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.\");\n        return;\n      }\n      const geometry = mesh.geometry;\n      const positionAttribute = geometry.attributes.position;\n      const normalAttribute = geometry.attributes.normal;\n      if (geometry.index !== null) {\n        const index = geometry.index;\n        for (i = 0; i < index.count; i++) {\n          vertex.fromBufferAttribute(positionAttribute, index.getX(i));\n          normal.fromBufferAttribute(normalAttribute, index.getX(i));\n          pushDecalVertex(decalVertices, vertex, normal);\n        }\n      } else {\n        for (i = 0; i < positionAttribute.count; i++) {\n          vertex.fromBufferAttribute(positionAttribute, i);\n          normal.fromBufferAttribute(normalAttribute, i);\n          pushDecalVertex(decalVertices, vertex, normal);\n        }\n      }\n      decalVertices = clipGeometry(decalVertices, plane.set(1, 0, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(-1, 0, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 1, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, -1, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, 1));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, -1));\n      for (i = 0; i < decalVertices.length; i++) {\n        const decalVertex = decalVertices[i];\n        uvs.push(0.5 + decalVertex.position.x / size.x, 0.5 + decalVertex.position.y / size.y);\n        decalVertex.position.applyMatrix4(projectorMatrix);\n        vertices.push(decalVertex.position.x, decalVertex.position.y, decalVertex.position.z);\n        normals.push(decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z);\n      }\n    }\n    function pushDecalVertex(decalVertices, vertex, normal) {\n      vertex.applyMatrix4(mesh.matrixWorld);\n      vertex.applyMatrix4(projectorMatrixInverse);\n      normal.transformDirection(mesh.matrixWorld);\n      decalVertices.push(new DecalVertex(vertex.clone(), normal.clone()));\n    }\n    function clipGeometry(inVertices, plane2) {\n      const outVertices = [];\n      const s = 0.5 * Math.abs(size.dot(plane2));\n      for (let i = 0; i < inVertices.length; i += 3) {\n        let v1Out,\n          v2Out,\n          v3Out,\n          total = 0;\n        let nV1, nV2, nV3, nV4;\n        const d1 = inVertices[i + 0].position.dot(plane2) - s;\n        const d2 = inVertices[i + 1].position.dot(plane2) - s;\n        const d3 = inVertices[i + 2].position.dot(plane2) - s;\n        v1Out = d1 > 0;\n        v2Out = d2 > 0;\n        v3Out = d3 > 0;\n        total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\n        switch (total) {\n          case 0:\n            {\n              outVertices.push(inVertices[i]);\n              outVertices.push(inVertices[i + 1]);\n              outVertices.push(inVertices[i + 2]);\n              break;\n            }\n          case 1:\n            {\n              if (v1Out) {\n                nV1 = inVertices[i + 1];\n                nV2 = inVertices[i + 2];\n                nV3 = clip(inVertices[i], nV1, plane2, s);\n                nV4 = clip(inVertices[i], nV2, plane2, s);\n              }\n              if (v2Out) {\n                nV1 = inVertices[i];\n                nV2 = inVertices[i + 2];\n                nV3 = clip(inVertices[i + 1], nV1, plane2, s);\n                nV4 = clip(inVertices[i + 1], nV2, plane2, s);\n                outVertices.push(nV3);\n                outVertices.push(nV2.clone());\n                outVertices.push(nV1.clone());\n                outVertices.push(nV2.clone());\n                outVertices.push(nV3.clone());\n                outVertices.push(nV4);\n                break;\n              }\n              if (v3Out) {\n                nV1 = inVertices[i];\n                nV2 = inVertices[i + 1];\n                nV3 = clip(inVertices[i + 2], nV1, plane2, s);\n                nV4 = clip(inVertices[i + 2], nV2, plane2, s);\n              }\n              outVertices.push(nV1.clone());\n              outVertices.push(nV2.clone());\n              outVertices.push(nV3);\n              outVertices.push(nV4);\n              outVertices.push(nV3.clone());\n              outVertices.push(nV2.clone());\n              break;\n            }\n          case 2:\n            {\n              if (!v1Out) {\n                nV1 = inVertices[i].clone();\n                nV2 = clip(nV1, inVertices[i + 1], plane2, s);\n                nV3 = clip(nV1, inVertices[i + 2], plane2, s);\n                outVertices.push(nV1);\n                outVertices.push(nV2);\n                outVertices.push(nV3);\n              }\n              if (!v2Out) {\n                nV1 = inVertices[i + 1].clone();\n                nV2 = clip(nV1, inVertices[i + 2], plane2, s);\n                nV3 = clip(nV1, inVertices[i], plane2, s);\n                outVertices.push(nV1);\n                outVertices.push(nV2);\n                outVertices.push(nV3);\n              }\n              if (!v3Out) {\n                nV1 = inVertices[i + 2].clone();\n                nV2 = clip(nV1, inVertices[i], plane2, s);\n                nV3 = clip(nV1, inVertices[i + 1], plane2, s);\n                outVertices.push(nV1);\n                outVertices.push(nV2);\n                outVertices.push(nV3);\n              }\n              break;\n            }\n        }\n      }\n      return outVertices;\n    }\n    function clip(v0, v1, p, s) {\n      const d0 = v0.position.dot(p) - s;\n      const d1 = v1.position.dot(p) - s;\n      const s0 = d0 / (d0 - d1);\n      const v = new DecalVertex(new Vector3(v0.position.x + s0 * (v1.position.x - v0.position.x), v0.position.y + s0 * (v1.position.y - v0.position.y), v0.position.z + s0 * (v1.position.z - v0.position.z)), new Vector3(v0.normal.x + s0 * (v1.normal.x - v0.normal.x), v0.normal.y + s0 * (v1.normal.y - v0.normal.y), v0.normal.z + s0 * (v1.normal.z - v0.normal.z)));\n      return v;\n    }\n  }\n}\nclass DecalVertex {\n  constructor(position, normal) {\n    this.position = position;\n    this.normal = normal;\n  }\n  clone() {\n    return new this.constructor(this.position.clone(), this.normal.clone());\n  }\n}\nexport { DecalGeometry, DecalVertex };\n//# sourceMappingURL=DecalGeometry.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}