{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { useThree, createPortal, useFrame } from '@react-three/fiber';\nconst RenderCubeTexture = /* @__PURE__ */React.forwardRef(({\n  children,\n  compute,\n  renderPriority = -1,\n  eventPriority = 0,\n  frames = Infinity,\n  stencilBuffer = false,\n  depthBuffer = true,\n  generateMipmaps = false,\n  resolution = 896,\n  near = 0.1,\n  far = 1000,\n  flip = false,\n  position,\n  rotation,\n  scale,\n  quaternion,\n  matrix,\n  matrixAutoUpdate,\n  ...props\n}, forwardRef) => {\n  const {\n    size,\n    viewport\n  } = useThree();\n  const camera = React.useRef(null);\n  const fbo = React.useMemo(() => {\n    const fbo = new THREE.WebGLCubeRenderTarget(Math.max((resolution || size.width) * viewport.dpr, (resolution || size.height) * viewport.dpr), {\n      stencilBuffer,\n      depthBuffer,\n      generateMipmaps\n    });\n    fbo.texture.isRenderTargetTexture = !flip;\n    fbo.texture.flipY = true;\n    fbo.texture.type = THREE.HalfFloatType;\n    return fbo;\n  }, [resolution, flip]);\n  React.useEffect(() => {\n    return () => fbo.dispose();\n  }, [fbo]);\n  const [vScene] = React.useState(() => new THREE.Scene());\n  React.useImperativeHandle(forwardRef, () => ({\n    scene: vScene,\n    fbo,\n    camera: camera.current\n  }), [fbo]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, createPortal(/*#__PURE__*/React.createElement(Container, {\n    renderPriority: renderPriority,\n    frames: frames,\n    camera: camera\n  }, children, /*#__PURE__*/React.createElement(\"group\", {\n    onPointerOver: () => null\n  })), vScene, {\n    events: {\n      compute,\n      priority: eventPriority\n    }\n  }), /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: fbo.texture\n  }, props)), /*#__PURE__*/React.createElement(\"cubeCamera\", {\n    ref: camera,\n    args: [near, far, fbo],\n    position: position,\n    rotation: rotation,\n    scale: scale,\n    quaternion: quaternion,\n    matrix: matrix,\n    matrixAutoUpdate: matrixAutoUpdate\n  }));\n});\n\n// The container component has to be separate, it can not be inlined because \"useFrame(state\" when run inside createPortal will return\n// the portals own state which includes user-land overrides (custom cameras etc), but if it is executed in <RenderTexture>'s render function\n// it would return the default state.\nfunction Container({\n  frames,\n  renderPriority,\n  children,\n  camera\n}) {\n  let count = 0;\n  useFrame(state => {\n    if (frames === Infinity || count < frames) {\n      camera.current.update(state.gl, state.scene);\n      count++;\n    }\n  }, renderPriority);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n}\nexport { RenderCubeTexture };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}