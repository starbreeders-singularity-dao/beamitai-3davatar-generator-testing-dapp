{"ast":null,"code":"import { Vector3 } from \"three\";\nconst _v1 = new Vector3();\nconst _v2 = new Vector3();\nconst _v3 = new Vector3();\nconst EPS = 1e-10;\nclass Capsule {\n  constructor(start = new Vector3(0, 0, 0), end = new Vector3(0, 1, 0), radius = 1) {\n    this.start = start;\n    this.end = end;\n    this.radius = radius;\n  }\n  clone() {\n    return new Capsule(this.start.clone(), this.end.clone(), this.radius);\n  }\n  set(start, end, radius) {\n    this.start.copy(start);\n    this.end.copy(end);\n    this.radius = radius;\n  }\n  copy(capsule) {\n    this.start.copy(capsule.start);\n    this.end.copy(capsule.end);\n    this.radius = capsule.radius;\n  }\n  getCenter(target) {\n    return target.copy(this.end).add(this.start).multiplyScalar(0.5);\n  }\n  translate(v) {\n    this.start.add(v);\n    this.end.add(v);\n  }\n  checkAABBAxis(p1x, p1y, p2x, p2y, minx, maxx, miny, maxy, radius) {\n    return (minx - p1x < radius || minx - p2x < radius) && (p1x - maxx < radius || p2x - maxx < radius) && (miny - p1y < radius || miny - p2y < radius) && (p1y - maxy < radius || p2y - maxy < radius);\n  }\n  intersectsBox(box) {\n    return this.checkAABBAxis(this.start.x, this.start.y, this.end.x, this.end.y, box.min.x, box.max.x, box.min.y, box.max.y, this.radius) && this.checkAABBAxis(this.start.x, this.start.z, this.end.x, this.end.z, box.min.x, box.max.x, box.min.z, box.max.z, this.radius) && this.checkAABBAxis(this.start.y, this.start.z, this.end.y, this.end.z, box.min.y, box.max.y, box.min.z, box.max.z, this.radius);\n  }\n  lineLineMinimumPoints(line1, line2) {\n    const r = _v1.copy(line1.end).sub(line1.start);\n    const s = _v2.copy(line2.end).sub(line2.start);\n    const w = _v3.copy(line2.start).sub(line1.start);\n    const a = r.dot(s),\n      b = r.dot(r),\n      c = s.dot(s),\n      d = s.dot(w),\n      e = r.dot(w);\n    let t1, t2;\n    const divisor = b * c - a * a;\n    if (Math.abs(divisor) < EPS) {\n      const d1 = -d / c;\n      const d2 = (a - d) / c;\n      if (Math.abs(d1 - 0.5) < Math.abs(d2 - 0.5)) {\n        t1 = 0;\n        t2 = d1;\n      } else {\n        t1 = 1;\n        t2 = d2;\n      }\n    } else {\n      t1 = (d * a + e * c) / divisor;\n      t2 = (t1 * a - d) / c;\n    }\n    t2 = Math.max(0, Math.min(1, t2));\n    t1 = Math.max(0, Math.min(1, t1));\n    const point1 = r.multiplyScalar(t1).add(line1.start);\n    const point2 = s.multiplyScalar(t2).add(line2.start);\n    return [point1, point2];\n  }\n}\nexport { Capsule };\n//# sourceMappingURL=Capsule.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}