{"ast":null,"code":"import { assert, isHexString } from \"../utils/index.js\";\nfunction copy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport function getPollingSubscriber(provider, event) {\n  if (event === \"block\") {\n    return new PollingBlockSubscriber(provider);\n  }\n  if (isHexString(event, 32)) {\n    return new PollingTransactionSubscriber(provider, event);\n  }\n  assert(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"getPollingSubscriber\",\n    info: {\n      event\n    }\n  });\n}\n// @TODO: refactor this\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingBlockSubscriber {\n  #provider;\n  #poller;\n  #interval;\n  // The most recent block we have scanned for events. The value -2\n  // indicates we still need to fetch an initial block number\n  #blockNumber;\n  /**\n   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n   */\n  constructor(provider) {\n    this.#provider = provider;\n    this.#poller = null;\n    this.#interval = 4000;\n    this.#blockNumber = -2;\n  }\n  /**\n   *  The polling interval.\n   */\n  get pollingInterval() {\n    return this.#interval;\n  }\n  set pollingInterval(value) {\n    this.#interval = value;\n  }\n  async #poll() {\n    try {\n      const blockNumber = await this.#provider.getBlockNumber();\n      // Bootstrap poll to setup our initial block number\n      if (this.#blockNumber === -2) {\n        this.#blockNumber = blockNumber;\n        return;\n      }\n      // @TODO: Put a cap on the maximum number of events per loop?\n      if (blockNumber !== this.#blockNumber) {\n        for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {\n          // We have been stopped\n          if (this.#poller == null) {\n            return;\n          }\n          await this.#provider.emit(\"block\", b);\n        }\n        this.#blockNumber = blockNumber;\n      }\n    } catch (error) {\n      // @TODO: Minor bump, add an \"error\" event to let subscribers\n      //        know things went awry.\n      //console.log(error);\n    }\n    // We have been stopped\n    if (this.#poller == null) {\n      return;\n    }\n    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n  }\n  start() {\n    if (this.#poller) {\n      return;\n    }\n    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    this.#poll();\n  }\n  stop() {\n    if (!this.#poller) {\n      return;\n    }\n    this.#provider._clearTimeout(this.#poller);\n    this.#poller = null;\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      this.#blockNumber = -2;\n    }\n  }\n  resume() {\n    this.start();\n  }\n}\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class OnBlockSubscriber {\n  #provider;\n  #poll;\n  #running;\n  /**\n   *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n   */\n  constructor(provider) {\n    this.#provider = provider;\n    this.#running = false;\n    this.#poll = blockNumber => {\n      this._poll(blockNumber, this.#provider);\n    };\n  }\n  /**\n   *  Called on every new block.\n   */\n  async _poll(blockNumber, provider) {\n    throw new Error(\"sub-classes must override this\");\n  }\n  start() {\n    if (this.#running) {\n      return;\n    }\n    this.#running = true;\n    this.#poll(-2);\n    this.#provider.on(\"block\", this.#poll);\n  }\n  stop() {\n    if (!this.#running) {\n      return;\n    }\n    this.#running = false;\n    this.#provider.off(\"block\", this.#poll);\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n  }\n  resume() {\n    this.start();\n  }\n}\nexport class PollingBlockTagSubscriber extends OnBlockSubscriber {\n  #tag;\n  #lastBlock;\n  constructor(provider, tag) {\n    super(provider);\n    this.#tag = tag;\n    this.#lastBlock = -2;\n  }\n  pause(dropWhilePaused) {\n    if (dropWhilePaused) {\n      this.#lastBlock = -2;\n    }\n    super.pause(dropWhilePaused);\n  }\n  async _poll(blockNumber, provider) {\n    const block = await provider.getBlock(this.#tag);\n    if (block == null) {\n      return;\n    }\n    if (this.#lastBlock === -2) {\n      this.#lastBlock = block.number;\n    } else if (block.number > this.#lastBlock) {\n      provider.emit(this.#tag, block.number);\n      this.#lastBlock = block.number;\n    }\n  }\n}\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingOrphanSubscriber extends OnBlockSubscriber {\n  #filter;\n  constructor(provider, filter) {\n    super(provider);\n    this.#filter = copy(filter);\n  }\n  async _poll(blockNumber, provider) {\n    throw new Error(\"@TODO\");\n    console.log(this.#filter);\n  }\n}\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingTransactionSubscriber extends OnBlockSubscriber {\n  #hash;\n  /**\n   *  Create a new **PollingTransactionSubscriber** attached to\n   *  %%provider%%, listening for %%hash%%.\n   */\n  constructor(provider, hash) {\n    super(provider);\n    this.#hash = hash;\n  }\n  async _poll(blockNumber, provider) {\n    const tx = await provider.getTransactionReceipt(this.#hash);\n    if (tx) {\n      provider.emit(this.#hash, tx);\n    }\n  }\n}\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingEventSubscriber {\n  #provider;\n  #filter;\n  #poller;\n  #running;\n  // The most recent block we have scanned for events. The value -2\n  // indicates we still need to fetch an initial block number\n  #blockNumber;\n  /**\n   *  Create a new **PollingTransactionSubscriber** attached to\n   *  %%provider%%, listening for %%filter%%.\n   */\n  constructor(provider, filter) {\n    this.#provider = provider;\n    this.#filter = copy(filter);\n    this.#poller = this.#poll.bind(this);\n    this.#running = false;\n    this.#blockNumber = -2;\n  }\n  async #poll(blockNumber) {\n    // The initial block hasn't been determined yet\n    if (this.#blockNumber === -2) {\n      return;\n    }\n    const filter = copy(this.#filter);\n    filter.fromBlock = this.#blockNumber + 1;\n    filter.toBlock = blockNumber;\n    const logs = await this.#provider.getLogs(filter);\n    // No logs could just mean the node has not indexed them yet,\n    // so we keep a sliding window of 60 blocks to keep scanning\n    if (logs.length === 0) {\n      if (this.#blockNumber < blockNumber - 60) {\n        this.#blockNumber = blockNumber - 60;\n      }\n      return;\n    }\n    for (const log of logs) {\n      this.#provider.emit(this.#filter, log);\n      // Only advance the block number when logs were found to\n      // account for networks (like BNB and Polygon) which may\n      // sacrifice event consistency for block event speed\n      this.#blockNumber = log.blockNumber;\n    }\n  }\n  start() {\n    if (this.#running) {\n      return;\n    }\n    this.#running = true;\n    if (this.#blockNumber === -2) {\n      this.#provider.getBlockNumber().then(blockNumber => {\n        this.#blockNumber = blockNumber;\n      });\n    }\n    this.#provider.on(\"block\", this.#poller);\n  }\n  stop() {\n    if (!this.#running) {\n      return;\n    }\n    this.#running = false;\n    this.#provider.off(\"block\", this.#poller);\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      this.#blockNumber = -2;\n    }\n  }\n  resume() {\n    this.start();\n  }\n}\n//# sourceMappingURL=subscriber-polling.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}