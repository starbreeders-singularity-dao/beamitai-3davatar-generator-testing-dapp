{"ast":null,"code":"import { BufferGeometry, Vector3, Quaternion, BufferAttribute, Raycaster, Color } from \"three\";\nclass RollerCoasterGeometry extends BufferGeometry {\n  constructor(curve, divisions) {\n    super();\n    const vertices = [];\n    const normals = [];\n    const colors = [];\n    const color1 = [1, 1, 1];\n    const color2 = [1, 1, 0];\n    const up = new Vector3(0, 1, 0);\n    const forward = new Vector3();\n    const right = new Vector3();\n    const quaternion = new Quaternion();\n    const prevQuaternion = new Quaternion();\n    prevQuaternion.setFromAxisAngle(up, Math.PI / 2);\n    const point = new Vector3();\n    const prevPoint = new Vector3();\n    prevPoint.copy(curve.getPointAt(0));\n    const step = [new Vector3(-0.225, 0, 0), new Vector3(0, -0.05, 0), new Vector3(0, -0.175, 0), new Vector3(0, -0.05, 0), new Vector3(0.225, 0, 0), new Vector3(0, -0.175, 0)];\n    const PI2 = Math.PI * 2;\n    let sides = 5;\n    const tube1 = [];\n    for (let i = 0; i < sides; i++) {\n      const angle = i / sides * PI2;\n      tube1.push(new Vector3(Math.sin(angle) * 0.06, Math.cos(angle) * 0.06, 0));\n    }\n    sides = 6;\n    const tube2 = [];\n    for (let i = 0; i < sides; i++) {\n      const angle = i / sides * PI2;\n      tube2.push(new Vector3(Math.sin(angle) * 0.025, Math.cos(angle) * 0.025, 0));\n    }\n    const vector = new Vector3();\n    const normal = new Vector3();\n    function drawShape(shape, color) {\n      normal.set(0, 0, -1).applyQuaternion(quaternion);\n      for (let j = 0; j < shape.length; j++) {\n        vector.copy(shape[j]);\n        vector.applyQuaternion(quaternion);\n        vector.add(point);\n        vertices.push(vector.x, vector.y, vector.z);\n        normals.push(normal.x, normal.y, normal.z);\n        colors.push(color[0], color[1], color[2]);\n      }\n      normal.set(0, 0, 1).applyQuaternion(quaternion);\n      for (let j = shape.length - 1; j >= 0; j--) {\n        vector.copy(shape[j]);\n        vector.applyQuaternion(quaternion);\n        vector.add(point);\n        vertices.push(vector.x, vector.y, vector.z);\n        normals.push(normal.x, normal.y, normal.z);\n        colors.push(color[0], color[1], color[2]);\n      }\n    }\n    const vector1 = new Vector3();\n    const vector2 = new Vector3();\n    const vector3 = new Vector3();\n    const vector4 = new Vector3();\n    const normal1 = new Vector3();\n    const normal2 = new Vector3();\n    const normal3 = new Vector3();\n    const normal4 = new Vector3();\n    function extrudeShape(shape, offset2, color) {\n      for (let j = 0, jl = shape.length; j < jl; j++) {\n        const point1 = shape[j];\n        const point2 = shape[(j + 1) % jl];\n        vector1.copy(point1).add(offset2);\n        vector1.applyQuaternion(quaternion);\n        vector1.add(point);\n        vector2.copy(point2).add(offset2);\n        vector2.applyQuaternion(quaternion);\n        vector2.add(point);\n        vector3.copy(point2).add(offset2);\n        vector3.applyQuaternion(prevQuaternion);\n        vector3.add(prevPoint);\n        vector4.copy(point1).add(offset2);\n        vector4.applyQuaternion(prevQuaternion);\n        vector4.add(prevPoint);\n        vertices.push(vector1.x, vector1.y, vector1.z);\n        vertices.push(vector2.x, vector2.y, vector2.z);\n        vertices.push(vector4.x, vector4.y, vector4.z);\n        vertices.push(vector2.x, vector2.y, vector2.z);\n        vertices.push(vector3.x, vector3.y, vector3.z);\n        vertices.push(vector4.x, vector4.y, vector4.z);\n        normal1.copy(point1);\n        normal1.applyQuaternion(quaternion);\n        normal1.normalize();\n        normal2.copy(point2);\n        normal2.applyQuaternion(quaternion);\n        normal2.normalize();\n        normal3.copy(point2);\n        normal3.applyQuaternion(prevQuaternion);\n        normal3.normalize();\n        normal4.copy(point1);\n        normal4.applyQuaternion(prevQuaternion);\n        normal4.normalize();\n        normals.push(normal1.x, normal1.y, normal1.z);\n        normals.push(normal2.x, normal2.y, normal2.z);\n        normals.push(normal4.x, normal4.y, normal4.z);\n        normals.push(normal2.x, normal2.y, normal2.z);\n        normals.push(normal3.x, normal3.y, normal3.z);\n        normals.push(normal4.x, normal4.y, normal4.z);\n        colors.push(color[0], color[1], color[2]);\n        colors.push(color[0], color[1], color[2]);\n        colors.push(color[0], color[1], color[2]);\n        colors.push(color[0], color[1], color[2]);\n        colors.push(color[0], color[1], color[2]);\n        colors.push(color[0], color[1], color[2]);\n      }\n    }\n    const offset = new Vector3();\n    for (let i = 1; i <= divisions; i++) {\n      point.copy(curve.getPointAt(i / divisions));\n      up.set(0, 1, 0);\n      forward.subVectors(point, prevPoint).normalize();\n      right.crossVectors(up, forward).normalize();\n      up.crossVectors(forward, right);\n      const angle = Math.atan2(forward.x, forward.z);\n      quaternion.setFromAxisAngle(up, angle);\n      if (i % 2 === 0) {\n        drawShape(step, color2);\n      }\n      extrudeShape(tube1, offset.set(0, -0.125, 0), color2);\n      extrudeShape(tube2, offset.set(0.2, 0, 0), color1);\n      extrudeShape(tube2, offset.set(-0.2, 0, 0), color1);\n      prevPoint.copy(point);\n      prevQuaternion.copy(quaternion);\n    }\n    this.setAttribute(\"position\", new BufferAttribute(new Float32Array(vertices), 3));\n    this.setAttribute(\"normal\", new BufferAttribute(new Float32Array(normals), 3));\n    this.setAttribute(\"color\", new BufferAttribute(new Float32Array(colors), 3));\n  }\n}\nclass RollerCoasterLiftersGeometry extends BufferGeometry {\n  constructor(curve, divisions) {\n    super();\n    const vertices = [];\n    const normals = [];\n    const quaternion = new Quaternion();\n    const up = new Vector3(0, 1, 0);\n    const point = new Vector3();\n    const tangent = new Vector3();\n    const tube1 = [new Vector3(0, 0.05, -0.05), new Vector3(0, 0.05, 0.05), new Vector3(0, -0.05, 0)];\n    const tube2 = [new Vector3(-0.05, 0, 0.05), new Vector3(-0.05, 0, -0.05), new Vector3(0.05, 0, 0)];\n    const tube3 = [new Vector3(0.05, 0, -0.05), new Vector3(0.05, 0, 0.05), new Vector3(-0.05, 0, 0)];\n    const vector1 = new Vector3();\n    const vector2 = new Vector3();\n    const vector3 = new Vector3();\n    const vector4 = new Vector3();\n    const normal1 = new Vector3();\n    const normal2 = new Vector3();\n    const normal3 = new Vector3();\n    const normal4 = new Vector3();\n    function extrudeShape(shape, fromPoint2, toPoint2) {\n      for (let j = 0, jl = shape.length; j < jl; j++) {\n        const point1 = shape[j];\n        const point2 = shape[(j + 1) % jl];\n        vector1.copy(point1);\n        vector1.applyQuaternion(quaternion);\n        vector1.add(fromPoint2);\n        vector2.copy(point2);\n        vector2.applyQuaternion(quaternion);\n        vector2.add(fromPoint2);\n        vector3.copy(point2);\n        vector3.applyQuaternion(quaternion);\n        vector3.add(toPoint2);\n        vector4.copy(point1);\n        vector4.applyQuaternion(quaternion);\n        vector4.add(toPoint2);\n        vertices.push(vector1.x, vector1.y, vector1.z);\n        vertices.push(vector2.x, vector2.y, vector2.z);\n        vertices.push(vector4.x, vector4.y, vector4.z);\n        vertices.push(vector2.x, vector2.y, vector2.z);\n        vertices.push(vector3.x, vector3.y, vector3.z);\n        vertices.push(vector4.x, vector4.y, vector4.z);\n        normal1.copy(point1);\n        normal1.applyQuaternion(quaternion);\n        normal1.normalize();\n        normal2.copy(point2);\n        normal2.applyQuaternion(quaternion);\n        normal2.normalize();\n        normal3.copy(point2);\n        normal3.applyQuaternion(quaternion);\n        normal3.normalize();\n        normal4.copy(point1);\n        normal4.applyQuaternion(quaternion);\n        normal4.normalize();\n        normals.push(normal1.x, normal1.y, normal1.z);\n        normals.push(normal2.x, normal2.y, normal2.z);\n        normals.push(normal4.x, normal4.y, normal4.z);\n        normals.push(normal2.x, normal2.y, normal2.z);\n        normals.push(normal3.x, normal3.y, normal3.z);\n        normals.push(normal4.x, normal4.y, normal4.z);\n      }\n    }\n    const fromPoint = new Vector3();\n    const toPoint = new Vector3();\n    for (let i = 1; i <= divisions; i++) {\n      point.copy(curve.getPointAt(i / divisions));\n      tangent.copy(curve.getTangentAt(i / divisions));\n      const angle = Math.atan2(tangent.x, tangent.z);\n      quaternion.setFromAxisAngle(up, angle);\n      if (point.y > 10) {\n        fromPoint.set(-0.75, -0.35, 0);\n        fromPoint.applyQuaternion(quaternion);\n        fromPoint.add(point);\n        toPoint.set(0.75, -0.35, 0);\n        toPoint.applyQuaternion(quaternion);\n        toPoint.add(point);\n        extrudeShape(tube1, fromPoint, toPoint);\n        fromPoint.set(-0.7, -0.3, 0);\n        fromPoint.applyQuaternion(quaternion);\n        fromPoint.add(point);\n        toPoint.set(-0.7, -point.y, 0);\n        toPoint.applyQuaternion(quaternion);\n        toPoint.add(point);\n        extrudeShape(tube2, fromPoint, toPoint);\n        fromPoint.set(0.7, -0.3, 0);\n        fromPoint.applyQuaternion(quaternion);\n        fromPoint.add(point);\n        toPoint.set(0.7, -point.y, 0);\n        toPoint.applyQuaternion(quaternion);\n        toPoint.add(point);\n        extrudeShape(tube3, fromPoint, toPoint);\n      } else {\n        fromPoint.set(0, -0.2, 0);\n        fromPoint.applyQuaternion(quaternion);\n        fromPoint.add(point);\n        toPoint.set(0, -point.y, 0);\n        toPoint.applyQuaternion(quaternion);\n        toPoint.add(point);\n        extrudeShape(tube3, fromPoint, toPoint);\n      }\n    }\n    this.setAttribute(\"position\", new BufferAttribute(new Float32Array(vertices), 3));\n    this.setAttribute(\"normal\", new BufferAttribute(new Float32Array(normals), 3));\n  }\n}\nclass RollerCoasterShadowGeometry extends BufferGeometry {\n  constructor(curve, divisions) {\n    super();\n    const vertices = [];\n    const up = new Vector3(0, 1, 0);\n    const forward = new Vector3();\n    const quaternion = new Quaternion();\n    const prevQuaternion = new Quaternion();\n    prevQuaternion.setFromAxisAngle(up, Math.PI / 2);\n    const point = new Vector3();\n    const prevPoint = new Vector3();\n    prevPoint.copy(curve.getPointAt(0));\n    prevPoint.y = 0;\n    const vector1 = new Vector3();\n    const vector2 = new Vector3();\n    const vector3 = new Vector3();\n    const vector4 = new Vector3();\n    for (let i = 1; i <= divisions; i++) {\n      point.copy(curve.getPointAt(i / divisions));\n      point.y = 0;\n      forward.subVectors(point, prevPoint);\n      const angle = Math.atan2(forward.x, forward.z);\n      quaternion.setFromAxisAngle(up, angle);\n      vector1.set(-0.3, 0, 0);\n      vector1.applyQuaternion(quaternion);\n      vector1.add(point);\n      vector2.set(0.3, 0, 0);\n      vector2.applyQuaternion(quaternion);\n      vector2.add(point);\n      vector3.set(0.3, 0, 0);\n      vector3.applyQuaternion(prevQuaternion);\n      vector3.add(prevPoint);\n      vector4.set(-0.3, 0, 0);\n      vector4.applyQuaternion(prevQuaternion);\n      vector4.add(prevPoint);\n      vertices.push(vector1.x, vector1.y, vector1.z);\n      vertices.push(vector2.x, vector2.y, vector2.z);\n      vertices.push(vector4.x, vector4.y, vector4.z);\n      vertices.push(vector2.x, vector2.y, vector2.z);\n      vertices.push(vector3.x, vector3.y, vector3.z);\n      vertices.push(vector4.x, vector4.y, vector4.z);\n      prevPoint.copy(point);\n      prevQuaternion.copy(quaternion);\n    }\n    this.setAttribute(\"position\", new BufferAttribute(new Float32Array(vertices), 3));\n  }\n}\nclass SkyGeometry extends BufferGeometry {\n  constructor() {\n    super();\n    const vertices = [];\n    for (let i = 0; i < 100; i++) {\n      const x = Math.random() * 800 - 400;\n      const y = Math.random() * 50 + 50;\n      const z = Math.random() * 800 - 400;\n      const size = Math.random() * 40 + 20;\n      vertices.push(x - size, y, z - size);\n      vertices.push(x + size, y, z - size);\n      vertices.push(x - size, y, z + size);\n      vertices.push(x + size, y, z - size);\n      vertices.push(x + size, y, z + size);\n      vertices.push(x - size, y, z + size);\n    }\n    this.setAttribute(\"position\", new BufferAttribute(new Float32Array(vertices), 3));\n  }\n}\nclass TreesGeometry extends BufferGeometry {\n  constructor(landscape) {\n    super();\n    const vertices = [];\n    const colors = [];\n    const raycaster = new Raycaster();\n    raycaster.ray.direction.set(0, -1, 0);\n    const _color = new Color();\n    for (let i = 0; i < 2e3; i++) {\n      const x = Math.random() * 500 - 250;\n      const z = Math.random() * 500 - 250;\n      raycaster.ray.origin.set(x, 50, z);\n      const intersections = raycaster.intersectObject(landscape);\n      if (intersections.length === 0) continue;\n      const y = intersections[0].point.y;\n      const height = Math.random() * 5 + 0.5;\n      let angle = Math.random() * Math.PI * 2;\n      vertices.push(x + Math.sin(angle), y, z + Math.cos(angle));\n      vertices.push(x, y + height, z);\n      vertices.push(x + Math.sin(angle + Math.PI), y, z + Math.cos(angle + Math.PI));\n      angle += Math.PI / 2;\n      vertices.push(x + Math.sin(angle), y, z + Math.cos(angle));\n      vertices.push(x, y + height, z);\n      vertices.push(x + Math.sin(angle + Math.PI), y, z + Math.cos(angle + Math.PI));\n      const random = Math.random() * 0.1;\n      for (let j = 0; j < 6; j++) {\n        _color.setRGB(0.2 + random, 0.4 + random, 0, \"srgb\");\n        colors.push(_color.r, _color.g, _color.b);\n      }\n    }\n    this.setAttribute(\"position\", new BufferAttribute(new Float32Array(vertices), 3));\n    this.setAttribute(\"color\", new BufferAttribute(new Float32Array(colors), 3));\n  }\n}\nexport { RollerCoasterGeometry, RollerCoasterLiftersGeometry, RollerCoasterShadowGeometry, SkyGeometry, TreesGeometry };\n//# sourceMappingURL=RollerCoaster.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}