{"ast":null,"code":"import * as THREE from 'three';\nimport { TextureLoader } from 'three';\nimport { useThree, useLoader } from '@react-three/fiber';\nimport * as React from 'react';\nimport { useState } from 'react';\n\n/* eslint react-hooks/exhaustive-deps: 1 */\n// utils\nconst getFirstFrame = (frames, frameName) => {\n  if (Array.isArray(frames)) {\n    return frames[0];\n  } else {\n    const k = frameName !== null && frameName !== void 0 ? frameName : Object.keys(frames)[0];\n    return frames[k][0];\n  }\n};\nconst checkIfFrameIsEmpty = frameData => {\n  for (let i = 3; i < frameData.length; i += 4) {\n    if (frameData[i] !== 0) {\n      return false;\n    }\n  }\n  return true;\n};\nfunction useSpriteLoader(/** The URL of the sprite sheet. */\ninput, /** The JSON data of the sprite sheet. */\njson, /** The names of the animations in the sprite sheet. */\nanimationNames, /** The number of frames in the sprite sheet. */\nnumberOfFrames, /** A callback that is called when the sprite sheet is loaded. */\nonLoad, /** The settings to use when creating the 2D context. */\ncanvasRenderingContext2DSettings) {\n  const viewportRef = React.useRef(useThree(state => state.viewport));\n  const spriteDataRef = React.useRef(null);\n  const totalFrames = React.useRef(0);\n  const aspectFactor = 0.1;\n  const inputRef = React.useRef(input);\n  const jsonRef = React.useRef(json);\n  const animationFramesRef = React.useRef(animationNames);\n  const [spriteData, setSpriteData] = useState(null);\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const textureLoader = React.useMemo(() => new THREE.TextureLoader(), []);\n  const [spriteObj, setSpriteObj] = useState(null);\n  const calculateAspectRatio = React.useCallback((width, height, factor) => {\n    const adaptedHeight = height * (viewportRef.current.aspect > width / height ? viewportRef.current.width / width : viewportRef.current.height / height);\n    const adaptedWidth = width * (viewportRef.current.aspect > width / height ? viewportRef.current.width / width : viewportRef.current.height / height);\n    const scaleX = adaptedWidth * factor;\n    const scaleY = adaptedHeight * factor;\n    const currentMaxScale = 1;\n    // Calculate the maximum scale based on the aspect ratio and max scale limit\n    let finalMaxScaleW = Math.min(currentMaxScale, scaleX);\n    let finalMaxScaleH = Math.min(currentMaxScale, scaleY);\n\n    // Ensure that scaleX and scaleY do not exceed the max scale while maintaining aspect ratio\n    if (scaleX > currentMaxScale) {\n      finalMaxScaleW = currentMaxScale;\n      finalMaxScaleH = scaleY / scaleX * currentMaxScale;\n    }\n    return new THREE.Vector3(finalMaxScaleW, finalMaxScaleH, 1);\n  }, []);\n  const getRowsAndColumns = React.useCallback((texture, totalFrames) => {\n    if (texture.image) {\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d', canvasRenderingContext2DSettings);\n      if (!ctx) {\n        throw new Error('Failed to get 2d context');\n      }\n      canvas.width = texture.image.width;\n      canvas.height = texture.image.height;\n      ctx.drawImage(texture.image, 0, 0);\n      const width = texture.image.width;\n      const height = texture.image.height;\n\n      // Calculate rows and columns based on the number of frames and image dimensions\n      const cols = Math.round(Math.sqrt(totalFrames * (width / height)));\n      const rows = Math.round(totalFrames / cols);\n      const frameWidth = width / cols;\n      const frameHeight = height / rows;\n      const emptyFrames = [];\n      for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n          const frameIndex = row * cols + col;\n          if (frameIndex >= totalFrames) {\n            emptyFrames.push({\n              row,\n              col\n            });\n            continue;\n          }\n          const frameData = ctx.getImageData(col * frameWidth, row * frameHeight, frameWidth, frameHeight).data;\n          const isEmpty = checkIfFrameIsEmpty(frameData);\n          if (isEmpty) {\n            emptyFrames.push({\n              row,\n              col\n            });\n          }\n        }\n      }\n      return {\n        rows,\n        columns: cols,\n        frameWidth,\n        frameHeight,\n        emptyFrames\n      };\n    } else {\n      return {\n        rows: 0,\n        columns: 0,\n        frameWidth: 0,\n        frameHeight: 0,\n        emptyFrames: []\n      };\n    }\n  }, [canvasRenderingContext2DSettings]);\n\n  // calculate scale ratio for the frames\n  const calculateScaleRatio = React.useCallback(frames => {\n    // Helper function to calculate scale ratio for an array of frames\n    const processFrameArray = frameArray => {\n      // Find the largest frame\n      let largestFrame = null;\n      for (const frame of frameArray) {\n        const {\n          w,\n          h\n        } = frame.frame;\n        const area = w * h;\n        if (!largestFrame || area > largestFrame.area) {\n          largestFrame = {\n            w,\n            h,\n            area\n          };\n        }\n      }\n\n      // Set scaleRatio property on each frame\n      const frameArr = frameArray.map(frame => {\n        const {\n          w,\n          h\n        } = frame.frame;\n        const area = w * h;\n        const scaleRatio = largestFrame ? area === largestFrame.area ? 1 : Math.sqrt(area / largestFrame.area) : 1;\n        return {\n          ...frame,\n          scaleRatio\n        };\n      });\n      return frameArr;\n    };\n\n    // Handle both array and record cases\n    if (Array.isArray(frames)) {\n      return processFrameArray(frames);\n    } else {\n      const result = {};\n      for (const key in frames) {\n        result[key] = processFrameArray(frames[key]);\n      }\n      return result;\n    }\n  }, []);\n\n  // for frame based JSON Hash sprite data\n  const parseFrames = React.useCallback(() => {\n    const sprites = {};\n    const data = spriteDataRef.current;\n    const delimiters = animationFramesRef.current;\n    if (data) {\n      if (delimiters && Array.isArray(data['frames'])) {\n        for (let i = 0; i < delimiters.length; i++) {\n          // we convert each named animation group into an array\n          sprites[delimiters[i]] = [];\n          for (const value of data['frames']) {\n            const frameData = value['frame'];\n            const sourceWidth = value['sourceSize']['w'];\n            const sourceHeight = value['sourceSize']['h'];\n            if (typeof value['filename'] === 'string' && value['filename'].toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n              sprites[delimiters[i]].push({\n                ...value,\n                frame: frameData,\n                sourceSize: {\n                  w: sourceWidth,\n                  h: sourceHeight\n                }\n              });\n            }\n          }\n        }\n        for (const frame in sprites) {\n          const scaleRatioData = calculateScaleRatio(sprites[frame]);\n          if (Array.isArray(scaleRatioData)) {\n            sprites[frame] = scaleRatioData;\n          }\n        }\n        return sprites;\n      } else if (delimiters && typeof data['frames'] === 'object') {\n        for (let i = 0; i < delimiters.length; i++) {\n          // we convert each named animation group into an array\n          sprites[delimiters[i]] = [];\n          for (const innerKey in data['frames']) {\n            const value = data['frames'][innerKey];\n            const frameData = value['frame'];\n            const sourceWidth = value['sourceSize']['w'];\n            const sourceHeight = value['sourceSize']['h'];\n            if (typeof innerKey === 'string' && innerKey.toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n              sprites[delimiters[i]].push({\n                ...value,\n                frame: frameData,\n                sourceSize: {\n                  w: sourceWidth,\n                  h: sourceHeight\n                }\n              });\n            }\n          }\n        }\n        for (const frame in sprites) {\n          const scaleRatioData = calculateScaleRatio(sprites[frame]);\n          if (Array.isArray(scaleRatioData)) {\n            sprites[frame] = scaleRatioData;\n          }\n        }\n        return sprites;\n      } else {\n        let spritesArr = [];\n        if (data != null && data.frames) {\n          if (Array.isArray(data.frames)) {\n            spritesArr = data.frames.map(frame => ({\n              ...frame,\n              x: frame.frame.x,\n              y: frame.frame.y,\n              w: frame.frame.w,\n              h: frame.frame.h\n            }));\n          } else {\n            spritesArr = Object.values(data.frames).flat().map(frame => ({\n              ...frame,\n              x: frame.frame.x,\n              y: frame.frame.y,\n              w: frame.frame.w,\n              h: frame.frame.h\n            }));\n          }\n        }\n        return calculateScaleRatio(spritesArr);\n      }\n    }\n    return [];\n  }, [calculateScaleRatio, spriteDataRef]);\n  const parseSpriteData = React.useCallback((json, _spriteTexture) => {\n    let aspect = new THREE.Vector3(1, 1, 1);\n    // sprite only case\n    if (json === null) {\n      if (_spriteTexture && numberOfFrames) {\n        //get size from texture\n        const width = _spriteTexture.image.width;\n        const height = _spriteTexture.image.height;\n        totalFrames.current = numberOfFrames;\n        const {\n          rows,\n          columns,\n          frameWidth,\n          frameHeight,\n          emptyFrames\n        } = getRowsAndColumns(_spriteTexture, numberOfFrames);\n        const nonJsonFrames = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            rows,\n            columns,\n            frameWidth,\n            frameHeight,\n            scale: '1'\n          }\n        };\n        for (let row = 0; row < rows; row++) {\n          for (let col = 0; col < columns; col++) {\n            const isExcluded = (emptyFrames !== null && emptyFrames !== void 0 ? emptyFrames : []).some(coord => coord.row === row && coord.col === col);\n            if (isExcluded) {\n              continue;\n            }\n            if (Array.isArray(nonJsonFrames.frames)) {\n              nonJsonFrames.frames.push({\n                frame: {\n                  x: col * frameWidth,\n                  y: row * frameHeight,\n                  w: frameWidth,\n                  h: frameHeight\n                },\n                scaleRatio: 1,\n                rotated: false,\n                trimmed: false,\n                spriteSourceSize: {\n                  x: 0,\n                  y: 0,\n                  w: frameWidth,\n                  h: frameHeight\n                },\n                sourceSize: {\n                  w: frameWidth,\n                  h: frameHeight\n                }\n              });\n            }\n          }\n        }\n        aspect = calculateAspectRatio(frameWidth, frameHeight, aspectFactor);\n        spriteDataRef.current = nonJsonFrames;\n      }\n\n      //scale ratio for standalone sprite\n      if (spriteDataRef.current && spriteDataRef.current.frames) {\n        spriteDataRef.current.frames = calculateScaleRatio(spriteDataRef.current.frames);\n      }\n    } else if (_spriteTexture) {\n      spriteDataRef.current = json;\n      spriteDataRef.current.frames = parseFrames();\n      totalFrames.current = Array.isArray(json.frames) ? json.frames.length : Object.keys(json.frames).length;\n      const {\n        w,\n        h\n      } = getFirstFrame(json.frames).sourceSize;\n      aspect = calculateAspectRatio(w, h, aspectFactor);\n    }\n    setSpriteData(spriteDataRef.current);\n    if ('encoding' in _spriteTexture) {\n      _spriteTexture.encoding = 3001; // sRGBEncoding\n    } else if ('colorSpace' in _spriteTexture) {\n      //@ts-ignore\n      _spriteTexture.colorSpace = THREE.SRGBColorSpace;\n    }\n    setSpriteTexture(_spriteTexture);\n    setSpriteObj({\n      spriteTexture: _spriteTexture,\n      spriteData: spriteDataRef.current,\n      aspect: aspect\n    });\n  }, [getRowsAndColumns, numberOfFrames, parseFrames, calculateAspectRatio, calculateScaleRatio]);\n\n  /**\r\n   *\r\n   */\n  const loadJsonAndTextureAndExecuteCallback = React.useCallback((jsonUrl, textureUrl, callback) => {\n    const jsonPromise = fetch(jsonUrl).then(response => response.json());\n    const texturePromise = new Promise(resolve => {\n      textureLoader.load(textureUrl, resolve);\n    });\n    Promise.all([jsonPromise, texturePromise]).then(response => {\n      callback(response[0], response[1]);\n    });\n  }, [textureLoader]);\n  const loadStandaloneSprite = React.useCallback(textureUrl => {\n    if (!textureUrl && !inputRef.current) {\n      throw new Error('Either textureUrl or input must be provided');\n    }\n    const validUrl = textureUrl !== null && textureUrl !== void 0 ? textureUrl : inputRef.current;\n    if (!validUrl) {\n      throw new Error('A valid texture URL must be provided');\n    }\n    textureLoader.load(validUrl, texture => parseSpriteData(null, texture));\n  }, [textureLoader, parseSpriteData]);\n  const loadJsonAndTexture = React.useCallback((textureUrl, jsonUrl) => {\n    if (jsonUrl && textureUrl) {\n      loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, parseSpriteData);\n    } else {\n      loadStandaloneSprite(textureUrl);\n    }\n  }, [loadJsonAndTextureAndExecuteCallback, loadStandaloneSprite, parseSpriteData]);\n  React.useLayoutEffect(() => {\n    if (jsonRef.current && inputRef.current) {\n      loadJsonAndTextureAndExecuteCallback(jsonRef.current, inputRef.current, parseSpriteData);\n    } else if (inputRef.current) {\n      // only load the texture, this is an image sprite only\n      loadStandaloneSprite();\n    }\n    const _inputRef = inputRef.current;\n    return () => {\n      if (_inputRef) {\n        useLoader.clear(TextureLoader, _inputRef);\n      }\n    };\n  }, [loadJsonAndTextureAndExecuteCallback, loadStandaloneSprite, parseSpriteData]);\n  React.useLayoutEffect(() => {\n    onLoad == null || onLoad(spriteTexture, spriteData !== null && spriteData !== void 0 ? spriteData : null);\n  }, [spriteTexture, spriteData, onLoad]);\n  return {\n    spriteObj,\n    loadJsonAndTexture\n  };\n}\nuseSpriteLoader.preload = url => useLoader.preload(TextureLoader, url);\nuseSpriteLoader.clear = input => useLoader.clear(TextureLoader, input);\nexport { checkIfFrameIsEmpty, getFirstFrame, useSpriteLoader };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}