{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { Instances, Instance } from './Instances.js';\nimport { Billboard } from './Billboard.js';\nimport { useSpriteLoader, getFirstFrame } from './useSpriteLoader.js';\n\n// Frame-related types\n\nconst context = /*#__PURE__*/React.createContext(null);\nfunction useSpriteAnimator() {\n  return React.useContext(context);\n}\n\n// Type guard for SpriteData\nfunction isSpriteData(data) {\n  return data !== null && 'meta' in data && 'frames' in data;\n}\nconst geometry = new THREE.PlaneGeometry(1, 1);\nconst SpriteAnimator = /* @__PURE__ */React.forwardRef(({\n  startFrame = 0,\n  endFrame,\n  fps = 30,\n  frameName = '',\n  textureDataURL,\n  textureImageURL,\n  loop = false,\n  numberOfFrames = 1,\n  autoPlay = true,\n  animationNames,\n  onStart,\n  onEnd,\n  onLoopEnd,\n  onFrame,\n  play,\n  pause = false,\n  flipX = false,\n  alphaTest = 0.0,\n  children,\n  asSprite = false,\n  offset,\n  playBackwards = false,\n  resetOnEnd = false,\n  maxItems = 1,\n  instanceItems = [[0, 0, 0]],\n  spriteDataset,\n  canvasRenderingContext2DSettings,\n  roundFramePosition = false,\n  meshProps = {},\n  ...props\n}, fref) => {\n  const ref = React.useRef(new THREE.Group());\n  const spriteData = React.useRef(null);\n  const matRef = React.useRef(null);\n  const spriteRef = React.useRef(null);\n  const timerOffset = React.useRef(window.performance.now());\n  const currentFrame = React.useRef(startFrame);\n  const currentFrameName = React.useRef(frameName);\n  const fpsInterval = fps > 0 ? 1000 / fps : 0;\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const totalFrames = React.useRef(0);\n  const [aspect, setAspect] = React.useState(new THREE.Vector3(1, 1, 1));\n  const flipOffset = flipX ? -1 : 1;\n  const pauseRef = React.useRef(pause);\n  const pos = React.useRef(offset);\n  const softEnd = React.useRef(false);\n  const {\n    spriteObj,\n    loadJsonAndTexture\n  } = useSpriteLoader(null, null, animationNames, numberOfFrames, undefined, canvasRenderingContext2DSettings);\n  const frameNameRef = React.useRef(frameName);\n\n  // lite version for pre-loaded assets\n  const parseSpriteDataLite = React.useCallback((textureData, data) => {\n    if (data === null) {\n      if (numberOfFrames) {\n        //get size from texture\n\n        totalFrames.current = numberOfFrames;\n        if (playBackwards) {\n          currentFrame.current = numberOfFrames - 1;\n        }\n        spriteData.current = data;\n      }\n    } else {\n      var _spriteData$current$f, _spriteData$current;\n      spriteData.current = data;\n      if (spriteData.current && Array.isArray(spriteData.current.frames)) {\n        totalFrames.current = spriteData.current.frames.length;\n      } else if (spriteData.current && typeof spriteData.current === 'object' && frameNameRef.current) {\n        totalFrames.current = spriteData.current.frames[frameNameRef.current].length;\n      } else {\n        totalFrames.current = 0;\n      }\n      if (playBackwards) {\n        currentFrame.current = totalFrames.current - 1;\n      }\n      const {\n        w,\n        h\n      } = getFirstFrame((_spriteData$current$f = (_spriteData$current = spriteData.current) == null ? void 0 : _spriteData$current.frames) !== null && _spriteData$current$f !== void 0 ? _spriteData$current$f : [], frameNameRef.current).sourceSize;\n      const aspect = calculateAspectRatio(w, h);\n      setAspect(aspect);\n      if (matRef.current) {\n        matRef.current.map = textureData;\n      }\n    }\n    setSpriteTexture(textureData);\n  }, [numberOfFrames, playBackwards]);\n\n  // modify the sprite material after json is parsed and state updated\n  const modifySpritePosition = React.useCallback(() => {\n    if (!spriteData.current) return;\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = Array.isArray(frames) ? frames[0].sourceSize : frameName ? frames[frameName] ? frames[frameName][0].sourceSize : {\n      w: 0,\n      h: 0\n    } : {\n      w: 0,\n      h: 0\n    };\n    if (matRef.current && matRef.current.map) {\n      matRef.current.map.wrapS = matRef.current.map.wrapT = THREE.RepeatWrapping;\n      matRef.current.map.center.set(0, 0);\n      matRef.current.map.repeat.set(1 * flipOffset / (metaInfo.w / frameW), 1 / (metaInfo.h / frameH));\n    }\n    //const framesH = (metaInfo.w - 1) / frameW\n    const framesV = (metaInfo.h - 1) / frameH;\n    const frameOffsetY = 1 / framesV;\n    if (matRef.current && matRef.current.map) {\n      matRef.current.map.offset.x = 0.0; //-matRef.current.map.repeat.x\n      matRef.current.map.offset.y = 1 - frameOffsetY;\n    }\n    if (onStart) {\n      onStart({\n        currentFrameName: frameName !== null && frameName !== void 0 ? frameName : '',\n        currentFrame: currentFrame.current\n      });\n    }\n  }, [flipOffset, frameName, onStart]);\n  const state = React.useMemo(() => ({\n    current: pos.current,\n    offset: pos.current,\n    imageUrl: textureImageURL,\n    hasEnded: false,\n    ref: fref\n  }), [textureImageURL, fref]);\n  React.useImperativeHandle(fref, () => ref.current, []);\n  React.useLayoutEffect(() => {\n    pos.current = offset;\n  }, [offset]);\n  const calculateAspectRatio = (width, height) => {\n    var _spriteRef$current;\n    const ret = new THREE.Vector3();\n    const aspectRatio = height / width;\n    ret.set(1, aspectRatio, 1);\n    (_spriteRef$current = spriteRef.current) == null || _spriteRef$current.scale.copy(ret);\n    return ret;\n  };\n\n  // initial loads\n  React.useEffect(() => {\n    if (spriteDataset) {\n      var _spriteDataset$sprite;\n      parseSpriteDataLite(spriteDataset == null || (_spriteDataset$sprite = spriteDataset.spriteTexture) == null ? void 0 : _spriteDataset$sprite.clone(), spriteDataset.spriteData);\n    } else {\n      if (textureImageURL && textureDataURL) {\n        loadJsonAndTexture(textureImageURL, textureDataURL);\n      }\n    }\n  }, [loadJsonAndTexture, spriteDataset, textureDataURL, textureImageURL, parseSpriteDataLite]);\n  React.useEffect(() => {\n    if (spriteObj) {\n      var _spriteObj$spriteText;\n      parseSpriteDataLite(spriteObj == null || (_spriteObj$spriteText = spriteObj.spriteTexture) == null ? void 0 : _spriteObj$spriteText.clone(), spriteObj == null ? void 0 : spriteObj.spriteData);\n    }\n  }, [spriteObj, parseSpriteDataLite]);\n\n  // support backwards play\n  React.useEffect(() => {\n    state.hasEnded = false;\n    if (spriteData.current && playBackwards === true) {\n      var _ref;\n      currentFrame.current = ((_ref = spriteData.current.frames.length) !== null && _ref !== void 0 ? _ref : 0) - 1;\n    } else {\n      currentFrame.current = 0;\n    }\n  }, [playBackwards, state]);\n  React.useLayoutEffect(() => {\n    modifySpritePosition();\n  }, [spriteTexture, flipX, modifySpritePosition]);\n  React.useEffect(() => {\n    if (autoPlay) {\n      pauseRef.current = false;\n    }\n  }, [autoPlay]);\n  React.useLayoutEffect(() => {\n    if (currentFrameName.current !== frameName && frameName) {\n      currentFrame.current = 0;\n      currentFrameName.current = frameName;\n      state.hasEnded = false;\n      if (fpsInterval <= 0) {\n        currentFrame.current = endFrame || startFrame || 0;\n      }\n      // modifySpritePosition()\n      if (spriteData.current) {\n        const {\n          w,\n          h\n        } = getFirstFrame(spriteData.current.frames, frameName).sourceSize;\n        const _aspect = calculateAspectRatio(w, h);\n        setAspect(_aspect);\n      }\n    }\n  }, [frameName, fpsInterval, state, endFrame, startFrame]);\n\n  // run the animation on each frame\n  const runAnimation = () => {\n    if (!isSpriteData(spriteData.current)) return;\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = getFirstFrame(frames, frameName).sourceSize;\n    const spriteFrames = Array.isArray(frames) ? frames : frameName ? frames[frameName] : [];\n    const _endFrame = endFrame || spriteFrames.length - 1;\n    var _offset = offset === undefined ? state.current : offset;\n    if (fpsInterval <= 0) {\n      currentFrame.current = endFrame || startFrame || 0;\n      calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames);\n      return;\n    }\n    const now = window.performance.now();\n    const diff = now - timerOffset.current;\n    if (diff <= fpsInterval) return;\n\n    // conditionals to support backwards play\n    var endCondition = playBackwards ? currentFrame.current < 0 : currentFrame.current > _endFrame;\n    var onStartCondition = playBackwards ? currentFrame.current === _endFrame : currentFrame.current === 0;\n    var manualProgressEndCondition = playBackwards ? currentFrame.current < 0 : currentFrame.current >= _endFrame;\n    if (endCondition) {\n      currentFrame.current = loop ? startFrame !== null && startFrame !== void 0 ? startFrame : 0 : 0;\n      if (playBackwards) {\n        currentFrame.current = _endFrame;\n      }\n      if (loop) {\n        onLoopEnd == null || onLoopEnd({\n          currentFrameName: frameName !== null && frameName !== void 0 ? frameName : '',\n          currentFrame: currentFrame.current\n        });\n      } else {\n        onEnd == null || onEnd({\n          currentFrameName: frameName !== null && frameName !== void 0 ? frameName : '',\n          currentFrame: currentFrame.current\n        });\n        state.hasEnded = !resetOnEnd;\n        if (resetOnEnd) {\n          pauseRef.current = true;\n          //calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames)\n        }\n      }\n      if (!loop) return;\n    } else if (onStartCondition) {\n      onStart == null || onStart({\n        currentFrameName: frameName !== null && frameName !== void 0 ? frameName : '',\n        currentFrame: currentFrame.current\n      });\n    }\n\n    // for manual update\n    if (_offset !== undefined && manualProgressEndCondition) {\n      if (softEnd.current === false) {\n        onEnd == null || onEnd({\n          currentFrameName: frameName !== null && frameName !== void 0 ? frameName : '',\n          currentFrame: currentFrame.current\n        });\n        softEnd.current = true;\n      }\n    } else {\n      // same for start?\n      softEnd.current = false;\n    }\n\n    // clock to limit fps\n    if (diff <= fpsInterval) return;\n    timerOffset.current = now - diff % fpsInterval;\n    calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames);\n  };\n  const calculateFinalPosition = (frameW, frameH, metaInfo, spriteFrames) => {\n    // get the manual update offset to find the next frame\n    var _offset = offset === undefined ? state.current : offset;\n    const targetFrame = currentFrame.current;\n    let finalValX = 0;\n    let finalValY = 0;\n    calculateAspectRatio(frameW, frameH);\n    const framesH = roundFramePosition ? Math.round((metaInfo.w - 1) / frameW) : (metaInfo.w - 1) / frameW;\n    const framesV = roundFramePosition ? Math.round((metaInfo.h - 1) / frameH) : (metaInfo.h - 1) / frameH;\n    if (!spriteFrames[targetFrame]) {\n      return;\n    }\n    const {\n      frame: {\n        x: frameX,\n        y: frameY\n      },\n      sourceSize: {\n        w: originalSizeX,\n        h: originalSizeY\n      }\n    } = spriteFrames[targetFrame];\n    const frameOffsetX = 1 / framesH;\n    const frameOffsetY = 1 / framesV;\n    if (matRef.current && matRef.current.map) {\n      finalValX = flipOffset > 0 ? frameOffsetX * (frameX / originalSizeX) : frameOffsetX * (frameX / originalSizeX) - matRef.current.map.repeat.x;\n      finalValY = Math.abs(1 - frameOffsetY) - frameOffsetY * (frameY / originalSizeY);\n      matRef.current.map.offset.x = finalValX;\n      matRef.current.map.offset.y = finalValY;\n    }\n\n    // if manual update is active\n    if (_offset !== undefined && _offset !== null) {\n      // Calculate the frame index, based on offset given from the provider\n      let frameIndex = Math.floor(_offset * spriteFrames.length);\n\n      // Ensure the frame index is within the valid range\n      frameIndex = Math.max(0, Math.min(frameIndex, spriteFrames.length - 1));\n      if (isNaN(frameIndex)) {\n        frameIndex = 0; //fallback\n      }\n      currentFrame.current = frameIndex;\n    } else {\n      // auto update\n      if (playBackwards) {\n        currentFrame.current -= 1;\n      } else {\n        currentFrame.current += 1;\n      }\n    }\n  };\n\n  // *** Warning! It runs on every frame! ***\n  useFrame((_state, _delta) => {\n    var _spriteData$current2, _matRef$current;\n    if (!((_spriteData$current2 = spriteData.current) != null && _spriteData$current2.frames) || !((_matRef$current = matRef.current) != null && _matRef$current.map)) {\n      return;\n    }\n    if (pauseRef.current) {\n      return;\n    }\n    if (!state.hasEnded && (autoPlay || play)) {\n      runAnimation();\n      onFrame == null || onFrame({\n        currentFrameName: currentFrameName.current,\n        currentFrame: currentFrame.current\n      });\n    }\n  });\n  function multiplyScale(initialScale = new THREE.Vector3(1, 1, 1), newScale = 1) {\n    if (typeof newScale === 'number') return initialScale.multiplyScalar(newScale);\n    if (Array.isArray(newScale)) return initialScale.multiply(new THREE.Vector3(...newScale));\n    if (newScale instanceof THREE.Vector3) return initialScale.multiply(newScale);\n  }\n  return /*#__PURE__*/React.createElement(\"group\", _extends({}, props, {\n    ref: ref,\n    scale: multiplyScale(aspect, props.scale)\n  }), /*#__PURE__*/React.createElement(context.Provider, {\n    value: state\n  }, asSprite && /*#__PURE__*/React.createElement(Billboard, null, /*#__PURE__*/React.createElement(\"mesh\", _extends({\n    ref: spriteRef,\n    scale: 1.0,\n    geometry: geometry\n  }, meshProps), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    premultipliedAlpha: false,\n    toneMapped: false,\n    side: THREE.DoubleSide,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  }))), !asSprite && /*#__PURE__*/React.createElement(Instances, _extends({\n    geometry: geometry,\n    limit: maxItems !== null && maxItems !== void 0 ? maxItems : 1\n  }, meshProps), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    premultipliedAlpha: false,\n    toneMapped: false,\n    side: THREE.DoubleSide,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  }), (instanceItems !== null && instanceItems !== void 0 ? instanceItems : [0]).map((item, index) => /*#__PURE__*/React.createElement(Instance, _extends({\n    key: index,\n    ref: (instanceItems == null ? void 0 : instanceItems.length) === 1 ? spriteRef : null,\n    position: item,\n    scale: 1.0\n  }, meshProps)))), children));\n});\nexport { SpriteAnimator, useSpriteAnimator };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}