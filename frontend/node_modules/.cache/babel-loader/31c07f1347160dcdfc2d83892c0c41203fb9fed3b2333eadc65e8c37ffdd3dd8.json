{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, Vector3, Vector2, TextureLoader, Scene, Object3D, Group, SphereGeometry, MeshBasicMaterial, BackSide, Mesh, PointsMaterial, Points, LineBasicMaterial, LineSegments, FrontSide, DoubleSide, MeshPhongMaterial, Color, DataTexture, BufferGeometry, Float32BufferAttribute, BoxGeometry, ConeGeometry, CylinderGeometry, Quaternion, ShapeUtils, BufferAttribute, RepeatWrapping, ClampToEdgeWrapping } from \"three\";\nimport { createToken, Lexer, CstParser } from \"../libs/chevrotain.js\";\nclass VRMLLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === \"\" ? LoaderUtils.extractUrlBase(url) : scope.path;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(data, path) {\n    const nodeMap = {};\n    function generateVRMLTree(data2) {\n      const tokenData = createTokens();\n      const lexer = new VRMLLexer(tokenData.tokens);\n      const parser = new VRMLParser(tokenData.tokenVocabulary);\n      const visitor = createVisitor(parser.getBaseCstVisitorConstructor());\n      const lexingResult = lexer.lex(data2);\n      parser.input = lexingResult.tokens;\n      const cstOutput = parser.vrml();\n      if (parser.errors.length > 0) {\n        console.error(parser.errors);\n        throw Error(\"THREE.VRMLLoader: Parsing errors detected.\");\n      }\n      const ast = visitor.visit(cstOutput);\n      return ast;\n    }\n    function createTokens() {\n      const RouteIdentifier = createToken({\n        name: \"RouteIdentifier\",\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/\n      });\n      const Identifier = createToken({\n        name: \"Identifier\",\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n        longer_alt: RouteIdentifier\n      });\n      const nodeTypes = [\"Anchor\", \"Billboard\", \"Collision\", \"Group\", \"Transform\",\n      // grouping nodes\n      \"Inline\", \"LOD\", \"Switch\",\n      // special groups\n      \"AudioClip\", \"DirectionalLight\", \"PointLight\", \"Script\", \"Shape\", \"Sound\", \"SpotLight\", \"WorldInfo\",\n      // common nodes\n      \"CylinderSensor\", \"PlaneSensor\", \"ProximitySensor\", \"SphereSensor\", \"TimeSensor\", \"TouchSensor\", \"VisibilitySensor\",\n      // sensors\n      \"Box\", \"Cone\", \"Cylinder\", \"ElevationGrid\", \"Extrusion\", \"IndexedFaceSet\", \"IndexedLineSet\", \"PointSet\", \"Sphere\",\n      // geometries\n      \"Color\", \"Coordinate\", \"Normal\", \"TextureCoordinate\",\n      // geometric properties\n      \"Appearance\", \"FontStyle\", \"ImageTexture\", \"Material\", \"MovieTexture\", \"PixelTexture\", \"TextureTransform\",\n      // appearance\n      \"ColorInterpolator\", \"CoordinateInterpolator\", \"NormalInterpolator\", \"OrientationInterpolator\", \"PositionInterpolator\", \"ScalarInterpolator\",\n      // interpolators\n      \"Background\", \"Fog\", \"NavigationInfo\", \"Viewpoint\",\n      // bindable nodes\n      \"Text\"\n      // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n      ];\n      const Version = createToken({\n        name: \"Version\",\n        pattern: /#VRML.*/,\n        longer_alt: Identifier\n      });\n      const NodeName = createToken({\n        name: \"NodeName\",\n        pattern: new RegExp(nodeTypes.join(\"|\")),\n        longer_alt: Identifier\n      });\n      const DEF = createToken({\n        name: \"DEF\",\n        pattern: /DEF/,\n        longer_alt: Identifier\n      });\n      const USE = createToken({\n        name: \"USE\",\n        pattern: /USE/,\n        longer_alt: Identifier\n      });\n      const ROUTE = createToken({\n        name: \"ROUTE\",\n        pattern: /ROUTE/,\n        longer_alt: Identifier\n      });\n      const TO = createToken({\n        name: \"TO\",\n        pattern: /TO/,\n        longer_alt: Identifier\n      });\n      const StringLiteral = createToken({\n        name: \"StringLiteral\",\n        pattern: /\"(?:[^\\\\\"\\n\\r]|\\\\[bfnrtv\"\\\\/]|\\\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*\"/\n      });\n      const HexLiteral = createToken({\n        name: \"HexLiteral\",\n        pattern: /0[xX][0-9a-fA-F]+/\n      });\n      const NumberLiteral = createToken({\n        name: \"NumberLiteral\",\n        pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/\n      });\n      const TrueLiteral = createToken({\n        name: \"TrueLiteral\",\n        pattern: /TRUE/\n      });\n      const FalseLiteral = createToken({\n        name: \"FalseLiteral\",\n        pattern: /FALSE/\n      });\n      const NullLiteral = createToken({\n        name: \"NullLiteral\",\n        pattern: /NULL/\n      });\n      const LSquare = createToken({\n        name: \"LSquare\",\n        pattern: /\\[/\n      });\n      const RSquare = createToken({\n        name: \"RSquare\",\n        pattern: /]/\n      });\n      const LCurly = createToken({\n        name: \"LCurly\",\n        pattern: /{/\n      });\n      const RCurly = createToken({\n        name: \"RCurly\",\n        pattern: /}/\n      });\n      const Comment = createToken({\n        name: \"Comment\",\n        pattern: /#.*/,\n        group: Lexer.SKIPPED\n      });\n      const WhiteSpace = createToken({\n        name: \"WhiteSpace\",\n        pattern: /[ ,\\s]/,\n        group: Lexer.SKIPPED\n      });\n      const tokens = [WhiteSpace,\n      // keywords appear before the Identifier\n      NodeName, DEF, USE, ROUTE, TO, TrueLiteral, FalseLiteral, NullLiteral,\n      // the Identifier must appear after the keywords because all keywords are valid identifiers\n      Version, Identifier, RouteIdentifier, StringLiteral, HexLiteral, NumberLiteral, LSquare, RSquare, LCurly, RCurly, Comment];\n      const tokenVocabulary = {};\n      for (let i = 0, l = tokens.length; i < l; i++) {\n        const token = tokens[i];\n        tokenVocabulary[token.name] = token;\n      }\n      return {\n        tokens,\n        tokenVocabulary\n      };\n    }\n    function createVisitor(BaseVRMLVisitor) {\n      function VRMLToASTVisitor() {\n        BaseVRMLVisitor.call(this);\n        this.validateVisitor();\n      }\n      VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\n        constructor: VRMLToASTVisitor,\n        vrml: function (ctx) {\n          const data2 = {\n            version: this.visit(ctx.version),\n            nodes: [],\n            routes: []\n          };\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i];\n            data2.nodes.push(this.visit(node));\n          }\n          if (ctx.route) {\n            for (let i = 0, l = ctx.route.length; i < l; i++) {\n              const route = ctx.route[i];\n              data2.routes.push(this.visit(route));\n            }\n          }\n          return data2;\n        },\n        version: function (ctx) {\n          return ctx.Version[0].image;\n        },\n        node: function (ctx) {\n          const data2 = {\n            name: ctx.NodeName[0].image,\n            fields: []\n          };\n          if (ctx.field) {\n            for (let i = 0, l = ctx.field.length; i < l; i++) {\n              const field = ctx.field[i];\n              data2.fields.push(this.visit(field));\n            }\n          }\n          if (ctx.def) {\n            data2.DEF = this.visit(ctx.def[0]);\n          }\n          return data2;\n        },\n        field: function (ctx) {\n          const data2 = {\n            name: ctx.Identifier[0].image,\n            type: null,\n            values: null\n          };\n          let result;\n          if (ctx.singleFieldValue) {\n            result = this.visit(ctx.singleFieldValue[0]);\n          }\n          if (ctx.multiFieldValue) {\n            result = this.visit(ctx.multiFieldValue[0]);\n          }\n          data2.type = result.type;\n          data2.values = result.values;\n          return data2;\n        },\n        def: function (ctx) {\n          return (ctx.Identifier || ctx.NodeName)[0].image;\n        },\n        use: function (ctx) {\n          return {\n            USE: (ctx.Identifier || ctx.NodeName)[0].image\n          };\n        },\n        singleFieldValue: function (ctx) {\n          return processField(this, ctx);\n        },\n        multiFieldValue: function (ctx) {\n          return processField(this, ctx);\n        },\n        route: function (ctx) {\n          const data2 = {\n            FROM: ctx.RouteIdentifier[0].image,\n            TO: ctx.RouteIdentifier[1].image\n          };\n          return data2;\n        }\n      });\n      function processField(scope, ctx) {\n        const field = {\n          type: null,\n          values: []\n        };\n        if (ctx.node) {\n          field.type = \"node\";\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i];\n            field.values.push(scope.visit(node));\n          }\n        }\n        if (ctx.use) {\n          field.type = \"use\";\n          for (let i = 0, l = ctx.use.length; i < l; i++) {\n            const use = ctx.use[i];\n            field.values.push(scope.visit(use));\n          }\n        }\n        if (ctx.StringLiteral) {\n          field.type = \"string\";\n          for (let i = 0, l = ctx.StringLiteral.length; i < l; i++) {\n            const stringLiteral = ctx.StringLiteral[i];\n            field.values.push(stringLiteral.image.replace(/'|\"/g, \"\"));\n          }\n        }\n        if (ctx.NumberLiteral) {\n          field.type = \"number\";\n          for (let i = 0, l = ctx.NumberLiteral.length; i < l; i++) {\n            const numberLiteral = ctx.NumberLiteral[i];\n            field.values.push(parseFloat(numberLiteral.image));\n          }\n        }\n        if (ctx.HexLiteral) {\n          field.type = \"hex\";\n          for (let i = 0, l = ctx.HexLiteral.length; i < l; i++) {\n            const hexLiteral = ctx.HexLiteral[i];\n            field.values.push(hexLiteral.image);\n          }\n        }\n        if (ctx.TrueLiteral) {\n          field.type = \"boolean\";\n          for (let i = 0, l = ctx.TrueLiteral.length; i < l; i++) {\n            const trueLiteral = ctx.TrueLiteral[i];\n            if (trueLiteral.image === \"TRUE\") field.values.push(true);\n          }\n        }\n        if (ctx.FalseLiteral) {\n          field.type = \"boolean\";\n          for (let i = 0, l = ctx.FalseLiteral.length; i < l; i++) {\n            const falseLiteral = ctx.FalseLiteral[i];\n            if (falseLiteral.image === \"FALSE\") field.values.push(false);\n          }\n        }\n        if (ctx.NullLiteral) {\n          field.type = \"null\";\n          ctx.NullLiteral.forEach(function () {\n            field.values.push(null);\n          });\n        }\n        return field;\n      }\n      return new VRMLToASTVisitor();\n    }\n    function parseTree(tree2) {\n      const nodes = tree2.nodes;\n      const scene2 = new Scene();\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i];\n        buildNodeMap(node);\n      }\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i];\n        const object = getNode(node);\n        if (object instanceof Object3D) scene2.add(object);\n        if (node.name === \"WorldInfo\") scene2.userData.worldInfo = object;\n      }\n      return scene2;\n    }\n    function buildNodeMap(node) {\n      if (node.DEF) {\n        nodeMap[node.DEF] = node;\n      }\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        if (field.type === \"node\") {\n          const fieldValues = field.values;\n          for (let j = 0, jl = fieldValues.length; j < jl; j++) {\n            buildNodeMap(fieldValues[j]);\n          }\n        }\n      }\n    }\n    function getNode(node) {\n      if (node.USE) {\n        return resolveUSE(node.USE);\n      }\n      if (node.build !== void 0) return node.build;\n      node.build = buildNode(node);\n      return node.build;\n    }\n    function buildNode(node) {\n      const nodeName = node.name;\n      let build;\n      switch (nodeName) {\n        case \"Group\":\n        case \"Transform\":\n        case \"Collision\":\n          build = buildGroupingNode(node);\n          break;\n        case \"Background\":\n          build = buildBackgroundNode(node);\n          break;\n        case \"Shape\":\n          build = buildShapeNode(node);\n          break;\n        case \"Appearance\":\n          build = buildAppearanceNode(node);\n          break;\n        case \"Material\":\n          build = buildMaterialNode(node);\n          break;\n        case \"ImageTexture\":\n          build = buildImageTextureNode(node);\n          break;\n        case \"PixelTexture\":\n          build = buildPixelTextureNode(node);\n          break;\n        case \"TextureTransform\":\n          build = buildTextureTransformNode(node);\n          break;\n        case \"IndexedFaceSet\":\n          build = buildIndexedFaceSetNode(node);\n          break;\n        case \"IndexedLineSet\":\n          build = buildIndexedLineSetNode(node);\n          break;\n        case \"PointSet\":\n          build = buildPointSetNode(node);\n          break;\n        case \"Box\":\n          build = buildBoxNode(node);\n          break;\n        case \"Cone\":\n          build = buildConeNode(node);\n          break;\n        case \"Cylinder\":\n          build = buildCylinderNode(node);\n          break;\n        case \"Sphere\":\n          build = buildSphereNode(node);\n          break;\n        case \"ElevationGrid\":\n          build = buildElevationGridNode(node);\n          break;\n        case \"Extrusion\":\n          build = buildExtrusionNode(node);\n          break;\n        case \"Color\":\n        case \"Coordinate\":\n        case \"Normal\":\n        case \"TextureCoordinate\":\n          build = buildGeometricNode(node);\n          break;\n        case \"WorldInfo\":\n          build = buildWorldInfoNode(node);\n          break;\n        case \"Anchor\":\n        case \"Billboard\":\n        case \"Inline\":\n        case \"LOD\":\n        case \"Switch\":\n        case \"AudioClip\":\n        case \"DirectionalLight\":\n        case \"PointLight\":\n        case \"Script\":\n        case \"Sound\":\n        case \"SpotLight\":\n        case \"CylinderSensor\":\n        case \"PlaneSensor\":\n        case \"ProximitySensor\":\n        case \"SphereSensor\":\n        case \"TimeSensor\":\n        case \"TouchSensor\":\n        case \"VisibilitySensor\":\n        case \"Text\":\n        case \"FontStyle\":\n        case \"MovieTexture\":\n        case \"ColorInterpolator\":\n        case \"CoordinateInterpolator\":\n        case \"NormalInterpolator\":\n        case \"OrientationInterpolator\":\n        case \"PositionInterpolator\":\n        case \"ScalarInterpolator\":\n        case \"Fog\":\n        case \"NavigationInfo\":\n        case \"Viewpoint\":\n          break;\n        default:\n          console.warn(\"THREE.VRMLLoader: Unknown node:\", nodeName);\n          break;\n      }\n      if (build !== void 0 && node.DEF !== void 0 && build.hasOwnProperty(\"name\") === true) {\n        build.name = node.DEF;\n      }\n      return build;\n    }\n    function buildGroupingNode(node) {\n      const object = new Group();\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"bboxCenter\":\n            break;\n          case \"bboxSize\":\n            break;\n          case \"center\":\n            break;\n          case \"children\":\n            parseFieldChildren(fieldValues, object);\n            break;\n          case \"collide\":\n            break;\n          case \"rotation\":\n            const axis = new Vector3(fieldValues[0], fieldValues[1], fieldValues[2]).normalize();\n            const angle = fieldValues[3];\n            object.quaternion.setFromAxisAngle(axis, angle);\n            break;\n          case \"scale\":\n            object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case \"scaleOrientation\":\n            break;\n          case \"translation\":\n            object.position.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case \"proxy\":\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      return object;\n    }\n    function buildBackgroundNode(node) {\n      const group = new Group();\n      let groundAngle, groundColor;\n      let skyAngle, skyColor;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"groundAngle\":\n            groundAngle = fieldValues;\n            break;\n          case \"groundColor\":\n            groundColor = fieldValues;\n            break;\n          case \"backUrl\":\n            break;\n          case \"bottomUrl\":\n            break;\n          case \"frontUrl\":\n            break;\n          case \"leftUrl\":\n            break;\n          case \"rightUrl\":\n            break;\n          case \"topUrl\":\n            break;\n          case \"skyAngle\":\n            skyAngle = fieldValues;\n            break;\n          case \"skyColor\":\n            skyColor = fieldValues;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const radius = 1e4;\n      if (skyColor) {\n        const skyGeometry = new SphereGeometry(radius, 32, 16);\n        const skyMaterial = new MeshBasicMaterial({\n          fog: false,\n          side: BackSide,\n          depthWrite: false,\n          depthTest: false\n        });\n        if (skyColor.length > 3) {\n          paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true);\n          skyMaterial.vertexColors = true;\n        } else {\n          skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2]);\n        }\n        const sky = new Mesh(skyGeometry, skyMaterial);\n        group.add(sky);\n      }\n      if (groundColor) {\n        if (groundColor.length > 0) {\n          const groundGeometry = new SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\n          const groundMaterial = new MeshBasicMaterial({\n            fog: false,\n            side: BackSide,\n            vertexColors: true,\n            depthWrite: false,\n            depthTest: false\n          });\n          paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false);\n          const ground = new Mesh(groundGeometry, groundMaterial);\n          group.add(ground);\n        }\n      }\n      group.renderOrder = -Infinity;\n      return group;\n    }\n    function buildShapeNode(node) {\n      const fields = node.fields;\n      let material = new MeshBasicMaterial({\n        color: 0\n      });\n      let geometry;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"appearance\":\n            if (fieldValues[0] !== null) {\n              material = getNode(fieldValues[0]);\n            }\n            break;\n          case \"geometry\":\n            if (fieldValues[0] !== null) {\n              geometry = getNode(fieldValues[0]);\n            }\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      let object;\n      if (geometry && geometry.attributes.position) {\n        const type = geometry._type;\n        if (type === \"points\") {\n          const pointsMaterial = new PointsMaterial({\n            color: 16777215\n          });\n          if (geometry.attributes.color !== void 0) {\n            pointsMaterial.vertexColors = true;\n          } else {\n            if (material.isMeshPhongMaterial) {\n              pointsMaterial.color.copy(material.emissive);\n            }\n          }\n          object = new Points(geometry, pointsMaterial);\n        } else if (type === \"line\") {\n          const lineMaterial = new LineBasicMaterial({\n            color: 16777215\n          });\n          if (geometry.attributes.color !== void 0) {\n            lineMaterial.vertexColors = true;\n          } else {\n            if (material.isMeshPhongMaterial) {\n              lineMaterial.color.copy(material.emissive);\n            }\n          }\n          object = new LineSegments(geometry, lineMaterial);\n        } else {\n          if (geometry._solid !== void 0) {\n            material.side = geometry._solid ? FrontSide : DoubleSide;\n          }\n          if (geometry.attributes.color !== void 0) {\n            material.vertexColors = true;\n          }\n          object = new Mesh(geometry, material);\n        }\n      } else {\n        object = new Object3D();\n        object.visible = false;\n      }\n      return object;\n    }\n    function buildAppearanceNode(node) {\n      let material = new MeshPhongMaterial();\n      let transformData;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"material\":\n            if (fieldValues[0] !== null) {\n              const materialData = getNode(fieldValues[0]);\n              if (materialData.diffuseColor) material.color.copy(materialData.diffuseColor);\n              if (materialData.emissiveColor) material.emissive.copy(materialData.emissiveColor);\n              if (materialData.shininess) material.shininess = materialData.shininess;\n              if (materialData.specularColor) material.specular.copy(materialData.specularColor);\n              if (materialData.transparency) material.opacity = 1 - materialData.transparency;\n              if (materialData.transparency > 0) material.transparent = true;\n            } else {\n              material = new MeshBasicMaterial({\n                color: 0\n              });\n            }\n            break;\n          case \"texture\":\n            const textureNode = fieldValues[0];\n            if (textureNode !== null) {\n              if (textureNode.name === \"ImageTexture\" || textureNode.name === \"PixelTexture\") {\n                material.map = getNode(textureNode);\n              }\n            }\n            break;\n          case \"textureTransform\":\n            if (fieldValues[0] !== null) {\n              transformData = getNode(fieldValues[0]);\n            }\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      if (material.map) {\n        if (material.map.__type) {\n          switch (material.map.__type) {\n            case TEXTURE_TYPE.INTENSITY_ALPHA:\n              material.opacity = 1;\n              break;\n            case TEXTURE_TYPE.RGB:\n              material.color.set(16777215);\n              break;\n            case TEXTURE_TYPE.RGBA:\n              material.color.set(16777215);\n              material.opacity = 1;\n              break;\n          }\n          delete material.map.__type;\n        }\n        if (transformData) {\n          material.map.center.copy(transformData.center);\n          material.map.rotation = transformData.rotation;\n          material.map.repeat.copy(transformData.scale);\n          material.map.offset.copy(transformData.translation);\n        }\n      }\n      return material;\n    }\n    function buildMaterialNode(node) {\n      const materialData = {};\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"ambientIntensity\":\n            break;\n          case \"diffuseColor\":\n            materialData.diffuseColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case \"emissiveColor\":\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case \"shininess\":\n            materialData.shininess = fieldValues[0];\n            break;\n          case \"specularColor\":\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n            break;\n          case \"transparency\":\n            materialData.transparency = fieldValues[0];\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      return materialData;\n    }\n    function parseHexColor(hex, textureType, color) {\n      let value;\n      switch (textureType) {\n        case TEXTURE_TYPE.INTENSITY:\n          value = parseInt(hex);\n          color.r = value;\n          color.g = value;\n          color.b = value;\n          color.a = 1;\n          break;\n        case TEXTURE_TYPE.INTENSITY_ALPHA:\n          value = parseInt(\"0x\" + hex.substring(2, 4));\n          color.r = value;\n          color.g = value;\n          color.b = value;\n          color.a = parseInt(\"0x\" + hex.substring(4, 6));\n          break;\n        case TEXTURE_TYPE.RGB:\n          color.r = parseInt(\"0x\" + hex.substring(2, 4));\n          color.g = parseInt(\"0x\" + hex.substring(4, 6));\n          color.b = parseInt(\"0x\" + hex.substring(6, 8));\n          color.a = 1;\n          break;\n        case TEXTURE_TYPE.RGBA:\n          color.r = parseInt(\"0x\" + hex.substring(2, 4));\n          color.g = parseInt(\"0x\" + hex.substring(4, 6));\n          color.b = parseInt(\"0x\" + hex.substring(6, 8));\n          color.a = parseInt(\"0x\" + hex.substring(8, 10));\n          break;\n      }\n    }\n    function getTextureType(num_components) {\n      let type;\n      switch (num_components) {\n        case 1:\n          type = TEXTURE_TYPE.INTENSITY;\n          break;\n        case 2:\n          type = TEXTURE_TYPE.INTENSITY_ALPHA;\n          break;\n        case 3:\n          type = TEXTURE_TYPE.RGB;\n          break;\n        case 4:\n          type = TEXTURE_TYPE.RGBA;\n          break;\n      }\n      return type;\n    }\n    function buildPixelTextureNode(node) {\n      let texture;\n      let wrapS = RepeatWrapping;\n      let wrapT = RepeatWrapping;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"image\":\n            const width = fieldValues[0];\n            const height = fieldValues[1];\n            const num_components = fieldValues[2];\n            const textureType = getTextureType(num_components);\n            const data2 = new Uint8Array(4 * width * height);\n            const color = {\n              r: 0,\n              g: 0,\n              b: 0,\n              a: 0\n            };\n            for (let j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n              parseHexColor(fieldValues[j], textureType, color);\n              const stride = k * 4;\n              data2[stride + 0] = color.r;\n              data2[stride + 1] = color.g;\n              data2[stride + 2] = color.b;\n              data2[stride + 3] = color.a;\n            }\n            texture = new DataTexture(data2, width, height);\n            texture.needsUpdate = true;\n            texture.__type = textureType;\n            break;\n          case \"repeatS\":\n            if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n            break;\n          case \"repeatT\":\n            if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      if (texture) {\n        texture.wrapS = wrapS;\n        texture.wrapT = wrapT;\n      }\n      return texture;\n    }\n    function buildImageTextureNode(node) {\n      let texture;\n      let wrapS = RepeatWrapping;\n      let wrapT = RepeatWrapping;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"url\":\n            const url = fieldValues[0];\n            if (url) texture = textureLoader.load(url);\n            break;\n          case \"repeatS\":\n            if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n            break;\n          case \"repeatT\":\n            if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      if (texture) {\n        texture.wrapS = wrapS;\n        texture.wrapT = wrapT;\n      }\n      return texture;\n    }\n    function buildTextureTransformNode(node) {\n      const transformData = {\n        center: new Vector2(),\n        rotation: new Vector2(),\n        scale: new Vector2(),\n        translation: new Vector2()\n      };\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"center\":\n            transformData.center.set(fieldValues[0], fieldValues[1]);\n            break;\n          case \"rotation\":\n            transformData.rotation = fieldValues[0];\n            break;\n          case \"scale\":\n            transformData.scale.set(fieldValues[0], fieldValues[1]);\n            break;\n          case \"translation\":\n            transformData.translation.set(fieldValues[0], fieldValues[1]);\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      return transformData;\n    }\n    function buildGeometricNode(node) {\n      return node.fields[0].values;\n    }\n    function buildWorldInfoNode(node) {\n      const worldInfo = {};\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"title\":\n            worldInfo.title = fieldValues[0];\n            break;\n          case \"info\":\n            worldInfo.info = fieldValues;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      return worldInfo;\n    }\n    function buildIndexedFaceSetNode(node) {\n      let color, coord, normal, texCoord;\n      let ccw = true,\n        solid = true,\n        creaseAngle = 0;\n      let colorIndex, coordIndex, normalIndex, texCoordIndex;\n      let colorPerVertex = true,\n        normalPerVertex = true;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"color\":\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case \"coord\":\n            const coordNode = fieldValues[0];\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n            break;\n          case \"normal\":\n            const normalNode = fieldValues[0];\n            if (normalNode !== null) {\n              normal = getNode(normalNode);\n            }\n            break;\n          case \"texCoord\":\n            const texCoordNode = fieldValues[0];\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode);\n            }\n            break;\n          case \"ccw\":\n            ccw = fieldValues[0];\n            break;\n          case \"colorIndex\":\n            colorIndex = fieldValues;\n            break;\n          case \"colorPerVertex\":\n            colorPerVertex = fieldValues[0];\n            break;\n          case \"convex\":\n            break;\n          case \"coordIndex\":\n            coordIndex = fieldValues;\n            break;\n          case \"creaseAngle\":\n            creaseAngle = fieldValues[0];\n            break;\n          case \"normalIndex\":\n            normalIndex = fieldValues;\n            break;\n          case \"normalPerVertex\":\n            normalPerVertex = fieldValues[0];\n            break;\n          case \"solid\":\n            solid = fieldValues[0];\n            break;\n          case \"texCoordIndex\":\n            texCoordIndex = fieldValues;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      if (coordIndex === void 0) {\n        console.warn(\"THREE.VRMLLoader: Missing coordIndex.\");\n        return new BufferGeometry();\n      }\n      const triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw);\n      let colorAttribute;\n      let normalAttribute;\n      let uvAttribute;\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex && colorIndex.length > 0) {\n            const triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw);\n            colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3);\n          } else {\n            colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(color, 3));\n          }\n        } else {\n          if (colorIndex && colorIndex.length > 0) {\n            const flattenFaceColors = flattenData(color, colorIndex);\n            const triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex);\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n          } else {\n            const triangulatedFaceColors = triangulateFaceData(color, coordIndex);\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n          }\n        }\n      }\n      if (normal) {\n        if (normalPerVertex === true) {\n          if (normalIndex && normalIndex.length > 0) {\n            const triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw);\n            normalAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedNormalIndex, normal, 3);\n          } else {\n            normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(normal, 3));\n          }\n        } else {\n          if (normalIndex && normalIndex.length > 0) {\n            const flattenFaceNormals = flattenData(normal, normalIndex);\n            const triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex);\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n          } else {\n            const triangulatedFaceNormals = triangulateFaceData(normal, coordIndex);\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n          }\n        }\n      } else {\n        normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle);\n      }\n      if (texCoord) {\n        if (texCoordIndex && texCoordIndex.length > 0) {\n          const triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw);\n          uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2);\n        } else {\n          uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(texCoord, 2));\n        }\n      }\n      const geometry = new BufferGeometry();\n      const positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(coord, 3));\n      geometry.setAttribute(\"position\", positionAttribute);\n      geometry.setAttribute(\"normal\", normalAttribute);\n      if (colorAttribute) geometry.setAttribute(\"color\", colorAttribute);\n      if (uvAttribute) geometry.setAttribute(\"uv\", uvAttribute);\n      geometry._solid = solid;\n      geometry._type = \"mesh\";\n      return geometry;\n    }\n    function buildIndexedLineSetNode(node) {\n      let color, coord;\n      let colorIndex, coordIndex;\n      let colorPerVertex = true;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"color\":\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case \"coord\":\n            const coordNode = fieldValues[0];\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n            break;\n          case \"colorIndex\":\n            colorIndex = fieldValues;\n            break;\n          case \"colorPerVertex\":\n            colorPerVertex = fieldValues[0];\n            break;\n          case \"coordIndex\":\n            coordIndex = fieldValues;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      let colorAttribute;\n      const expandedLineIndex = expandLineIndex(coordIndex);\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex.length > 0) {\n            const expandedColorIndex = expandLineIndex(colorIndex);\n            colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3);\n          } else {\n            colorAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(color, 3));\n          }\n        } else {\n          if (colorIndex.length > 0) {\n            const flattenLineColors = flattenData(color, colorIndex);\n            const expandedLineColors = expandLineData(flattenLineColors, coordIndex);\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors);\n          } else {\n            const expandedLineColors = expandLineData(color, coordIndex);\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors);\n          }\n        }\n      }\n      const geometry = new BufferGeometry();\n      const positionAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(coord, 3));\n      geometry.setAttribute(\"position\", positionAttribute);\n      if (colorAttribute) geometry.setAttribute(\"color\", colorAttribute);\n      geometry._type = \"line\";\n      return geometry;\n    }\n    function buildPointSetNode(node) {\n      let color, coord;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"color\":\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case \"coord\":\n            const coordNode = fieldValues[0];\n            if (coordNode !== null) {\n              coord = getNode(coordNode);\n            }\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(coord, 3));\n      if (color) geometry.setAttribute(\"color\", new Float32BufferAttribute(color, 3));\n      geometry._type = \"points\";\n      return geometry;\n    }\n    function buildBoxNode(node) {\n      const size = new Vector3(2, 2, 2);\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"size\":\n            size.x = fieldValues[0];\n            size.y = fieldValues[1];\n            size.z = fieldValues[2];\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const geometry = new BoxGeometry(size.x, size.y, size.z);\n      return geometry;\n    }\n    function buildConeNode(node) {\n      let radius = 1,\n        height = 2,\n        openEnded = false;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"bottom\":\n            openEnded = !fieldValues[0];\n            break;\n          case \"bottomRadius\":\n            radius = fieldValues[0];\n            break;\n          case \"height\":\n            height = fieldValues[0];\n            break;\n          case \"side\":\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const geometry = new ConeGeometry(radius, height, 16, 1, openEnded);\n      return geometry;\n    }\n    function buildCylinderNode(node) {\n      let radius = 1,\n        height = 2;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"bottom\":\n            break;\n          case \"radius\":\n            radius = fieldValues[0];\n            break;\n          case \"height\":\n            height = fieldValues[0];\n            break;\n          case \"side\":\n            break;\n          case \"top\":\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const geometry = new CylinderGeometry(radius, radius, height, 16, 1);\n      return geometry;\n    }\n    function buildSphereNode(node) {\n      let radius = 1;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"radius\":\n            radius = fieldValues[0];\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const geometry = new SphereGeometry(radius, 16, 16);\n      return geometry;\n    }\n    function buildElevationGridNode(node) {\n      let color;\n      let normal;\n      let texCoord;\n      let height;\n      let colorPerVertex = true;\n      let normalPerVertex = true;\n      let solid = true;\n      let ccw = true;\n      let creaseAngle = 0;\n      let xDimension = 2;\n      let zDimension = 2;\n      let xSpacing = 1;\n      let zSpacing = 1;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"color\":\n            const colorNode = fieldValues[0];\n            if (colorNode !== null) {\n              color = getNode(colorNode);\n            }\n            break;\n          case \"normal\":\n            const normalNode = fieldValues[0];\n            if (normalNode !== null) {\n              normal = getNode(normalNode);\n            }\n            break;\n          case \"texCoord\":\n            const texCoordNode = fieldValues[0];\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode);\n            }\n            break;\n          case \"height\":\n            height = fieldValues;\n            break;\n          case \"ccw\":\n            ccw = fieldValues[0];\n            break;\n          case \"colorPerVertex\":\n            colorPerVertex = fieldValues[0];\n            break;\n          case \"creaseAngle\":\n            creaseAngle = fieldValues[0];\n            break;\n          case \"normalPerVertex\":\n            normalPerVertex = fieldValues[0];\n            break;\n          case \"solid\":\n            solid = fieldValues[0];\n            break;\n          case \"xDimension\":\n            xDimension = fieldValues[0];\n            break;\n          case \"xSpacing\":\n            xSpacing = fieldValues[0];\n            break;\n          case \"zDimension\":\n            zDimension = fieldValues[0];\n            break;\n          case \"zSpacing\":\n            zSpacing = fieldValues[0];\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const vertices = [];\n      const normals = [];\n      const colors = [];\n      const uvs = [];\n      for (let i = 0; i < zDimension; i++) {\n        for (let j = 0; j < xDimension; j++) {\n          const index = i * xDimension + j;\n          const x = xSpacing * i;\n          const y = height[index];\n          const z = zSpacing * j;\n          vertices.push(x, y, z);\n          if (color && colorPerVertex === true) {\n            const r = color[index * 3 + 0];\n            const g = color[index * 3 + 1];\n            const b = color[index * 3 + 2];\n            colors.push(r, g, b);\n          }\n          if (normal && normalPerVertex === true) {\n            const xn = normal[index * 3 + 0];\n            const yn = normal[index * 3 + 1];\n            const zn = normal[index * 3 + 2];\n            normals.push(xn, yn, zn);\n          }\n          if (texCoord) {\n            const s = texCoord[index * 2 + 0];\n            const t = texCoord[index * 2 + 1];\n            uvs.push(s, t);\n          } else {\n            uvs.push(i / (xDimension - 1), j / (zDimension - 1));\n          }\n        }\n      }\n      const indices = [];\n      for (let i = 0; i < xDimension - 1; i++) {\n        for (let j = 0; j < zDimension - 1; j++) {\n          const a = i + j * xDimension;\n          const b = i + (j + 1) * xDimension;\n          const c = i + 1 + (j + 1) * xDimension;\n          const d = i + 1 + j * xDimension;\n          if (ccw === true) {\n            indices.push(a, c, b);\n            indices.push(c, a, d);\n          } else {\n            indices.push(a, b, c);\n            indices.push(c, d, a);\n          }\n        }\n      }\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n      const uvAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(uvs, 2));\n      let colorAttribute;\n      let normalAttribute;\n      if (color) {\n        if (colorPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1);\n              const r = color[index * 3 + 0];\n              const g = color[index * 3 + 1];\n              const b = color[index * 3 + 2];\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n              colors.push(r, g, b);\n            }\n          }\n          colorAttribute = new Float32BufferAttribute(colors, 3);\n        } else {\n          colorAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(colors, 3));\n        }\n      }\n      if (normal) {\n        if (normalPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1);\n              const xn = normal[index * 3 + 0];\n              const yn = normal[index * 3 + 1];\n              const zn = normal[index * 3 + 2];\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n              normals.push(xn, yn, zn);\n            }\n          }\n          normalAttribute = new Float32BufferAttribute(normals, 3);\n        } else {\n          normalAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(normals, 3));\n        }\n      } else {\n        normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n      }\n      const geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", positionAttribute);\n      geometry.setAttribute(\"normal\", normalAttribute);\n      geometry.setAttribute(\"uv\", uvAttribute);\n      if (colorAttribute) geometry.setAttribute(\"color\", colorAttribute);\n      geometry._solid = solid;\n      geometry._type = \"mesh\";\n      return geometry;\n    }\n    function buildExtrusionNode(node) {\n      let crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1];\n      let spine = [0, 0, 0, 0, 1, 0];\n      let scale;\n      let orientation;\n      let beginCap = true;\n      let ccw = true;\n      let creaseAngle = 0;\n      let endCap = true;\n      let solid = true;\n      const fields = node.fields;\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i];\n        const fieldName = field.name;\n        const fieldValues = field.values;\n        switch (fieldName) {\n          case \"beginCap\":\n            beginCap = fieldValues[0];\n            break;\n          case \"ccw\":\n            ccw = fieldValues[0];\n            break;\n          case \"convex\":\n            break;\n          case \"creaseAngle\":\n            creaseAngle = fieldValues[0];\n            break;\n          case \"crossSection\":\n            crossSection = fieldValues;\n            break;\n          case \"endCap\":\n            endCap = fieldValues[0];\n            break;\n          case \"orientation\":\n            orientation = fieldValues;\n            break;\n          case \"scale\":\n            scale = fieldValues;\n            break;\n          case \"solid\":\n            solid = fieldValues[0];\n            break;\n          case \"spine\":\n            spine = fieldValues;\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n            break;\n        }\n      }\n      const crossSectionClosed = crossSection[0] === crossSection[crossSection.length - 2] && crossSection[1] === crossSection[crossSection.length - 1];\n      const vertices = [];\n      const spineVector = new Vector3();\n      const scaling = new Vector3();\n      const axis = new Vector3();\n      const vertex = new Vector3();\n      const quaternion = new Quaternion();\n      for (let i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4) {\n        spineVector.fromArray(spine, i);\n        scaling.x = scale ? scale[j + 0] : 1;\n        scaling.y = 1;\n        scaling.z = scale ? scale[j + 1] : 1;\n        axis.x = orientation ? orientation[o + 0] : 0;\n        axis.y = orientation ? orientation[o + 1] : 0;\n        axis.z = orientation ? orientation[o + 2] : 1;\n        const angle = orientation ? orientation[o + 3] : 0;\n        for (let k = 0, kl = crossSection.length; k < kl; k += 2) {\n          vertex.x = crossSection[k + 0];\n          vertex.y = 0;\n          vertex.z = crossSection[k + 1];\n          vertex.multiply(scaling);\n          quaternion.setFromAxisAngle(axis, angle);\n          vertex.applyQuaternion(quaternion);\n          vertex.add(spineVector);\n          vertices.push(vertex.x, vertex.y, vertex.z);\n        }\n      }\n      const indices = [];\n      const spineCount = spine.length / 3;\n      const crossSectionCount = crossSection.length / 2;\n      for (let i = 0; i < spineCount - 1; i++) {\n        for (let j = 0; j < crossSectionCount - 1; j++) {\n          const a = j + i * crossSectionCount;\n          let b = j + 1 + i * crossSectionCount;\n          const c = j + (i + 1) * crossSectionCount;\n          let d = j + 1 + (i + 1) * crossSectionCount;\n          if (j === crossSectionCount - 2 && crossSectionClosed === true) {\n            b = i * crossSectionCount;\n            d = (i + 1) * crossSectionCount;\n          }\n          if (ccw === true) {\n            indices.push(a, b, c);\n            indices.push(c, b, d);\n          } else {\n            indices.push(a, c, b);\n            indices.push(c, d, b);\n          }\n        }\n      }\n      if (beginCap === true || endCap === true) {\n        const contour = [];\n        for (let i = 0, l = crossSection.length; i < l; i += 2) {\n          contour.push(new Vector2(crossSection[i], crossSection[i + 1]));\n        }\n        const faces = ShapeUtils.triangulateShape(contour, []);\n        const capIndices = [];\n        for (let i = 0, l = faces.length; i < l; i++) {\n          const face = faces[i];\n          capIndices.push(face[0], face[1], face[2]);\n        }\n        if (beginCap === true) {\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(capIndices[i + 0], capIndices[i + 1], capIndices[i + 2]);\n            } else {\n              indices.push(capIndices[i + 0], capIndices[i + 2], capIndices[i + 1]);\n            }\n          }\n        }\n        if (endCap === true) {\n          const indexOffset = crossSectionCount * (spineCount - 1);\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(indexOffset + capIndices[i + 0], indexOffset + capIndices[i + 2], indexOffset + capIndices[i + 1]);\n            } else {\n              indices.push(indexOffset + capIndices[i + 0], indexOffset + capIndices[i + 1], indexOffset + capIndices[i + 2]);\n            }\n          }\n        }\n      }\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n      const normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n      const geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", positionAttribute);\n      geometry.setAttribute(\"normal\", normalAttribute);\n      geometry._solid = solid;\n      geometry._type = \"mesh\";\n      return geometry;\n    }\n    function resolveUSE(identifier) {\n      const node = nodeMap[identifier];\n      const build = getNode(node);\n      return build.isObject3D || build.isMaterial ? build.clone() : build;\n    }\n    function parseFieldChildren(children, owner) {\n      for (let i = 0, l = children.length; i < l; i++) {\n        const object = getNode(children[i]);\n        if (object instanceof Object3D) owner.add(object);\n      }\n    }\n    function triangulateFaceIndex(index, ccw) {\n      const indices = [];\n      let start = 0;\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[start];\n        const i2 = index[i + (ccw ? 1 : 2)];\n        const i3 = index[i + (ccw ? 2 : 1)];\n        indices.push(i1, i2, i3);\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3;\n          start = i + 1;\n        }\n      }\n      return indices;\n    }\n    function triangulateFaceData(data2, index) {\n      const triangulatedData = [];\n      let start = 0;\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3;\n        const x = data2[stride];\n        const y = data2[stride + 1];\n        const z = data2[stride + 2];\n        triangulatedData.push(x, y, z);\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3;\n          start++;\n        }\n      }\n      return triangulatedData;\n    }\n    function flattenData(data2, index) {\n      const flattenData2 = [];\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i];\n        const stride = i1 * 3;\n        const x = data2[stride];\n        const y = data2[stride + 1];\n        const z = data2[stride + 2];\n        flattenData2.push(x, y, z);\n      }\n      return flattenData2;\n    }\n    function expandLineIndex(index) {\n      const indices = [];\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i];\n        const i2 = index[i + 1];\n        indices.push(i1, i2);\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2;\n        }\n      }\n      return indices;\n    }\n    function expandLineData(data2, index) {\n      const triangulatedData = [];\n      let start = 0;\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3;\n        const x = data2[stride];\n        const y = data2[stride + 1];\n        const z = data2[stride + 2];\n        triangulatedData.push(x, y, z);\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2;\n          start++;\n        }\n      }\n      return triangulatedData;\n    }\n    const vA = new Vector3();\n    const vB = new Vector3();\n    const vC = new Vector3();\n    const uvA = new Vector2();\n    const uvB = new Vector2();\n    const uvC = new Vector2();\n    function computeAttributeFromIndexedData(coordIndex, index, data2, itemSize) {\n      const array = [];\n      for (let i = 0, l = coordIndex.length; i < l; i += 3) {\n        const a = index[i];\n        const b = index[i + 1];\n        const c = index[i + 2];\n        if (itemSize === 2) {\n          uvA.fromArray(data2, a * itemSize);\n          uvB.fromArray(data2, b * itemSize);\n          uvC.fromArray(data2, c * itemSize);\n          array.push(uvA.x, uvA.y);\n          array.push(uvB.x, uvB.y);\n          array.push(uvC.x, uvC.y);\n        } else {\n          vA.fromArray(data2, a * itemSize);\n          vB.fromArray(data2, b * itemSize);\n          vC.fromArray(data2, c * itemSize);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vB.x, vB.y, vB.z);\n          array.push(vC.x, vC.y, vC.z);\n        }\n      }\n      return new Float32BufferAttribute(array, itemSize);\n    }\n    function computeAttributeFromFaceData(index, faceData) {\n      const array = [];\n      for (let i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n        vA.fromArray(faceData, j * 3);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n      }\n      return new Float32BufferAttribute(array, 3);\n    }\n    function computeAttributeFromLineData(index, lineData) {\n      const array = [];\n      for (let i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n        vA.fromArray(lineData, j * 3);\n        array.push(vA.x, vA.y, vA.z);\n        array.push(vA.x, vA.y, vA.z);\n      }\n      return new Float32BufferAttribute(array, 3);\n    }\n    function toNonIndexedAttribute(indices, attribute) {\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      const array2 = new array.constructor(indices.length * itemSize);\n      let index = 0,\n        index2 = 0;\n      for (let i = 0, l = indices.length; i < l; i++) {\n        index = indices[i] * itemSize;\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n      return new Float32BufferAttribute(array2, itemSize);\n    }\n    const ab = new Vector3();\n    const cb = new Vector3();\n    function computeNormalAttribute(index, coord, creaseAngle) {\n      const faces = [];\n      const vertexNormals = {};\n      for (let i = 0, l = index.length; i < l; i += 3) {\n        const a = index[i];\n        const b = index[i + 1];\n        const c = index[i + 2];\n        const face = new Face(a, b, c);\n        vA.fromArray(coord, a * 3);\n        vB.fromArray(coord, b * 3);\n        vC.fromArray(coord, c * 3);\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        cb.normalize();\n        face.normal.copy(cb);\n        if (vertexNormals[a] === void 0) vertexNormals[a] = [];\n        if (vertexNormals[b] === void 0) vertexNormals[b] = [];\n        if (vertexNormals[c] === void 0) vertexNormals[c] = [];\n        vertexNormals[a].push(face.normal);\n        vertexNormals[b].push(face.normal);\n        vertexNormals[c].push(face.normal);\n        faces.push(face);\n      }\n      const normals = [];\n      for (let i = 0, l = faces.length; i < l; i++) {\n        const face = faces[i];\n        const nA = weightedNormal(vertexNormals[face.a], face.normal, creaseAngle);\n        const nB = weightedNormal(vertexNormals[face.b], face.normal, creaseAngle);\n        const nC = weightedNormal(vertexNormals[face.c], face.normal, creaseAngle);\n        vA.fromArray(coord, face.a * 3);\n        vB.fromArray(coord, face.b * 3);\n        vC.fromArray(coord, face.c * 3);\n        normals.push(nA.x, nA.y, nA.z);\n        normals.push(nB.x, nB.y, nB.z);\n        normals.push(nC.x, nC.y, nC.z);\n      }\n      return new Float32BufferAttribute(normals, 3);\n    }\n    function weightedNormal(normals, vector, creaseAngle) {\n      const normal = new Vector3();\n      if (creaseAngle === 0) {\n        normal.copy(vector);\n      } else {\n        for (let i = 0, l = normals.length; i < l; i++) {\n          if (normals[i].angleTo(vector) < creaseAngle) {\n            normal.add(normals[i]);\n          }\n        }\n      }\n      return normal.normalize();\n    }\n    function toColorArray(colors) {\n      const array = [];\n      for (let i = 0, l = colors.length; i < l; i += 3) {\n        array.push(new Color(colors[i], colors[i + 1], colors[i + 2]));\n      }\n      return array;\n    }\n    function paintFaces(geometry, radius, angles, colors, topDown) {\n      const thresholds = [];\n      const startAngle = topDown === true ? 0 : Math.PI;\n      for (let i = 0, l = colors.length; i < l; i++) {\n        let angle = i === 0 ? 0 : angles[i - 1];\n        angle = topDown === true ? angle : startAngle - angle;\n        const point = new Vector3();\n        point.setFromSphericalCoords(radius, angle, 0);\n        thresholds.push(point);\n      }\n      const indices = geometry.index;\n      const positionAttribute = geometry.attributes.position;\n      const colorAttribute = new BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\n      const position = new Vector3();\n      const color = new Color();\n      for (let i = 0; i < indices.count; i++) {\n        const index = indices.getX(i);\n        position.fromBufferAttribute(positionAttribute, index);\n        let thresholdIndexA, thresholdIndexB;\n        let t = 1;\n        for (let j = 1; j < thresholds.length; j++) {\n          thresholdIndexA = j - 1;\n          thresholdIndexB = j;\n          const thresholdA = thresholds[thresholdIndexA];\n          const thresholdB = thresholds[thresholdIndexB];\n          if (topDown === true) {\n            if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n              break;\n            }\n          } else {\n            if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n              break;\n            }\n          }\n        }\n        const colorA = colors[thresholdIndexA];\n        const colorB = colors[thresholdIndexB];\n        color.copy(colorA).lerp(colorB, t);\n        colorAttribute.setXYZ(index, color.r, color.g, color.b);\n      }\n      geometry.setAttribute(\"color\", colorAttribute);\n    }\n    const textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    if (data.indexOf(\"#VRML V2.0\") === -1) {\n      throw Error(\"THREE.VRMLLexer: Version of VRML asset not supported.\");\n    }\n    const tree = generateVRMLTree(data);\n    const scene = parseTree(tree);\n    return scene;\n  }\n}\nclass VRMLLexer {\n  constructor(tokens) {\n    this.lexer = new Lexer(tokens);\n  }\n  lex(inputText) {\n    const lexingResult = this.lexer.tokenize(inputText);\n    if (lexingResult.errors.length > 0) {\n      console.error(lexingResult.errors);\n      throw Error(\"THREE.VRMLLexer: Lexing errors detected.\");\n    }\n    return lexingResult;\n  }\n}\nclass VRMLParser extends CstParser {\n  constructor(tokenVocabulary) {\n    super(tokenVocabulary);\n    const $ = this;\n    const Version = tokenVocabulary[\"Version\"];\n    const LCurly = tokenVocabulary[\"LCurly\"];\n    const RCurly = tokenVocabulary[\"RCurly\"];\n    const LSquare = tokenVocabulary[\"LSquare\"];\n    const RSquare = tokenVocabulary[\"RSquare\"];\n    const Identifier = tokenVocabulary[\"Identifier\"];\n    const RouteIdentifier = tokenVocabulary[\"RouteIdentifier\"];\n    const StringLiteral = tokenVocabulary[\"StringLiteral\"];\n    const HexLiteral = tokenVocabulary[\"HexLiteral\"];\n    const NumberLiteral = tokenVocabulary[\"NumberLiteral\"];\n    const TrueLiteral = tokenVocabulary[\"TrueLiteral\"];\n    const FalseLiteral = tokenVocabulary[\"FalseLiteral\"];\n    const NullLiteral = tokenVocabulary[\"NullLiteral\"];\n    const DEF = tokenVocabulary[\"DEF\"];\n    const USE = tokenVocabulary[\"USE\"];\n    const ROUTE = tokenVocabulary[\"ROUTE\"];\n    const TO = tokenVocabulary[\"TO\"];\n    const NodeName = tokenVocabulary[\"NodeName\"];\n    $.RULE(\"vrml\", function () {\n      $.SUBRULE($.version);\n      $.AT_LEAST_ONE(function () {\n        $.SUBRULE($.node);\n      });\n      $.MANY(function () {\n        $.SUBRULE($.route);\n      });\n    });\n    $.RULE(\"version\", function () {\n      $.CONSUME(Version);\n    });\n    $.RULE(\"node\", function () {\n      $.OPTION(function () {\n        $.SUBRULE($.def);\n      });\n      $.CONSUME(NodeName);\n      $.CONSUME(LCurly);\n      $.MANY(function () {\n        $.SUBRULE($.field);\n      });\n      $.CONSUME(RCurly);\n    });\n    $.RULE(\"field\", function () {\n      $.CONSUME(Identifier);\n      $.OR2([{\n        ALT: function () {\n          $.SUBRULE($.singleFieldValue);\n        }\n      }, {\n        ALT: function () {\n          $.SUBRULE($.multiFieldValue);\n        }\n      }]);\n    });\n    $.RULE(\"def\", function () {\n      $.CONSUME(DEF);\n      $.OR([{\n        ALT: function () {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function () {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE(\"use\", function () {\n      $.CONSUME(USE);\n      $.OR([{\n        ALT: function () {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function () {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE(\"singleFieldValue\", function () {\n      $.AT_LEAST_ONE(function () {\n        $.OR([{\n          ALT: function () {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function () {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(TrueLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(FalseLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n    });\n    $.RULE(\"multiFieldValue\", function () {\n      $.CONSUME(LSquare);\n      $.MANY(function () {\n        $.OR([{\n          ALT: function () {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function () {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function () {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n      $.CONSUME(RSquare);\n    });\n    $.RULE(\"route\", function () {\n      $.CONSUME(ROUTE);\n      $.CONSUME(RouteIdentifier);\n      $.CONSUME(TO);\n      $.CONSUME2(RouteIdentifier);\n    });\n    this.performSelfAnalysis();\n  }\n}\nclass Face {\n  constructor(a, b, c) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = new Vector3();\n  }\n}\nconst TEXTURE_TYPE = {\n  INTENSITY: 1,\n  INTENSITY_ALPHA: 2,\n  RGB: 3,\n  RGBA: 4\n};\nexport { VRMLLoader };\n//# sourceMappingURL=VRMLLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}