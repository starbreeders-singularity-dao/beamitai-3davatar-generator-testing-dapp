{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c;\nimport { normalizeUnit } from './conversions.js';\nimport { numberNode, ZERO } from './parsers.js';\nconst $evaluate = Symbol('evaluate');\nconst $lastValue = Symbol('lastValue');\n/**\n * An Evaluator is used to derive a computed style from part (or all) of a CSS\n * expression AST. This construct is particularly useful for complex ASTs\n * containing function calls such as calc, var and env. Such styles could be\n * costly to re-evaluate on every frame (and in some cases we may try to do\n * that). The Evaluator construct allows us to mark sub-trees of the AST as\n * constant, so that only the dynamic parts are re-evaluated. It also separates\n * one-time AST preparation work from work that necessarily has to happen upon\n * each evaluation.\n */\nexport class Evaluator {\n  constructor() {\n    this[_a] = null;\n  }\n  /**\n   * An Evaluatable is a NumberNode or an Evaluator that evaluates a NumberNode\n   * as the result of invoking its evaluate method. This is mainly used to\n   * ensure that CSS function nodes are cast to the corresponding Evaluators\n   * that will resolve the result of the function, but is also used to ensure\n   * that a percentage nested at arbitrary depth in the expression will always\n   * be evaluated against the correct basis.\n   */\n  static evaluatableFor(node, basis = ZERO) {\n    if (node instanceof Evaluator) {\n      return node;\n    }\n    if (node.type === 'number') {\n      if (node.unit === '%') {\n        return new PercentageEvaluator(node, basis);\n      }\n      return node;\n    }\n    switch (node.name.value) {\n      case 'calc':\n        return new CalcEvaluator(node, basis);\n      case 'env':\n        return new EnvEvaluator(node);\n    }\n    return ZERO;\n  }\n  /**\n   * If the input is an Evaluator, returns the result of evaluating it.\n   * Otherwise, returns the input.\n   *\n   * This is a helper to aide in resolving a NumberNode without conditionally\n   * checking if the Evaluatable is an Evaluator everywhere.\n   */\n  static evaluate(evaluatable) {\n    if (evaluatable instanceof Evaluator) {\n      return evaluatable.evaluate();\n    }\n    return evaluatable;\n  }\n  /**\n   * If the input is an Evaluator, returns the value of its isConstant property.\n   * Returns true for all other input values.\n   */\n  static isConstant(evaluatable) {\n    if (evaluatable instanceof Evaluator) {\n      return evaluatable.isConstant;\n    }\n    return true;\n  }\n  /**\n   * This method applies a set of structured intrinsic metadata to an evaluated\n   * result from a parsed CSS-like string of expressions. Intrinsics provide\n   * sufficient metadata (e.g., basis values, analogs for keywords) such that\n   * omitted values in the input string can be backfilled, and keywords can be\n   * converted to concrete numbers.\n   *\n   * The result of applying intrinsics is a tuple of NumberNode values whose\n   * units match the units used by the basis of the intrinsics.\n   *\n   * The following is a high-level description of how intrinsics are applied:\n   *\n   *  1. Determine the value of 'auto' for the current term\n   *  2. If there is no corresponding input value for this term, substitute the\n   *     'auto' value.\n   *  3. If the term is an IdentNode, treat it as a keyword and perform the\n   *     appropriate substitution.\n   *  4. If the term is still null, fallback to the 'auto' value\n   *  5. If the term is a percentage, apply it to the basis and return that\n   *     value\n   *  6. Normalize the unit of the term\n   *  7. If the term's unit does not match the basis unit, return the basis\n   *     value\n   *  8. Return the term as is\n   */\n  static applyIntrinsics(evaluated, intrinsics) {\n    const {\n      basis,\n      keywords\n    } = intrinsics;\n    const {\n      auto\n    } = keywords;\n    return basis.map((basisNode, index) => {\n      // Use an auto value if we have it, otherwise the auto value is the basis:\n      const autoSubstituteNode = auto[index] == null ? basisNode : auto[index];\n      // If the evaluated nodes do not have a node at the current\n      // index, fallback to the \"auto\" substitute right away:\n      let evaluatedNode = evaluated[index] ? evaluated[index] : autoSubstituteNode;\n      // Any ident node is considered a keyword:\n      if (evaluatedNode.type === 'ident') {\n        const keyword = evaluatedNode.value;\n        // Substitute any keywords for concrete values first:\n        if (keyword in keywords) {\n          evaluatedNode = keywords[keyword][index];\n        }\n      }\n      // If we don't have a NumberNode at this point, fall back to whatever\n      // is specified for auto:\n      if (evaluatedNode == null || evaluatedNode.type === 'ident') {\n        evaluatedNode = autoSubstituteNode;\n      }\n      // For percentages, we always apply the percentage to the basis value:\n      if (evaluatedNode.unit === '%') {\n        return numberNode(evaluatedNode.number / 100 * basisNode.number, basisNode.unit);\n      }\n      // Otherwise, normalize whatever we have:\n      evaluatedNode = normalizeUnit(evaluatedNode, basisNode);\n      // If the normalized units do not match, return the basis as a fallback:\n      if (evaluatedNode.unit !== basisNode.unit) {\n        return basisNode;\n      }\n      // Finally, return the evaluated node with intrinsics applied:\n      return evaluatedNode;\n    });\n  }\n  /**\n   * If true, the Evaluator will only evaluate its AST one time. If false, the\n   * Evaluator will re-evaluate the AST each time that the public evaluate\n   * method is invoked.\n   */\n  get isConstant() {\n    return false;\n  }\n  /**\n   * Evaluate the Evaluator and return the result. If the Evaluator is constant,\n   * the corresponding AST will only be evaluated once, and the result of\n   * evaluating it the first time will be returned on all subsequent\n   * evaluations.\n   */\n  evaluate() {\n    if (!this.isConstant || this[$lastValue] == null) {\n      this[$lastValue] = this[$evaluate]();\n    }\n    return this[$lastValue];\n  }\n}\n_a = $lastValue;\nconst $percentage = Symbol('percentage');\nconst $basis = Symbol('basis');\n/**\n * A PercentageEvaluator scales a given basis value by a given percentage value.\n * The evaluated result is always considered to be constant.\n */\nexport class PercentageEvaluator extends Evaluator {\n  constructor(percentage, basis) {\n    super();\n    this[$percentage] = percentage;\n    this[$basis] = basis;\n  }\n  get isConstant() {\n    return true;\n  }\n  [$evaluate]() {\n    return numberNode(this[$percentage].number / 100 * this[$basis].number, this[$basis].unit);\n  }\n}\nconst $identNode = Symbol('identNode');\n/**\n * Evaluator for CSS-like env() functions. Currently, only one environment\n * variable is accepted as an argument for such functions: window-scroll-y.\n *\n * The env() Evaluator is explicitly dynamic because it always refers to\n * external state that changes as the user scrolls, so it should always be\n * re-evaluated to ensure we get the most recent value.\n *\n * Some important notes about this feature include:\n *\n *  - There is no such thing as a \"window-scroll-y\" CSS environment variable in\n *    any stable browser at the time that this comment is being written.\n *  - The actual CSS env() function accepts a second argument as a fallback for\n *    the case that the specified first argument isn't set; our syntax does not\n *    support this second argument.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/env\n */\nexport class EnvEvaluator extends Evaluator {\n  constructor(envFunction) {\n    super();\n    this[_b] = null;\n    const identNode = envFunction.arguments.length ? envFunction.arguments[0].terms[0] : null;\n    if (identNode != null && identNode.type === 'ident') {\n      this[$identNode] = identNode;\n    }\n  }\n  get isConstant() {\n    return false;\n  }\n  [(_b = $identNode, $evaluate)]() {\n    if (this[$identNode] != null) {\n      switch (this[$identNode].value) {\n        case 'window-scroll-y':\n          const verticalScrollPosition = window.pageYOffset;\n          const verticalScrollMax = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);\n          const scrollY = verticalScrollPosition / (verticalScrollMax - window.innerHeight) || 0;\n          return {\n            type: 'number',\n            number: scrollY,\n            unit: null\n          };\n      }\n    }\n    return ZERO;\n  }\n}\nconst IS_MULTIPLICATION_RE = /[\\*\\/]/;\nconst $evaluator = Symbol('evaluator');\n/**\n * Evaluator for CSS-like calc() functions. Our implementation of calc()\n * evaluation currently support nested function calls, an unlimited number of\n * terms, and all four algebraic operators (+, -, * and /).\n *\n * The Evaluator is marked as constant unless the calc expression contains an\n * internal env expression at any depth, in which case it will be marked as\n * dynamic.\n *\n * @see https://www.w3.org/TR/css-values-3/#calc-syntax\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc\n */\nexport class CalcEvaluator extends Evaluator {\n  constructor(calcFunction, basis = ZERO) {\n    super();\n    this[_c] = null;\n    if (calcFunction.arguments.length !== 1) {\n      return;\n    }\n    const terms = calcFunction.arguments[0].terms.slice();\n    const secondOrderTerms = [];\n    while (terms.length) {\n      const term = terms.shift();\n      if (secondOrderTerms.length > 0) {\n        const previousTerm = secondOrderTerms[secondOrderTerms.length - 1];\n        if (previousTerm.type === 'operator' && IS_MULTIPLICATION_RE.test(previousTerm.value)) {\n          const operator = secondOrderTerms.pop();\n          const leftValue = secondOrderTerms.pop();\n          if (leftValue == null) {\n            return;\n          }\n          secondOrderTerms.push(new OperatorEvaluator(operator, Evaluator.evaluatableFor(leftValue, basis), Evaluator.evaluatableFor(term, basis)));\n          continue;\n        }\n      }\n      secondOrderTerms.push(term.type === 'operator' ? term : Evaluator.evaluatableFor(term, basis));\n    }\n    while (secondOrderTerms.length > 2) {\n      const [left, operator, right] = secondOrderTerms.splice(0, 3);\n      if (operator.type !== 'operator') {\n        return;\n      }\n      secondOrderTerms.unshift(new OperatorEvaluator(operator, Evaluator.evaluatableFor(left, basis), Evaluator.evaluatableFor(right, basis)));\n    }\n    // There should only be one combined evaluator at this point:\n    if (secondOrderTerms.length === 1) {\n      this[$evaluator] = secondOrderTerms[0];\n    }\n  }\n  get isConstant() {\n    return this[$evaluator] == null || Evaluator.isConstant(this[$evaluator]);\n  }\n  [(_c = $evaluator, $evaluate)]() {\n    return this[$evaluator] != null ? Evaluator.evaluate(this[$evaluator]) : ZERO;\n  }\n}\nconst $operator = Symbol('operator');\nconst $left = Symbol('left');\nconst $right = Symbol('right');\n/**\n * An Evaluator for the operators found inside CSS calc() functions.\n * The evaluator accepts an operator and left/right operands. The operands can\n * be any valid expression term typically allowed inside a CSS calc function.\n *\n * As detail of this implementation, the only supported unit types are angles\n * expressed as radians or degrees, and lengths expressed as meters, centimeters\n * or millimeters.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc\n */\nexport class OperatorEvaluator extends Evaluator {\n  constructor(operator, left, right) {\n    super();\n    this[$operator] = operator;\n    this[$left] = left;\n    this[$right] = right;\n  }\n  get isConstant() {\n    return Evaluator.isConstant(this[$left]) && Evaluator.isConstant(this[$right]);\n  }\n  [$evaluate]() {\n    const leftNode = normalizeUnit(Evaluator.evaluate(this[$left]));\n    const rightNode = normalizeUnit(Evaluator.evaluate(this[$right]));\n    const {\n      number: leftValue,\n      unit: leftUnit\n    } = leftNode;\n    const {\n      number: rightValue,\n      unit: rightUnit\n    } = rightNode;\n    // Disallow operations for mismatched normalized units e.g., m and rad:\n    if (rightUnit != null && leftUnit != null && rightUnit != leftUnit) {\n      return ZERO;\n    }\n    // NOTE(cdata): rules for calc type checking are defined here\n    // https://drafts.csswg.org/css-values-3/#calc-type-checking\n    // This is a simplification and may not hold up once we begin to support\n    // additional unit types:\n    const unit = leftUnit || rightUnit;\n    let value;\n    switch (this[$operator].value) {\n      case '+':\n        value = leftValue + rightValue;\n        break;\n      case '-':\n        value = leftValue - rightValue;\n        break;\n      case '/':\n        value = leftValue / rightValue;\n        break;\n      case '*':\n        value = leftValue * rightValue;\n        break;\n      default:\n        return ZERO;\n    }\n    return {\n      type: 'number',\n      number: value,\n      unit\n    };\n  }\n}\nconst $evaluatables = Symbol('evaluatables');\nconst $intrinsics = Symbol('intrinsics');\n/**\n * A VectorEvaluator evaluates a series of numeric terms that usually represent\n * a data structure such as a multi-dimensional vector or a spherical\n *\n * The form of the evaluator's result is determined by the Intrinsics that are\n * given to it when it is constructed. For example, spherical intrinsics would\n * establish two angle terms and a length term, so the result of evaluating the\n * evaluator that is configured with spherical intrinsics is a three element\n * array where the first two elements represent angles in radians and the third\n * element representing a length in meters.\n */\nexport class StyleEvaluator extends Evaluator {\n  constructor(expressions, intrinsics) {\n    super();\n    this[$intrinsics] = intrinsics;\n    const firstExpression = expressions[0];\n    const terms = firstExpression != null ? firstExpression.terms : [];\n    this[$evaluatables] = intrinsics.basis.map((basisNode, index) => {\n      const term = terms[index];\n      if (term == null) {\n        return {\n          type: 'ident',\n          value: 'auto'\n        };\n      }\n      if (term.type === 'ident') {\n        return term;\n      }\n      return Evaluator.evaluatableFor(term, basisNode);\n    });\n  }\n  get isConstant() {\n    for (const evaluatable of this[$evaluatables]) {\n      if (!Evaluator.isConstant(evaluatable)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  [$evaluate]() {\n    const evaluated = this[$evaluatables].map(evaluatable => Evaluator.evaluate(evaluatable));\n    return Evaluator.applyIntrinsics(evaluated, this[$intrinsics]).map(numberNode => numberNode.number);\n  }\n}\n//# sourceMappingURL=evaluators.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}