{"ast":null,"code":"import { Vector3, Line3, Plane, Triangle } from \"three\";\nconst Visible = 0;\nconst Deleted = 1;\nconst _v1 = new Vector3();\nconst _line3 = new Line3();\nconst _plane = new Plane();\nconst _closestPoint = new Vector3();\nconst _triangle = new Triangle();\nclass ConvexHull {\n  constructor() {\n    this.tolerance = -1;\n    this.faces = [];\n    this.newFaces = [];\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = [];\n  }\n  setFromPoints(points) {\n    if (points.length >= 4) {\n      this.makeEmpty();\n      for (let i = 0, l = points.length; i < l; i++) {\n        this.vertices.push(new VertexNode(points[i]));\n      }\n      this.compute();\n    }\n    return this;\n  }\n  setFromObject(object) {\n    const points = [];\n    object.updateMatrixWorld(true);\n    object.traverse(function (node) {\n      const geometry = node.geometry;\n      if (geometry !== void 0) {\n        const attribute = geometry.attributes.position;\n        if (attribute !== void 0) {\n          for (let i = 0, l = attribute.count; i < l; i++) {\n            const point = new Vector3();\n            point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n            points.push(point);\n          }\n        }\n      }\n    });\n    return this.setFromPoints(points);\n  }\n  containsPoint(point) {\n    const faces = this.faces;\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i];\n      if (face.distanceToPoint(point) > this.tolerance) return false;\n    }\n    return true;\n  }\n  intersectRay(ray, target) {\n    const faces = this.faces;\n    let tNear = -Infinity;\n    let tFar = Infinity;\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i];\n      const vN = face.distanceToPoint(ray.origin);\n      const vD = face.normal.dot(ray.direction);\n      if (vN > 0 && vD >= 0) return null;\n      const t = vD !== 0 ? -vN / vD : 0;\n      if (t <= 0) continue;\n      if (vD > 0) {\n        tFar = Math.min(t, tFar);\n      } else {\n        tNear = Math.max(t, tNear);\n      }\n      if (tNear > tFar) {\n        return null;\n      }\n    }\n    if (tNear !== -Infinity) {\n      ray.at(tNear, target);\n    } else {\n      ray.at(tFar, target);\n    }\n    return target;\n  }\n  intersectsRay(ray) {\n    return this.intersectRay(ray, _v1) !== null;\n  }\n  makeEmpty() {\n    this.faces = [];\n    this.vertices = [];\n    return this;\n  }\n  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n  addVertexToFace(vertex, face) {\n    vertex.face = face;\n    if (face.outside === null) {\n      this.assigned.append(vertex);\n    } else {\n      this.assigned.insertBefore(face.outside, vertex);\n    }\n    face.outside = vertex;\n    return this;\n  }\n  // Removes a vertex from the 'assigned' list of vertices and from the given face\n  removeVertexFromFace(vertex, face) {\n    if (vertex === face.outside) {\n      if (vertex.next !== null && vertex.next.face === face) {\n        face.outside = vertex.next;\n      } else {\n        face.outside = null;\n      }\n    }\n    this.assigned.remove(vertex);\n    return this;\n  }\n  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list\n  removeAllVerticesFromFace(face) {\n    if (face.outside !== null) {\n      const start = face.outside;\n      let end = face.outside;\n      while (end.next !== null && end.next.face === face) {\n        end = end.next;\n      }\n      this.assigned.removeSubList(start, end);\n      start.prev = end.next = null;\n      face.outside = null;\n      return start;\n    }\n  }\n  // Removes all the visible vertices that 'face' is able to see\n  deleteFaceVertices(face, absorbingFace) {\n    const faceVertices = this.removeAllVerticesFromFace(face);\n    if (faceVertices !== void 0) {\n      if (absorbingFace === void 0) {\n        this.unassigned.appendChain(faceVertices);\n      } else {\n        let vertex = faceVertices;\n        do {\n          const nextVertex = vertex.next;\n          const distance = absorbingFace.distanceToPoint(vertex.point);\n          if (distance > this.tolerance) {\n            this.addVertexToFace(vertex, absorbingFace);\n          } else {\n            this.unassigned.append(vertex);\n          }\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n    }\n    return this;\n  }\n  // Reassigns as many vertices as possible from the unassigned list to the new faces\n  resolveUnassignedPoints(newFaces) {\n    if (this.unassigned.isEmpty() === false) {\n      let vertex = this.unassigned.first();\n      do {\n        const nextVertex = vertex.next;\n        let maxDistance = this.tolerance;\n        let maxFace = null;\n        for (let i = 0; i < newFaces.length; i++) {\n          const face = newFaces[i];\n          if (face.mark === Visible) {\n            const distance = face.distanceToPoint(vertex.point);\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              maxFace = face;\n            }\n            if (maxDistance > 1e3 * this.tolerance) break;\n          }\n        }\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n        vertex = nextVertex;\n      } while (vertex !== null);\n    }\n    return this;\n  }\n  // Computes the extremes of a simplex which will be the initial hull\n  computeExtremes() {\n    const min = new Vector3();\n    const max = new Vector3();\n    const minVertices = [];\n    const maxVertices = [];\n    for (let i = 0; i < 3; i++) {\n      minVertices[i] = maxVertices[i] = this.vertices[0];\n    }\n    min.copy(this.vertices[0].point);\n    max.copy(this.vertices[0].point);\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = this.vertices[i];\n      const point = vertex.point;\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) < min.getComponent(j)) {\n          min.setComponent(j, point.getComponent(j));\n          minVertices[j] = vertex;\n        }\n      }\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) > max.getComponent(j)) {\n          max.setComponent(j, point.getComponent(j));\n          maxVertices[j] = vertex;\n        }\n      }\n    }\n    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n    return {\n      min: minVertices,\n      max: maxVertices\n    };\n  }\n  // Computes the initial simplex assigning to its faces all the points\n  // that are candidates to form part of the hull\n  computeInitialHull() {\n    const vertices = this.vertices;\n    const extremes = this.computeExtremes();\n    const min = extremes.min;\n    const max = extremes.max;\n    let maxDistance = 0;\n    let index = 0;\n    for (let i = 0; i < 3; i++) {\n      const distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        index = i;\n      }\n    }\n    const v0 = min[index];\n    const v1 = max[index];\n    let v2;\n    let v3;\n    maxDistance = 0;\n    _line3.set(v0.point, v1.point);\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n      if (vertex !== v0 && vertex !== v1) {\n        _line3.closestPointToPoint(vertex.point, true, _closestPoint);\n        const distance = _closestPoint.distanceToSquared(vertex.point);\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v2 = vertex;\n        }\n      }\n    }\n    maxDistance = -1;\n    _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n        const distance = Math.abs(_plane.distanceToPoint(vertex.point));\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v3 = vertex;\n        }\n      }\n    }\n    const faces = [];\n    if (_plane.distanceToPoint(v3.point) < 0) {\n      faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2));\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3;\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j));\n        faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n      }\n    } else {\n      faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0));\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3;\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3));\n        faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));\n      }\n    }\n    for (let i = 0; i < 4; i++) {\n      this.faces.push(faces[i]);\n    }\n    for (let i = 0, l = vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n        maxDistance = this.tolerance;\n        let maxFace = null;\n        for (let j = 0; j < 4; j++) {\n          const distance = this.faces[j].distanceToPoint(vertex.point);\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            maxFace = this.faces[j];\n          }\n        }\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n      }\n    }\n    return this;\n  }\n  // Removes inactive faces\n  reindexFaces() {\n    const activeFaces = [];\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      if (face.mark === Visible) {\n        activeFaces.push(face);\n      }\n    }\n    this.faces = activeFaces;\n    return this;\n  }\n  // Finds the next vertex to create faces with the current hull\n  nextVertexToAdd() {\n    if (this.assigned.isEmpty() === false) {\n      let eyeVertex,\n        maxDistance = 0;\n      const eyeFace = this.assigned.first().face;\n      let vertex = eyeFace.outside;\n      do {\n        const distance = eyeFace.distanceToPoint(vertex.point);\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          eyeVertex = vertex;\n        }\n        vertex = vertex.next;\n      } while (vertex !== null && vertex.face === eyeFace);\n      return eyeVertex;\n    }\n  }\n  // Computes a chain of half edges in CCW order called the 'horizon'.\n  // For an edge to be part of the horizon it must join a face that can see\n  // 'eyePoint' and a face that cannot see 'eyePoint'.\n  computeHorizon(eyePoint, crossEdge, face, horizon) {\n    this.deleteFaceVertices(face);\n    face.mark = Deleted;\n    let edge;\n    if (crossEdge === null) {\n      edge = crossEdge = face.getEdge(0);\n    } else {\n      edge = crossEdge.next;\n    }\n    do {\n      const twinEdge = edge.twin;\n      const oppositeFace = twinEdge.face;\n      if (oppositeFace.mark === Visible) {\n        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n        } else {\n          horizon.push(edge);\n        }\n      }\n      edge = edge.next;\n    } while (edge !== crossEdge);\n    return this;\n  }\n  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n  addAdjoiningFace(eyeVertex, horizonEdge) {\n    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n    this.faces.push(face);\n    face.getEdge(-1).setTwin(horizonEdge.twin);\n    return face.getEdge(0);\n  }\n  //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n  //  horizon opposite face and the face on the left/right\n  addNewFaces(eyeVertex, horizon) {\n    this.newFaces = [];\n    let firstSideEdge = null;\n    let previousSideEdge = null;\n    for (let i = 0; i < horizon.length; i++) {\n      const horizonEdge = horizon[i];\n      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n      if (firstSideEdge === null) {\n        firstSideEdge = sideEdge;\n      } else {\n        sideEdge.next.setTwin(previousSideEdge);\n      }\n      this.newFaces.push(sideEdge.face);\n      previousSideEdge = sideEdge;\n    }\n    firstSideEdge.next.setTwin(previousSideEdge);\n    return this;\n  }\n  // Adds a vertex to the hull\n  addVertexToHull(eyeVertex) {\n    const horizon = [];\n    this.unassigned.clear();\n    this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n    this.addNewFaces(eyeVertex, horizon);\n    this.resolveUnassignedPoints(this.newFaces);\n    return this;\n  }\n  cleanup() {\n    this.assigned.clear();\n    this.unassigned.clear();\n    this.newFaces = [];\n    return this;\n  }\n  compute() {\n    let vertex;\n    this.computeInitialHull();\n    while ((vertex = this.nextVertexToAdd()) !== void 0) {\n      this.addVertexToHull(vertex);\n    }\n    this.reindexFaces();\n    this.cleanup();\n    return this;\n  }\n}\nclass Face {\n  constructor() {\n    this.normal = new Vector3();\n    this.midpoint = new Vector3();\n    this.area = 0;\n    this.constant = 0;\n    this.outside = null;\n    this.mark = Visible;\n    this.edge = null;\n  }\n  static create(a, b, c) {\n    const face = new Face();\n    const e0 = new HalfEdge(a, face);\n    const e1 = new HalfEdge(b, face);\n    const e2 = new HalfEdge(c, face);\n    e0.next = e2.prev = e1;\n    e1.next = e0.prev = e2;\n    e2.next = e1.prev = e0;\n    face.edge = e0;\n    return face.compute();\n  }\n  getEdge(i) {\n    let edge = this.edge;\n    while (i > 0) {\n      edge = edge.next;\n      i--;\n    }\n    while (i < 0) {\n      edge = edge.prev;\n      i++;\n    }\n    return edge;\n  }\n  compute() {\n    const a = this.edge.tail();\n    const b = this.edge.head();\n    const c = this.edge.next.head();\n    _triangle.set(a.point, b.point, c.point);\n    _triangle.getNormal(this.normal);\n    _triangle.getMidpoint(this.midpoint);\n    this.area = _triangle.getArea();\n    this.constant = this.normal.dot(this.midpoint);\n    return this;\n  }\n  distanceToPoint(point) {\n    return this.normal.dot(point) - this.constant;\n  }\n}\nclass HalfEdge {\n  constructor(vertex, face) {\n    this.vertex = vertex;\n    this.prev = null;\n    this.next = null;\n    this.twin = null;\n    this.face = face;\n  }\n  head() {\n    return this.vertex;\n  }\n  tail() {\n    return this.prev ? this.prev.vertex : null;\n  }\n  length() {\n    const head = this.head();\n    const tail = this.tail();\n    if (tail !== null) {\n      return tail.point.distanceTo(head.point);\n    }\n    return -1;\n  }\n  lengthSquared() {\n    const head = this.head();\n    const tail = this.tail();\n    if (tail !== null) {\n      return tail.point.distanceToSquared(head.point);\n    }\n    return -1;\n  }\n  setTwin(edge) {\n    this.twin = edge;\n    edge.twin = this;\n    return this;\n  }\n}\nclass VertexNode {\n  constructor(point) {\n    this.point = point;\n    this.prev = null;\n    this.next = null;\n    this.face = null;\n  }\n}\nclass VertexList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n  first() {\n    return this.head;\n  }\n  last() {\n    return this.tail;\n  }\n  clear() {\n    this.head = this.tail = null;\n    return this;\n  }\n  // Inserts a vertex before the target vertex\n  insertBefore(target, vertex) {\n    vertex.prev = target.prev;\n    vertex.next = target;\n    if (vertex.prev === null) {\n      this.head = vertex;\n    } else {\n      vertex.prev.next = vertex;\n    }\n    target.prev = vertex;\n    return this;\n  }\n  // Inserts a vertex after the target vertex\n  insertAfter(target, vertex) {\n    vertex.prev = target;\n    vertex.next = target.next;\n    if (vertex.next === null) {\n      this.tail = vertex;\n    } else {\n      vertex.next.prev = vertex;\n    }\n    target.next = vertex;\n    return this;\n  }\n  // Appends a vertex to the end of the linked list\n  append(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n    vertex.prev = this.tail;\n    vertex.next = null;\n    this.tail = vertex;\n    return this;\n  }\n  // Appends a chain of vertices where 'vertex' is the head.\n  appendChain(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n    vertex.prev = this.tail;\n    while (vertex.next !== null) {\n      vertex = vertex.next;\n    }\n    this.tail = vertex;\n    return this;\n  }\n  // Removes a vertex from the linked list\n  remove(vertex) {\n    if (vertex.prev === null) {\n      this.head = vertex.next;\n    } else {\n      vertex.prev.next = vertex.next;\n    }\n    if (vertex.next === null) {\n      this.tail = vertex.prev;\n    } else {\n      vertex.next.prev = vertex.prev;\n    }\n    return this;\n  }\n  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n  removeSubList(a, b) {\n    if (a.prev === null) {\n      this.head = b.next;\n    } else {\n      a.prev.next = b.next;\n    }\n    if (b.next === null) {\n      this.tail = a.prev;\n    } else {\n      b.next.prev = a.prev;\n    }\n    return this;\n  }\n  isEmpty() {\n    return this.head === null;\n  }\n}\nexport { ConvexHull, Face, HalfEdge, VertexList, VertexNode };\n//# sourceMappingURL=ConvexHull.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}