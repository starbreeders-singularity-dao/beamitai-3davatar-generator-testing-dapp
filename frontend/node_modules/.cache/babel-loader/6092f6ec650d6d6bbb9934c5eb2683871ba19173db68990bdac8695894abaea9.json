{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ClampToEdgeWrapping, LinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, MirroredRepeatWrapping, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, RepeatWrapping, Vector2 } from 'three';\nimport { toVector2D } from '../../model-viewer-base.js';\nimport { Filter, Wrap } from '../../three-components/gltf-instance/gltf-2.0.js';\nimport { $correlatedObjects, $onUpdate, ThreeDOMElement } from './three-dom-element.js';\n// Convertion between gltf standards and threejs standards.\nconst wrapModeToWrapping = new Map([[Wrap.Repeat, RepeatWrapping], [Wrap.ClampToEdge, ClampToEdgeWrapping], [Wrap.MirroredRepeat, MirroredRepeatWrapping]]);\nconst wrappingToWrapMode = new Map([[RepeatWrapping, Wrap.Repeat], [ClampToEdgeWrapping, Wrap.ClampToEdge], [MirroredRepeatWrapping, Wrap.MirroredRepeat]]);\nconst minFilterToMinification = new Map([[Filter.Nearest, NearestFilter], [Filter.Linear, LinearFilter], [Filter.NearestMipmapNearest, NearestMipmapNearestFilter], [Filter.LinearMipmapNearest, LinearMipmapNearestFilter], [Filter.NearestMipmapLinear, NearestMipmapLinearFilter], [Filter.LinearMipmapLinear, LinearMipmapLinearFilter]]);\nconst minificationToMinFilter = new Map([[NearestFilter, Filter.Nearest], [LinearFilter, Filter.Linear], [NearestMipmapNearestFilter, Filter.NearestMipmapNearest], [LinearMipmapNearestFilter, Filter.LinearMipmapNearest], [NearestMipmapLinearFilter, Filter.NearestMipmapLinear], [LinearMipmapLinearFilter, Filter.LinearMipmapLinear]]);\nconst magFilterToMagnification = new Map([[Filter.Nearest, NearestFilter], [Filter.Linear, LinearFilter]]);\nconst magnificationToMagFilter = new Map([[NearestFilter, Filter.Nearest], [LinearFilter, Filter.Linear]]);\n// Checks for threejs standards.\nconst isMinFilter = (() => {\n  return value => minificationToMinFilter.has(value);\n})();\nconst isMagFilter = (() => {\n  return value => magnificationToMagFilter.has(value);\n})();\nconst isWrapping = (() => {\n  return value => wrappingToWrapMode.has(value);\n})();\nconst isValidSamplerValue = (property, value) => {\n  switch (property) {\n    case 'minFilter':\n      return isMinFilter(value);\n    case 'magFilter':\n      return isMagFilter(value);\n    case 'wrapS':\n    case 'wrapT':\n      return isWrapping(value);\n    case 'rotation':\n    case 'repeat':\n    case 'offset':\n      return true;\n    default:\n      throw new Error(`Cannot configure property \"${property}\" on Sampler`);\n  }\n};\nconst $threeTexture = Symbol('threeTexture');\nconst $threeTextures = Symbol('threeTextures');\nconst $setProperty = Symbol('setProperty');\n/**\n * Sampler facade implementation for Three.js textures\n */\nexport class Sampler extends ThreeDOMElement {\n  get [$threeTexture]() {\n    var _a;\n    return (_a = this[$correlatedObjects]) === null || _a === void 0 ? void 0 : _a.values().next().value;\n  }\n  get [$threeTextures]() {\n    return this[$correlatedObjects];\n  }\n  constructor(onUpdate, texture) {\n    super(onUpdate, new Set(texture ? [texture] : []));\n  }\n  get name() {\n    return this[$threeTexture].name || '';\n  }\n  get minFilter() {\n    return minificationToMinFilter.get(this[$threeTexture].minFilter);\n  }\n  get magFilter() {\n    return magnificationToMagFilter.get(this[$threeTexture].magFilter);\n  }\n  get wrapS() {\n    return wrappingToWrapMode.get(this[$threeTexture].wrapS);\n  }\n  get wrapT() {\n    return wrappingToWrapMode.get(this[$threeTexture].wrapT);\n  }\n  get rotation() {\n    return this[$threeTexture].rotation;\n  }\n  get scale() {\n    return toVector2D(this[$threeTexture].repeat);\n  }\n  get offset() {\n    return toVector2D(this[$threeTexture].offset);\n  }\n  setMinFilter(filter) {\n    this[$setProperty]('minFilter', minFilterToMinification.get(filter));\n  }\n  setMagFilter(filter) {\n    this[$setProperty]('magFilter', magFilterToMagnification.get(filter));\n  }\n  setWrapS(mode) {\n    this[$setProperty]('wrapS', wrapModeToWrapping.get(mode));\n  }\n  setWrapT(mode) {\n    this[$setProperty]('wrapT', wrapModeToWrapping.get(mode));\n  }\n  setRotation(rotation) {\n    if (rotation == null) {\n      // Reset rotation.\n      rotation = 0;\n    }\n    this[$setProperty]('rotation', rotation);\n  }\n  setScale(scale) {\n    if (scale == null) {\n      // Reset scale.\n      scale = {\n        u: 1,\n        v: 1\n      };\n    }\n    this[$setProperty]('repeat', new Vector2(scale.u, scale.v));\n  }\n  setOffset(offset) {\n    if (offset == null) {\n      // Reset offset.\n      offset = {\n        u: 0,\n        v: 0\n      };\n    }\n    this[$setProperty]('offset', new Vector2(offset.u, offset.v));\n  }\n  [$setProperty](property, value) {\n    if (isValidSamplerValue(property, value)) {\n      for (const texture of this[$threeTextures]) {\n        texture[property] = value;\n        texture.needsUpdate = true;\n      }\n    }\n    this[$onUpdate]();\n  }\n}\n//# sourceMappingURL=sampler.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}