{"ast":null,"code":"import { BufferAttribute, DynamicDrawUsage, BufferGeometry, MeshStandardMaterial, Mesh, Vector3, Color, Matrix4 } from \"three\";\nfunction TubePainter() {\n  const BUFFER_SIZE = 1e6 * 3;\n  const positions = new BufferAttribute(new Float32Array(BUFFER_SIZE), 3);\n  positions.usage = DynamicDrawUsage;\n  const normals = new BufferAttribute(new Float32Array(BUFFER_SIZE), 3);\n  normals.usage = DynamicDrawUsage;\n  const colors = new BufferAttribute(new Float32Array(BUFFER_SIZE), 3);\n  colors.usage = DynamicDrawUsage;\n  const geometry = new BufferGeometry();\n  geometry.setAttribute(\"position\", positions);\n  geometry.setAttribute(\"normal\", normals);\n  geometry.setAttribute(\"color\", colors);\n  geometry.drawRange.count = 0;\n  const material = new MeshStandardMaterial({\n    vertexColors: true\n  });\n  const mesh = new Mesh(geometry, material);\n  mesh.frustumCulled = false;\n  function getPoints(size2) {\n    const PI2 = Math.PI * 2;\n    const sides = 10;\n    const array = [];\n    const radius = 0.01 * size2;\n    for (let i = 0; i < sides; i++) {\n      const angle = i / sides * PI2;\n      array.push(new Vector3(Math.sin(angle) * radius, Math.cos(angle) * radius, 0));\n    }\n    return array;\n  }\n  const vector1 = new Vector3();\n  const vector2 = new Vector3();\n  const vector3 = new Vector3();\n  const vector4 = new Vector3();\n  const color = new Color(16777215);\n  let size = 1;\n  function stroke(position1, position2, matrix12, matrix22) {\n    if (position1.distanceToSquared(position2) === 0) return;\n    let count2 = geometry.drawRange.count;\n    const points = getPoints(size);\n    for (let i = 0, il = points.length; i < il; i++) {\n      const vertex1 = points[i];\n      const vertex2 = points[(i + 1) % il];\n      vector1.copy(vertex1).applyMatrix4(matrix22).add(position2);\n      vector2.copy(vertex2).applyMatrix4(matrix22).add(position2);\n      vector3.copy(vertex2).applyMatrix4(matrix12).add(position1);\n      vector4.copy(vertex1).applyMatrix4(matrix12).add(position1);\n      vector1.toArray(positions.array, (count2 + 0) * 3);\n      vector2.toArray(positions.array, (count2 + 1) * 3);\n      vector4.toArray(positions.array, (count2 + 2) * 3);\n      vector2.toArray(positions.array, (count2 + 3) * 3);\n      vector3.toArray(positions.array, (count2 + 4) * 3);\n      vector4.toArray(positions.array, (count2 + 5) * 3);\n      vector1.copy(vertex1).applyMatrix4(matrix22).normalize();\n      vector2.copy(vertex2).applyMatrix4(matrix22).normalize();\n      vector3.copy(vertex2).applyMatrix4(matrix12).normalize();\n      vector4.copy(vertex1).applyMatrix4(matrix12).normalize();\n      vector1.toArray(normals.array, (count2 + 0) * 3);\n      vector2.toArray(normals.array, (count2 + 1) * 3);\n      vector4.toArray(normals.array, (count2 + 2) * 3);\n      vector2.toArray(normals.array, (count2 + 3) * 3);\n      vector3.toArray(normals.array, (count2 + 4) * 3);\n      vector4.toArray(normals.array, (count2 + 5) * 3);\n      color.toArray(colors.array, (count2 + 0) * 3);\n      color.toArray(colors.array, (count2 + 1) * 3);\n      color.toArray(colors.array, (count2 + 2) * 3);\n      color.toArray(colors.array, (count2 + 3) * 3);\n      color.toArray(colors.array, (count2 + 4) * 3);\n      color.toArray(colors.array, (count2 + 5) * 3);\n      count2 += 6;\n    }\n    geometry.drawRange.count = count2;\n  }\n  const up = new Vector3(0, 1, 0);\n  const point1 = new Vector3();\n  const point2 = new Vector3();\n  const matrix1 = new Matrix4();\n  const matrix2 = new Matrix4();\n  function moveTo(position) {\n    point1.copy(position);\n    matrix1.lookAt(point2, point1, up);\n    point2.copy(position);\n    matrix2.copy(matrix1);\n  }\n  function lineTo(position) {\n    point1.copy(position);\n    matrix1.lookAt(point2, point1, up);\n    stroke(point1, point2, matrix1, matrix2);\n    point2.copy(point1);\n    matrix2.copy(matrix1);\n  }\n  function setSize(value) {\n    size = value;\n  }\n  let count = 0;\n  function update() {\n    const start = count;\n    const end = geometry.drawRange.count;\n    if (start === end) return;\n    positions.updateRange.offset = start * 3;\n    positions.updateRange.count = (end - start) * 3;\n    positions.needsUpdate = true;\n    normals.updateRange.offset = start * 3;\n    normals.updateRange.count = (end - start) * 3;\n    normals.needsUpdate = true;\n    colors.updateRange.offset = start * 3;\n    colors.updateRange.count = (end - start) * 3;\n    colors.needsUpdate = true;\n    count = geometry.drawRange.count;\n  }\n  return {\n    mesh,\n    moveTo,\n    lineTo,\n    setSize,\n    update\n  };\n}\nexport { TubePainter };\n//# sourceMappingURL=TubePainter.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}