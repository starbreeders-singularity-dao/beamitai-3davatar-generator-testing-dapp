{"ast":null,"code":"import { Vector3, Matrix4, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\nexport class OrientedBox {\n  constructor(min, max, matrix) {\n    this.isOrientedBox = true;\n    this.min = new Vector3();\n    this.max = new Vector3();\n    this.matrix = new Matrix4();\n    this.invMatrix = new Matrix4();\n    this.points = new Array(8).fill().map(() => new Vector3());\n    this.satAxes = new Array(3).fill().map(() => new Vector3());\n    this.satBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());\n    this.alignedSatBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());\n    this.needsUpdate = false;\n    if (min) this.min.copy(min);\n    if (max) this.max.copy(max);\n    if (matrix) this.matrix.copy(matrix);\n  }\n  set(min, max, matrix) {\n    this.min.copy(min);\n    this.max.copy(max);\n    this.matrix.copy(matrix);\n    this.needsUpdate = true;\n  }\n  copy(other) {\n    this.min.copy(other.min);\n    this.max.copy(other.max);\n    this.matrix.copy(other.matrix);\n    this.needsUpdate = true;\n  }\n}\nOrientedBox.prototype.update = function () {\n  return function update() {\n    const matrix = this.matrix;\n    const min = this.min;\n    const max = this.max;\n    const points = this.points;\n    for (let x = 0; x <= 1; x++) {\n      for (let y = 0; y <= 1; y++) {\n        for (let z = 0; z <= 1; z++) {\n          const i = (1 << 0) * x | (1 << 1) * y | (1 << 2) * z;\n          const v = points[i];\n          v.x = x ? max.x : min.x;\n          v.y = y ? max.y : min.y;\n          v.z = z ? max.z : min.z;\n          v.applyMatrix4(matrix);\n        }\n      }\n    }\n    const satBounds = this.satBounds;\n    const satAxes = this.satAxes;\n    const minVec = points[0];\n    for (let i = 0; i < 3; i++) {\n      const axis = satAxes[i];\n      const sb = satBounds[i];\n      const index = 1 << i;\n      const pi = points[index];\n      axis.subVectors(minVec, pi);\n      sb.setFromPoints(axis, points);\n    }\n    const alignedSatBounds = this.alignedSatBounds;\n    alignedSatBounds[0].setFromPointsField(points, 'x');\n    alignedSatBounds[1].setFromPointsField(points, 'y');\n    alignedSatBounds[2].setFromPointsField(points, 'z');\n    this.invMatrix.copy(this.matrix).invert();\n    this.needsUpdate = false;\n  };\n}();\nOrientedBox.prototype.intersectsBox = function () {\n  const aabbBounds = new SeparatingAxisBounds();\n  return function intersectsBox(box) {\n    // TODO: should this be doing SAT against the AABB?\n    if (this.needsUpdate) {\n      this.update();\n    }\n    const min = box.min;\n    const max = box.max;\n    const satBounds = this.satBounds;\n    const satAxes = this.satAxes;\n    const alignedSatBounds = this.alignedSatBounds;\n    aabbBounds.min = min.x;\n    aabbBounds.max = max.x;\n    if (alignedSatBounds[0].isSeparated(aabbBounds)) return false;\n    aabbBounds.min = min.y;\n    aabbBounds.max = max.y;\n    if (alignedSatBounds[1].isSeparated(aabbBounds)) return false;\n    aabbBounds.min = min.z;\n    aabbBounds.max = max.z;\n    if (alignedSatBounds[2].isSeparated(aabbBounds)) return false;\n    for (let i = 0; i < 3; i++) {\n      const axis = satAxes[i];\n      const sb = satBounds[i];\n      aabbBounds.setFromBox(axis, box);\n      if (sb.isSeparated(aabbBounds)) return false;\n    }\n    return true;\n  };\n}();\nOrientedBox.prototype.intersectsTriangle = function () {\n  const saTri = new ExtendedTriangle();\n  const pointsArr = new Array(3);\n  const cachedSatBounds = new SeparatingAxisBounds();\n  const cachedSatBounds2 = new SeparatingAxisBounds();\n  const cachedAxis = new Vector3();\n  return function intersectsTriangle(triangle) {\n    if (this.needsUpdate) {\n      this.update();\n    }\n    if (!triangle.isExtendedTriangle) {\n      saTri.copy(triangle);\n      saTri.update();\n      triangle = saTri;\n    } else if (triangle.needsUpdate) {\n      triangle.update();\n    }\n    const satBounds = this.satBounds;\n    const satAxes = this.satAxes;\n    pointsArr[0] = triangle.a;\n    pointsArr[1] = triangle.b;\n    pointsArr[2] = triangle.c;\n    for (let i = 0; i < 3; i++) {\n      const sb = satBounds[i];\n      const sa = satAxes[i];\n      cachedSatBounds.setFromPoints(sa, pointsArr);\n      if (sb.isSeparated(cachedSatBounds)) return false;\n    }\n    const triSatBounds = triangle.satBounds;\n    const triSatAxes = triangle.satAxes;\n    const points = this.points;\n    for (let i = 0; i < 3; i++) {\n      const sb = triSatBounds[i];\n      const sa = triSatAxes[i];\n      cachedSatBounds.setFromPoints(sa, points);\n      if (sb.isSeparated(cachedSatBounds)) return false;\n    }\n\n    // check crossed axes\n    for (let i = 0; i < 3; i++) {\n      const sa1 = satAxes[i];\n      for (let i2 = 0; i2 < 4; i2++) {\n        const sa2 = triSatAxes[i2];\n        cachedAxis.crossVectors(sa1, sa2);\n        cachedSatBounds.setFromPoints(cachedAxis, pointsArr);\n        cachedSatBounds2.setFromPoints(cachedAxis, points);\n        if (cachedSatBounds.isSeparated(cachedSatBounds2)) return false;\n      }\n    }\n    return true;\n  };\n}();\nOrientedBox.prototype.closestPointToPoint = function () {\n  return function closestPointToPoint(point, target1) {\n    if (this.needsUpdate) {\n      this.update();\n    }\n    target1.copy(point).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix);\n    return target1;\n  };\n}();\nOrientedBox.prototype.distanceToPoint = function () {\n  const target = new Vector3();\n  return function distanceToPoint(point) {\n    this.closestPointToPoint(point, target);\n    return point.distanceTo(target);\n  };\n}();\nOrientedBox.prototype.distanceToBox = function () {\n  const xyzFields = ['x', 'y', 'z'];\n  const segments1 = new Array(12).fill().map(() => new Line3());\n  const segments2 = new Array(12).fill().map(() => new Line3());\n  const point1 = new Vector3();\n  const point2 = new Vector3();\n\n  // early out if we find a value below threshold\n  return function distanceToBox(box, threshold = 0, target1 = null, target2 = null) {\n    if (this.needsUpdate) {\n      this.update();\n    }\n    if (this.intersectsBox(box)) {\n      if (target1 || target2) {\n        box.getCenter(point2);\n        this.closestPointToPoint(point2, point1);\n        box.closestPointToPoint(point1, point2);\n        if (target1) target1.copy(point1);\n        if (target2) target2.copy(point2);\n      }\n      return 0;\n    }\n    const threshold2 = threshold * threshold;\n    const min = box.min;\n    const max = box.max;\n    const points = this.points;\n\n    // iterate over every edge and compare distances\n    let closestDistanceSq = Infinity;\n\n    // check over all these points\n    for (let i = 0; i < 8; i++) {\n      const p = points[i];\n      point2.copy(p).clamp(min, max);\n      const dist = p.distanceToSquared(point2);\n      if (dist < closestDistanceSq) {\n        closestDistanceSq = dist;\n        if (target1) target1.copy(p);\n        if (target2) target2.copy(point2);\n        if (dist < threshold2) return Math.sqrt(dist);\n      }\n    }\n\n    // generate and check all line segment distances\n    let count = 0;\n    for (let i = 0; i < 3; i++) {\n      for (let i1 = 0; i1 <= 1; i1++) {\n        for (let i2 = 0; i2 <= 1; i2++) {\n          const nextIndex = (i + 1) % 3;\n          const nextIndex2 = (i + 2) % 3;\n\n          // get obb line segments\n          const index = i1 << nextIndex | i2 << nextIndex2;\n          const index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n          const p1 = points[index];\n          const p2 = points[index2];\n          const line1 = segments1[count];\n          line1.set(p1, p2);\n\n          // get aabb line segments\n          const f1 = xyzFields[i];\n          const f2 = xyzFields[nextIndex];\n          const f3 = xyzFields[nextIndex2];\n          const line2 = segments2[count];\n          const start = line2.start;\n          const end = line2.end;\n          start[f1] = min[f1];\n          start[f2] = i1 ? min[f2] : max[f2];\n          start[f3] = i2 ? min[f3] : max[f2];\n          end[f1] = max[f1];\n          end[f2] = i1 ? min[f2] : max[f2];\n          end[f3] = i2 ? min[f3] : max[f2];\n          count++;\n        }\n      }\n    }\n\n    // check all the other boxes point\n    for (let x = 0; x <= 1; x++) {\n      for (let y = 0; y <= 1; y++) {\n        for (let z = 0; z <= 1; z++) {\n          point2.x = x ? max.x : min.x;\n          point2.y = y ? max.y : min.y;\n          point2.z = z ? max.z : min.z;\n          this.closestPointToPoint(point2, point1);\n          const dist = point2.distanceToSquared(point1);\n          if (dist < closestDistanceSq) {\n            closestDistanceSq = dist;\n            if (target1) target1.copy(point1);\n            if (target2) target2.copy(point2);\n            if (dist < threshold2) return Math.sqrt(dist);\n          }\n        }\n      }\n    }\n    for (let i = 0; i < 12; i++) {\n      const l1 = segments1[i];\n      for (let i2 = 0; i2 < 12; i2++) {\n        const l2 = segments2[i2];\n        closestPointsSegmentToSegment(l1, l2, point1, point2);\n        const dist = point1.distanceToSquared(point2);\n        if (dist < closestDistanceSq) {\n          closestDistanceSq = dist;\n          if (target1) target1.copy(point1);\n          if (target2) target2.copy(point2);\n          if (dist < threshold2) return Math.sqrt(dist);\n        }\n      }\n    }\n    return Math.sqrt(closestDistanceSq);\n  };\n}();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}