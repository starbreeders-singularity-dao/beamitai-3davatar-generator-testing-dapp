{"ast":null,"code":"import { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST } from '../Constants.js';\nconst BIN_COUNT = 32;\nconst binsSort = (a, b) => a.candidate - b.candidate;\nconst sahBins = new Array(BIN_COUNT).fill().map(() => {\n  return {\n    count: 0,\n    bounds: new Float32Array(6),\n    rightCacheBounds: new Float32Array(6),\n    leftCacheBounds: new Float32Array(6),\n    candidate: 0\n  };\n});\nconst leftBounds = new Float32Array(6);\nexport function getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {\n  let axis = -1;\n  let pos = 0;\n\n  // Center\n  if (strategy === CENTER) {\n    axis = getLongestEdgeIndex(centroidBoundingData);\n    if (axis !== -1) {\n      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;\n    }\n  } else if (strategy === AVERAGE) {\n    axis = getLongestEdgeIndex(nodeBoundingData);\n    if (axis !== -1) {\n      pos = getAverage(triangleBounds, offset, count, axis);\n    }\n  } else if (strategy === SAH) {\n    const rootSurfaceArea = computeSurfaceArea(nodeBoundingData);\n    let bestCost = TRIANGLE_INTERSECT_COST * count;\n\n    // iterate over all axes\n    const cStart = offset * 6;\n    const cEnd = (offset + count) * 6;\n    for (let a = 0; a < 3; a++) {\n      const axisLeft = centroidBoundingData[a];\n      const axisRight = centroidBoundingData[a + 3];\n      const axisLength = axisRight - axisLeft;\n      const binWidth = axisLength / BIN_COUNT;\n\n      // If we have fewer triangles than we're planning to split then just check all\n      // the triangle positions because it will be faster.\n      if (count < BIN_COUNT / 4) {\n        // initialize the bin candidates\n        const truncatedBins = [...sahBins];\n        truncatedBins.length = count;\n\n        // set the candidates\n        let b = 0;\n        for (let c = cStart; c < cEnd; c += 6, b++) {\n          const bin = truncatedBins[b];\n          bin.candidate = triangleBounds[c + 2 * a];\n          bin.count = 0;\n          const {\n            bounds,\n            leftCacheBounds,\n            rightCacheBounds\n          } = bin;\n          for (let d = 0; d < 3; d++) {\n            rightCacheBounds[d] = Infinity;\n            rightCacheBounds[d + 3] = -Infinity;\n            leftCacheBounds[d] = Infinity;\n            leftCacheBounds[d + 3] = -Infinity;\n            bounds[d] = Infinity;\n            bounds[d + 3] = -Infinity;\n          }\n          expandByTriangleBounds(c, triangleBounds, bounds);\n        }\n        truncatedBins.sort(binsSort);\n\n        // remove redundant splits\n        let splitCount = count;\n        for (let bi = 0; bi < splitCount; bi++) {\n          const bin = truncatedBins[bi];\n          while (bi + 1 < splitCount && truncatedBins[bi + 1].candidate === bin.candidate) {\n            truncatedBins.splice(bi + 1, 1);\n            splitCount--;\n          }\n        }\n\n        // find the appropriate bin for each triangle and expand the bounds.\n        for (let c = cStart; c < cEnd; c += 6) {\n          const center = triangleBounds[c + 2 * a];\n          for (let bi = 0; bi < splitCount; bi++) {\n            const bin = truncatedBins[bi];\n            if (center >= bin.candidate) {\n              expandByTriangleBounds(c, triangleBounds, bin.rightCacheBounds);\n            } else {\n              expandByTriangleBounds(c, triangleBounds, bin.leftCacheBounds);\n              bin.count++;\n            }\n          }\n        }\n\n        // expand all the bounds\n        for (let bi = 0; bi < splitCount; bi++) {\n          const bin = truncatedBins[bi];\n          const leftCount = bin.count;\n          const rightCount = count - bin.count;\n\n          // check the cost of this split\n          const leftBounds = bin.leftCacheBounds;\n          const rightBounds = bin.rightCacheBounds;\n          let leftProb = 0;\n          if (leftCount !== 0) {\n            leftProb = computeSurfaceArea(leftBounds) / rootSurfaceArea;\n          }\n          let rightProb = 0;\n          if (rightCount !== 0) {\n            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;\n          }\n          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);\n          if (cost < bestCost) {\n            axis = a;\n            bestCost = cost;\n            pos = bin.candidate;\n          }\n        }\n      } else {\n        // reset the bins\n        for (let i = 0; i < BIN_COUNT; i++) {\n          const bin = sahBins[i];\n          bin.count = 0;\n          bin.candidate = axisLeft + binWidth + i * binWidth;\n          const bounds = bin.bounds;\n          for (let d = 0; d < 3; d++) {\n            bounds[d] = Infinity;\n            bounds[d + 3] = -Infinity;\n          }\n        }\n\n        // iterate over all center positions\n        for (let c = cStart; c < cEnd; c += 6) {\n          const triCenter = triangleBounds[c + 2 * a];\n          const relativeCenter = triCenter - axisLeft;\n\n          // in the partition function if the centroid lies on the split plane then it is\n          // considered to be on the right side of the split\n          let binIndex = ~~(relativeCenter / binWidth);\n          if (binIndex >= BIN_COUNT) binIndex = BIN_COUNT - 1;\n          const bin = sahBins[binIndex];\n          bin.count++;\n          expandByTriangleBounds(c, triangleBounds, bin.bounds);\n        }\n\n        // cache the unioned bounds from right to left so we don't have to regenerate them each time\n        const lastBin = sahBins[BIN_COUNT - 1];\n        copyBounds(lastBin.bounds, lastBin.rightCacheBounds);\n        for (let i = BIN_COUNT - 2; i >= 0; i--) {\n          const bin = sahBins[i];\n          const nextBin = sahBins[i + 1];\n          unionBounds(bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds);\n        }\n        let leftCount = 0;\n        for (let i = 0; i < BIN_COUNT - 1; i++) {\n          const bin = sahBins[i];\n          const binCount = bin.count;\n          const bounds = bin.bounds;\n          const nextBin = sahBins[i + 1];\n          const rightBounds = nextBin.rightCacheBounds;\n\n          // don't do anything with the bounds if the new bounds have no triangles\n          if (binCount !== 0) {\n            if (leftCount === 0) {\n              copyBounds(bounds, leftBounds);\n            } else {\n              unionBounds(bounds, leftBounds, leftBounds);\n            }\n          }\n          leftCount += binCount;\n\n          // check the cost of this split\n          let leftProb = 0;\n          let rightProb = 0;\n          if (leftCount !== 0) {\n            leftProb = computeSurfaceArea(leftBounds) / rootSurfaceArea;\n          }\n          const rightCount = count - leftCount;\n          if (rightCount !== 0) {\n            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;\n          }\n          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);\n          if (cost < bestCost) {\n            axis = a;\n            bestCost = cost;\n            pos = bin.candidate;\n          }\n        }\n      }\n    }\n  } else {\n    console.warn(`MeshBVH: Invalid build strategy value ${strategy} used.`);\n  }\n  return {\n    axis,\n    pos\n  };\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage(triangleBounds, offset, count, axis) {\n  let avg = 0;\n  for (let i = offset, end = offset + count; i < end; i++) {\n    avg += triangleBounds[i * 6 + axis * 2];\n  }\n  return avg / count;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}