{"ast":null,"code":"import { DataTextureLoader, HalfFloatType, CubeTexture, RGBAFormat, LinearFilter, DataUtils } from \"three\";\nlet UPNG;\nfunction init() {\n  if (UPNG) return UPNG;\n  UPNG = {};\n  UPNG.toRGBA8 = function (out) {\n    var w = out.width,\n      h = out.height;\n    if (out.tabs.acTL == null) return [UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer];\n    var frms = [];\n    if (out.frames[0].data == null) out.frames[0].data = out.data;\n    var len = w * h * 4,\n      img = new Uint8Array(len),\n      empty = new Uint8Array(len),\n      prev = new Uint8Array(len);\n    for (var i = 0; i < out.frames.length; i++) {\n      var frm = out.frames[i];\n      var fx = frm.rect.x,\n        fy = frm.rect.y,\n        fw = frm.rect.width,\n        fh = frm.rect.height;\n      var fdata = UPNG.toRGBA8.decodeImage(frm.data, fw, fh, out);\n      if (i != 0) for (var j = 0; j < len; j++) prev[j] = img[j];\n      if (frm.blend == 0) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);else if (frm.blend == 1) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);\n      frms.push(img.buffer.slice(0));\n      if (frm.dispose == 1) UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);else if (frm.dispose == 2) for (var j = 0; j < len; j++) img[j] = prev[j];\n    }\n    return frms;\n  };\n  UPNG.toRGBA8.decodeImage = function (data, w, h, out) {\n    var area = w * h,\n      bpp = UPNG.decode._getBPP(out);\n    var bpl = Math.ceil(w * bpp / 8);\n    var bf = new Uint8Array(area * 4),\n      bf32 = new Uint32Array(bf.buffer);\n    var ctype = out.ctype,\n      depth = out.depth;\n    var rs = UPNG._bin.readUshort;\n    if (ctype == 6) {\n      var qarea = area << 2;\n      if (depth == 8) {\n        for (var i = 0; i < qarea; i += 4) {\n          bf[i] = data[i];\n          bf[i + 1] = data[i + 1];\n          bf[i + 2] = data[i + 2];\n          bf[i + 3] = data[i + 3];\n        }\n      }\n      if (depth == 16) {\n        for (var i = 0; i < qarea; i++) {\n          bf[i] = data[i << 1];\n        }\n      }\n    } else if (ctype == 2) {\n      var ts = out.tabs[\"tRNS\"];\n      if (ts == null) {\n        if (depth == 8) {\n          for (var i = 0; i < area; i++) {\n            var ti = i * 3;\n            bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];\n          }\n        }\n        if (depth == 16) {\n          for (var i = 0; i < area; i++) {\n            var ti = i * 6;\n            bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];\n          }\n        }\n      } else {\n        var tr = ts[0],\n          tg = ts[1],\n          tb = ts[2];\n        if (depth == 8) {\n          for (var i = 0; i < area; i++) {\n            var qi = i << 2,\n              ti = i * 3;\n            bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];\n            if (data[ti] == tr && data[ti + 1] == tg && data[ti + 2] == tb) bf[qi + 3] = 0;\n          }\n        }\n        if (depth == 16) {\n          for (var i = 0; i < area; i++) {\n            var qi = i << 2,\n              ti = i * 6;\n            bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];\n            if (rs(data, ti) == tr && rs(data, ti + 2) == tg && rs(data, ti + 4) == tb) bf[qi + 3] = 0;\n          }\n        }\n      }\n    } else if (ctype == 3) {\n      var p = out.tabs[\"PLTE\"],\n        ap = out.tabs[\"tRNS\"],\n        tl = ap ? ap.length : 0;\n      if (depth == 1) {\n        for (var y = 0; y < h; y++) {\n          var s0 = y * bpl,\n            t0 = y * w;\n          for (var i = 0; i < w; i++) {\n            var qi = t0 + i << 2,\n              j = data[s0 + (i >> 3)] >> 7 - ((i & 7) << 0) & 1,\n              cj = 3 * j;\n            bf[qi] = p[cj];\n            bf[qi + 1] = p[cj + 1];\n            bf[qi + 2] = p[cj + 2];\n            bf[qi + 3] = j < tl ? ap[j] : 255;\n          }\n        }\n      }\n      if (depth == 2) {\n        for (var y = 0; y < h; y++) {\n          var s0 = y * bpl,\n            t0 = y * w;\n          for (var i = 0; i < w; i++) {\n            var qi = t0 + i << 2,\n              j = data[s0 + (i >> 2)] >> 6 - ((i & 3) << 1) & 3,\n              cj = 3 * j;\n            bf[qi] = p[cj];\n            bf[qi + 1] = p[cj + 1];\n            bf[qi + 2] = p[cj + 2];\n            bf[qi + 3] = j < tl ? ap[j] : 255;\n          }\n        }\n      }\n      if (depth == 4) {\n        for (var y = 0; y < h; y++) {\n          var s0 = y * bpl,\n            t0 = y * w;\n          for (var i = 0; i < w; i++) {\n            var qi = t0 + i << 2,\n              j = data[s0 + (i >> 1)] >> 4 - ((i & 1) << 2) & 15,\n              cj = 3 * j;\n            bf[qi] = p[cj];\n            bf[qi + 1] = p[cj + 1];\n            bf[qi + 2] = p[cj + 2];\n            bf[qi + 3] = j < tl ? ap[j] : 255;\n          }\n        }\n      }\n      if (depth == 8) {\n        for (var i = 0; i < area; i++) {\n          var qi = i << 2,\n            j = data[i],\n            cj = 3 * j;\n          bf[qi] = p[cj];\n          bf[qi + 1] = p[cj + 1];\n          bf[qi + 2] = p[cj + 2];\n          bf[qi + 3] = j < tl ? ap[j] : 255;\n        }\n      }\n    } else if (ctype == 4) {\n      if (depth == 8) {\n        for (var i = 0; i < area; i++) {\n          var qi = i << 2,\n            di = i << 1,\n            gr = data[di];\n          bf[qi] = gr;\n          bf[qi + 1] = gr;\n          bf[qi + 2] = gr;\n          bf[qi + 3] = data[di + 1];\n        }\n      }\n      if (depth == 16) {\n        for (var i = 0; i < area; i++) {\n          var qi = i << 2,\n            di = i << 2,\n            gr = data[di];\n          bf[qi] = gr;\n          bf[qi + 1] = gr;\n          bf[qi + 2] = gr;\n          bf[qi + 3] = data[di + 2];\n        }\n      }\n    } else if (ctype == 0) {\n      var tr = out.tabs[\"tRNS\"] ? out.tabs[\"tRNS\"] : -1;\n      for (var y = 0; y < h; y++) {\n        var off = y * bpl,\n          to = y * w;\n        if (depth == 1) {\n          for (var x = 0; x < w; x++) {\n            var gr = 255 * (data[off + (x >>> 3)] >>> 7 - (x & 7) & 1),\n              al = gr == tr * 255 ? 0 : 255;\n            bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n          }\n        } else if (depth == 2) {\n          for (var x = 0; x < w; x++) {\n            var gr = 85 * (data[off + (x >>> 2)] >>> 6 - ((x & 3) << 1) & 3),\n              al = gr == tr * 85 ? 0 : 255;\n            bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n          }\n        } else if (depth == 4) {\n          for (var x = 0; x < w; x++) {\n            var gr = 17 * (data[off + (x >>> 1)] >>> 4 - ((x & 1) << 2) & 15),\n              al = gr == tr * 17 ? 0 : 255;\n            bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n          }\n        } else if (depth == 8) {\n          for (var x = 0; x < w; x++) {\n            var gr = data[off + x],\n              al = gr == tr ? 0 : 255;\n            bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n          }\n        } else if (depth == 16) {\n          for (var x = 0; x < w; x++) {\n            var gr = data[off + (x << 1)],\n              al = rs(data, off + (x << 1)) == tr ? 0 : 255;\n            bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n          }\n        }\n      }\n    }\n    return bf;\n  };\n  UPNG.decode = function (buff) {\n    var data = new Uint8Array(buff),\n      offset = 8,\n      bin = UPNG._bin,\n      rUs = bin.readUshort,\n      rUi = bin.readUint;\n    var out = {\n      tabs: {},\n      frames: []\n    };\n    var dd = new Uint8Array(data.length),\n      doff = 0;\n    var fd,\n      foff = 0;\n    var text, keyw, bfr;\n    var mgck = [137, 80, 78, 71, 13, 10, 26, 10];\n    for (var i = 0; i < 8; i++) if (data[i] != mgck[i]) throw new Error(\"The input is not a PNG file!\");\n    while (offset < data.length) {\n      var len = bin.readUint(data, offset);\n      offset += 4;\n      var type = bin.readASCII(data, offset, 4);\n      offset += 4;\n      if (type == \"IHDR\") {\n        UPNG.decode._IHDR(data, offset, out);\n      } else if (type == \"CgBI\") {\n        out.tabs[type] = data.slice(offset, offset + 4);\n      } else if (type == \"IDAT\") {\n        for (var i = 0; i < len; i++) dd[doff + i] = data[offset + i];\n        doff += len;\n      } else if (type == \"acTL\") {\n        out.tabs[type] = {\n          num_frames: rUi(data, offset),\n          num_plays: rUi(data, offset + 4)\n        };\n        fd = new Uint8Array(data.length);\n      } else if (type == \"fcTL\") {\n        if (foff != 0) {\n          var fr = out.frames[out.frames.length - 1];\n          fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);\n          foff = 0;\n        }\n        var rct = {\n          x: rUi(data, offset + 12),\n          y: rUi(data, offset + 16),\n          width: rUi(data, offset + 4),\n          height: rUi(data, offset + 8)\n        };\n        var del = rUs(data, offset + 22);\n        del = rUs(data, offset + 20) / (del == 0 ? 100 : del);\n        var frm = {\n          rect: rct,\n          delay: Math.round(del * 1e3),\n          dispose: data[offset + 24],\n          blend: data[offset + 25]\n        };\n        out.frames.push(frm);\n      } else if (type == \"fdAT\") {\n        for (var i = 0; i < len - 4; i++) fd[foff + i] = data[offset + i + 4];\n        foff += len - 4;\n      } else if (type == \"pHYs\") {\n        out.tabs[type] = [bin.readUint(data, offset), bin.readUint(data, offset + 4), data[offset + 8]];\n      } else if (type == \"cHRM\") {\n        out.tabs[type] = [];\n        for (var i = 0; i < 8; i++) out.tabs[type].push(bin.readUint(data, offset + i * 4));\n      } else if (type == \"tEXt\" || type == \"zTXt\") {\n        if (out.tabs[type] == null) out.tabs[type] = {};\n        var nz = bin.nextZero(data, offset);\n        keyw = bin.readASCII(data, offset, nz - offset);\n        var tl = offset + len - nz - 1;\n        if (type == \"tEXt\") {\n          text = bin.readASCII(data, nz + 1, tl);\n        } else {\n          bfr = UPNG.decode._inflate(data.slice(nz + 2, nz + 2 + tl));\n          text = bin.readUTF8(bfr, 0, bfr.length);\n        }\n        out.tabs[type][keyw] = text;\n      } else if (type == \"iTXt\") {\n        if (out.tabs[type] == null) out.tabs[type] = {};\n        var nz = 0,\n          off = offset;\n        nz = bin.nextZero(data, off);\n        keyw = bin.readASCII(data, off, nz - off);\n        off = nz + 1;\n        var cflag = data[off];\n        off += 2;\n        nz = bin.nextZero(data, off);\n        bin.readASCII(data, off, nz - off);\n        off = nz + 1;\n        nz = bin.nextZero(data, off);\n        bin.readUTF8(data, off, nz - off);\n        off = nz + 1;\n        var tl = len - (off - offset);\n        if (cflag == 0) {\n          text = bin.readUTF8(data, off, tl);\n        } else {\n          bfr = UPNG.decode._inflate(data.slice(off, off + tl));\n          text = bin.readUTF8(bfr, 0, bfr.length);\n        }\n        out.tabs[type][keyw] = text;\n      } else if (type == \"PLTE\") {\n        out.tabs[type] = bin.readBytes(data, offset, len);\n      } else if (type == \"hIST\") {\n        var pl = out.tabs[\"PLTE\"].length / 3;\n        out.tabs[type] = [];\n        for (var i = 0; i < pl; i++) out.tabs[type].push(rUs(data, offset + i * 2));\n      } else if (type == \"tRNS\") {\n        if (out.ctype == 3) out.tabs[type] = bin.readBytes(data, offset, len);else if (out.ctype == 0) out.tabs[type] = rUs(data, offset);else if (out.ctype == 2) out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];\n      } else if (type == \"gAMA\") {\n        out.tabs[type] = bin.readUint(data, offset) / 1e5;\n      } else if (type == \"sRGB\") {\n        out.tabs[type] = data[offset];\n      } else if (type == \"bKGD\") {\n        if (out.ctype == 0 || out.ctype == 4) {\n          out.tabs[type] = [rUs(data, offset)];\n        } else if (out.ctype == 2 || out.ctype == 6) {\n          out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];\n        } else if (out.ctype == 3) {\n          out.tabs[type] = data[offset];\n        }\n      } else if (type == \"IEND\") {\n        break;\n      }\n      offset += len;\n      bin.readUint(data, offset);\n      offset += 4;\n    }\n    if (foff != 0) {\n      var fr = out.frames[out.frames.length - 1];\n      fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);\n    }\n    out.data = UPNG.decode._decompress(out, dd, out.width, out.height);\n    delete out.compress;\n    delete out.interlace;\n    delete out.filter;\n    return out;\n  };\n  UPNG.decode._decompress = function (out, dd, w, h) {\n    var bpp = UPNG.decode._getBPP(out),\n      bpl = Math.ceil(w * bpp / 8),\n      buff = new Uint8Array((bpl + 1 + out.interlace) * h);\n    if (out.tabs[\"CgBI\"]) dd = UPNG.inflateRaw(dd, buff);else dd = UPNG.decode._inflate(dd, buff);\n    if (out.interlace == 0) dd = UPNG.decode._filterZero(dd, out, 0, w, h);else if (out.interlace == 1) dd = UPNG.decode._readInterlace(dd, out);\n    return dd;\n  };\n  UPNG.decode._inflate = function (data, buff) {\n    var out = UPNG[\"inflateRaw\"](new Uint8Array(data.buffer, 2, data.length - 6), buff);\n    return out;\n  };\n  UPNG.inflateRaw = function () {\n    var H = {};\n    H.H = {};\n    H.H.N = function (N, W) {\n      var R = Uint8Array,\n        i = 0,\n        m = 0,\n        J = 0,\n        h = 0,\n        Q = 0,\n        X = 0,\n        u = 0,\n        w = 0,\n        d = 0,\n        v,\n        C;\n      if (N[0] == 3 && N[1] == 0) return W ? W : new R(0);\n      var V = H.H,\n        n = V.b,\n        A = V.e,\n        l = V.R,\n        M = V.n,\n        I = V.A,\n        e = V.Z,\n        b = V.m,\n        Z = W == null;\n      if (Z) W = new R(N.length >>> 2 << 5);\n      while (i == 0) {\n        i = n(N, d, 1);\n        m = n(N, d + 1, 2);\n        d += 3;\n        if (m == 0) {\n          if ((d & 7) != 0) d += 8 - (d & 7);\n          var D = (d >>> 3) + 4,\n            q = N[D - 4] | N[D - 3] << 8;\n          if (Z) W = H.H.W(W, w + q);\n          W.set(new R(N.buffer, N.byteOffset + D, q), w);\n          d = D + q << 3;\n          w += q;\n          continue;\n        }\n        if (Z) W = H.H.W(W, w + (1 << 17));\n        if (m == 1) {\n          v = b.J;\n          C = b.h;\n          X = (1 << 9) - 1;\n          u = (1 << 5) - 1;\n        }\n        if (m == 2) {\n          J = A(N, d, 5) + 257;\n          h = A(N, d + 5, 5) + 1;\n          Q = A(N, d + 10, 4) + 4;\n          d += 14;\n          var j = 1;\n          for (var c = 0; c < 38; c += 2) {\n            b.Q[c] = 0;\n            b.Q[c + 1] = 0;\n          }\n          for (var c = 0; c < Q; c++) {\n            var K = A(N, d + c * 3, 3);\n            b.Q[(b.X[c] << 1) + 1] = K;\n            if (K > j) j = K;\n          }\n          d += 3 * Q;\n          M(b.Q, j);\n          I(b.Q, j, b.u);\n          v = b.w;\n          C = b.d;\n          d = l(b.u, (1 << j) - 1, J + h, N, d, b.v);\n          var r = V.V(b.v, 0, J, b.C);\n          X = (1 << r) - 1;\n          var S = V.V(b.v, J, h, b.D);\n          u = (1 << S) - 1;\n          M(b.C, r);\n          I(b.C, r, v);\n          M(b.D, S);\n          I(b.D, S, C);\n        }\n        while (true) {\n          var T = v[e(N, d) & X];\n          d += T & 15;\n          var p = T >>> 4;\n          if (p >>> 8 == 0) {\n            W[w++] = p;\n          } else if (p == 256) {\n            break;\n          } else {\n            var z = w + p - 254;\n            if (p > 264) {\n              var _ = b.q[p - 257];\n              z = w + (_ >>> 3) + A(N, d, _ & 7);\n              d += _ & 7;\n            }\n            var $ = C[e(N, d) & u];\n            d += $ & 15;\n            var s = $ >>> 4,\n              Y = b.c[s],\n              a = (Y >>> 4) + n(N, d, Y & 15);\n            d += Y & 15;\n            while (w < z) {\n              W[w] = W[w++ - a];\n              W[w] = W[w++ - a];\n              W[w] = W[w++ - a];\n              W[w] = W[w++ - a];\n            }\n            w = z;\n          }\n        }\n      }\n      return W.length == w ? W : W.slice(0, w);\n    };\n    H.H.W = function (N, W) {\n      var R = N.length;\n      if (W <= R) return N;\n      var V = new Uint8Array(R << 1);\n      V.set(N, 0);\n      return V;\n    };\n    H.H.R = function (N, W, R, V, n, A) {\n      var l = H.H.e,\n        M = H.H.Z,\n        I = 0;\n      while (I < R) {\n        var e = N[M(V, n) & W];\n        n += e & 15;\n        var b = e >>> 4;\n        if (b <= 15) {\n          A[I] = b;\n          I++;\n        } else {\n          var Z = 0,\n            m = 0;\n          if (b == 16) {\n            m = 3 + l(V, n, 2);\n            n += 2;\n            Z = A[I - 1];\n          } else if (b == 17) {\n            m = 3 + l(V, n, 3);\n            n += 3;\n          } else if (b == 18) {\n            m = 11 + l(V, n, 7);\n            n += 7;\n          }\n          var J = I + m;\n          while (I < J) {\n            A[I] = Z;\n            I++;\n          }\n        }\n      }\n      return n;\n    };\n    H.H.V = function (N, W, R, V) {\n      var n = 0,\n        A = 0,\n        l = V.length >>> 1;\n      while (A < R) {\n        var M = N[A + W];\n        V[A << 1] = 0;\n        V[(A << 1) + 1] = M;\n        if (M > n) n = M;\n        A++;\n      }\n      while (A < l) {\n        V[A << 1] = 0;\n        V[(A << 1) + 1] = 0;\n        A++;\n      }\n      return n;\n    };\n    H.H.n = function (N, W) {\n      var R = H.H.m,\n        V = N.length,\n        n,\n        A,\n        l,\n        M,\n        I,\n        e = R.j;\n      for (var M = 0; M <= W; M++) e[M] = 0;\n      for (M = 1; M < V; M += 2) e[N[M]]++;\n      var b = R.K;\n      n = 0;\n      e[0] = 0;\n      for (A = 1; A <= W; A++) {\n        n = n + e[A - 1] << 1;\n        b[A] = n;\n      }\n      for (l = 0; l < V; l += 2) {\n        I = N[l + 1];\n        if (I != 0) {\n          N[l] = b[I];\n          b[I]++;\n        }\n      }\n    };\n    H.H.A = function (N, W, R) {\n      var V = N.length,\n        n = H.H.m,\n        A = n.r;\n      for (var l = 0; l < V; l += 2) {\n        if (N[l + 1] != 0) {\n          var M = l >> 1,\n            I = N[l + 1],\n            e = M << 4 | I,\n            b = W - I,\n            Z = N[l] << b,\n            m = Z + (1 << b);\n          while (Z != m) {\n            var J = A[Z] >>> 15 - W;\n            R[J] = e;\n            Z++;\n          }\n        }\n      }\n    };\n    H.H.l = function (N, W) {\n      var R = H.H.m.r,\n        V = 15 - W;\n      for (var n = 0; n < N.length; n += 2) {\n        var A = N[n] << W - N[n + 1];\n        N[n] = R[A] >>> V;\n      }\n    };\n    H.H.M = function (N, W, R) {\n      R = R << (W & 7);\n      var V = W >>> 3;\n      N[V] |= R;\n      N[V + 1] |= R >>> 8;\n    };\n    H.H.I = function (N, W, R) {\n      R = R << (W & 7);\n      var V = W >>> 3;\n      N[V] |= R;\n      N[V + 1] |= R >>> 8;\n      N[V + 2] |= R >>> 16;\n    };\n    H.H.e = function (N, W, R) {\n      return (N[W >>> 3] | N[(W >>> 3) + 1] << 8) >>> (W & 7) & (1 << R) - 1;\n    };\n    H.H.b = function (N, W, R) {\n      return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7) & (1 << R) - 1;\n    };\n    H.H.Z = function (N, W) {\n      return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7);\n    };\n    H.H.i = function (N, W) {\n      return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16 | N[(W >>> 3) + 3] << 24) >>> (W & 7);\n    };\n    H.H.m = function () {\n      var N = Uint16Array,\n        W = Uint32Array;\n      return {\n        K: new N(16),\n        j: new N(16),\n        X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n        S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],\n        T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],\n        q: new N(32),\n        p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],\n        z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],\n        c: new W(32),\n        J: new N(512),\n        _: [],\n        h: new N(32),\n        $: [],\n        w: new N(32768),\n        C: [],\n        v: [],\n        d: new N(32768),\n        D: [],\n        u: new N(512),\n        Q: [],\n        r: new N(1 << 15),\n        s: new W(286),\n        Y: new W(30),\n        a: new W(19),\n        t: new W(15e3),\n        k: new N(1 << 16),\n        g: new N(1 << 15)\n      };\n    }();\n    (function () {\n      var N = H.H.m,\n        W = 1 << 15;\n      for (var R = 0; R < W; R++) {\n        var V = R;\n        V = (V & 2863311530) >>> 1 | (V & 1431655765) << 1;\n        V = (V & 3435973836) >>> 2 | (V & 858993459) << 2;\n        V = (V & 4042322160) >>> 4 | (V & 252645135) << 4;\n        V = (V & 4278255360) >>> 8 | (V & 16711935) << 8;\n        N.r[R] = (V >>> 16 | V << 16) >>> 17;\n      }\n      function n(A, l, M) {\n        while (l-- != 0) A.push(0, M);\n      }\n      for (var R = 0; R < 32; R++) {\n        N.q[R] = N.S[R] << 3 | N.T[R];\n        N.c[R] = N.p[R] << 4 | N.z[R];\n      }\n      n(N._, 144, 8);\n      n(N._, 255 - 143, 9);\n      n(N._, 279 - 255, 7);\n      n(N._, 287 - 279, 8);\n      H.H.n(N._, 9);\n      H.H.A(N._, 9, N.J);\n      H.H.l(N._, 9);\n      n(N.$, 32, 5);\n      H.H.n(N.$, 5);\n      H.H.A(N.$, 5, N.h);\n      H.H.l(N.$, 5);\n      n(N.Q, 19, 0);\n      n(N.C, 286, 0);\n      n(N.D, 30, 0);\n      n(N.v, 320, 0);\n    })();\n    return H.H.N;\n  }();\n  UPNG.decode._readInterlace = function (data, out) {\n    var w = out.width,\n      h = out.height;\n    var bpp = UPNG.decode._getBPP(out),\n      cbpp = bpp >> 3,\n      bpl = Math.ceil(w * bpp / 8);\n    var img = new Uint8Array(h * bpl);\n    var di = 0;\n    var starting_row = [0, 0, 4, 0, 2, 0, 1];\n    var starting_col = [0, 4, 0, 2, 0, 1, 0];\n    var row_increment = [8, 8, 8, 4, 4, 2, 2];\n    var col_increment = [8, 8, 4, 4, 2, 2, 1];\n    var pass = 0;\n    while (pass < 7) {\n      var ri = row_increment[pass],\n        ci = col_increment[pass];\n      var sw = 0,\n        sh = 0;\n      var cr = starting_row[pass];\n      while (cr < h) {\n        cr += ri;\n        sh++;\n      }\n      var cc = starting_col[pass];\n      while (cc < w) {\n        cc += ci;\n        sw++;\n      }\n      var bpll = Math.ceil(sw * bpp / 8);\n      UPNG.decode._filterZero(data, out, di, sw, sh);\n      var y = 0,\n        row = starting_row[pass];\n      var val;\n      while (row < h) {\n        var col = starting_col[pass];\n        var cdi = di + y * bpll << 3;\n        while (col < w) {\n          if (bpp == 1) {\n            val = data[cdi >> 3];\n            val = val >> 7 - (cdi & 7) & 1;\n            img[row * bpl + (col >> 3)] |= val << 7 - ((col & 7) << 0);\n          }\n          if (bpp == 2) {\n            val = data[cdi >> 3];\n            val = val >> 6 - (cdi & 7) & 3;\n            img[row * bpl + (col >> 2)] |= val << 6 - ((col & 3) << 1);\n          }\n          if (bpp == 4) {\n            val = data[cdi >> 3];\n            val = val >> 4 - (cdi & 7) & 15;\n            img[row * bpl + (col >> 1)] |= val << 4 - ((col & 1) << 2);\n          }\n          if (bpp >= 8) {\n            var ii = row * bpl + col * cbpp;\n            for (var j = 0; j < cbpp; j++) img[ii + j] = data[(cdi >> 3) + j];\n          }\n          cdi += bpp;\n          col += ci;\n        }\n        y++;\n        row += ri;\n      }\n      if (sw * sh != 0) di += sh * (1 + bpll);\n      pass = pass + 1;\n    }\n    return img;\n  };\n  UPNG.decode._getBPP = function (out) {\n    var noc = [1, null, 3, 1, 2, null, 4][out.ctype];\n    return noc * out.depth;\n  };\n  UPNG.decode._filterZero = function (data, out, off, w, h) {\n    var bpp = UPNG.decode._getBPP(out),\n      bpl = Math.ceil(w * bpp / 8),\n      paeth = UPNG.decode._paeth;\n    bpp = Math.ceil(bpp / 8);\n    var i,\n      di,\n      type = data[off],\n      x = 0;\n    if (type > 1) data[off] = [0, 0, 1][type - 2];\n    if (type == 3) for (x = bpp; x < bpl; x++) data[x + 1] = data[x + 1] + (data[x + 1 - bpp] >>> 1) & 255;\n    for (var y = 0; y < h; y++) {\n      i = off + y * bpl;\n      di = i + y + 1;\n      type = data[di - 1];\n      x = 0;\n      if (type == 0) {\n        for (; x < bpl; x++) data[i + x] = data[di + x];\n      } else if (type == 1) {\n        for (; x < bpp; x++) data[i + x] = data[di + x];\n        for (; x < bpl; x++) data[i + x] = data[di + x] + data[i + x - bpp];\n      } else if (type == 2) {\n        for (; x < bpl; x++) data[i + x] = data[di + x] + data[i + x - bpl];\n      } else if (type == 3) {\n        for (; x < bpp; x++) data[i + x] = data[di + x] + (data[i + x - bpl] >>> 1);\n        for (; x < bpl; x++) data[i + x] = data[di + x] + (data[i + x - bpl] + data[i + x - bpp] >>> 1);\n      } else {\n        for (; x < bpp; x++) data[i + x] = data[di + x] + paeth(0, data[i + x - bpl], 0);\n        for (; x < bpl; x++) {\n          data[i + x] = data[di + x] + paeth(data[i + x - bpp], data[i + x - bpl], data[i + x - bpp - bpl]);\n        }\n      }\n    }\n    return data;\n  };\n  UPNG.decode._paeth = function (a, b, c) {\n    var p = a + b - c,\n      pa = p - a,\n      pb = p - b,\n      pc = p - c;\n    if (pa * pa <= pb * pb && pa * pa <= pc * pc) return a;else if (pb * pb <= pc * pc) return b;\n    return c;\n  };\n  UPNG.decode._IHDR = function (data, offset, out) {\n    var bin = UPNG._bin;\n    out.width = bin.readUint(data, offset);\n    offset += 4;\n    out.height = bin.readUint(data, offset);\n    offset += 4;\n    out.depth = data[offset];\n    offset++;\n    out.ctype = data[offset];\n    offset++;\n    out.compress = data[offset];\n    offset++;\n    out.filter = data[offset];\n    offset++;\n    out.interlace = data[offset];\n    offset++;\n  };\n  UPNG._bin = {\n    nextZero: function (data, p) {\n      while (data[p] != 0) p++;\n      return p;\n    },\n    readUshort: function (buff, p) {\n      return buff[p] << 8 | buff[p + 1];\n    },\n    writeUshort: function (buff, p, n) {\n      buff[p] = n >> 8 & 255;\n      buff[p + 1] = n & 255;\n    },\n    readUint: function (buff, p) {\n      return buff[p] * (256 * 256 * 256) + (buff[p + 1] << 16 | buff[p + 2] << 8 | buff[p + 3]);\n    },\n    writeUint: function (buff, p, n) {\n      buff[p] = n >> 24 & 255;\n      buff[p + 1] = n >> 16 & 255;\n      buff[p + 2] = n >> 8 & 255;\n      buff[p + 3] = n & 255;\n    },\n    readASCII: function (buff, p, l) {\n      var s = \"\";\n      for (var i = 0; i < l; i++) s += String.fromCharCode(buff[p + i]);\n      return s;\n    },\n    writeASCII: function (data, p, s) {\n      for (var i = 0; i < s.length; i++) data[p + i] = s.charCodeAt(i);\n    },\n    readBytes: function (buff, p, l) {\n      var arr = [];\n      for (var i = 0; i < l; i++) arr.push(buff[p + i]);\n      return arr;\n    },\n    pad: function (n) {\n      return n.length < 2 ? \"0\" + n : n;\n    },\n    readUTF8: function (buff, p, l) {\n      var s = \"\",\n        ns;\n      for (var i = 0; i < l; i++) s += \"%\" + UPNG._bin.pad(buff[p + i].toString(16));\n      try {\n        ns = decodeURIComponent(s);\n      } catch (e) {\n        return UPNG._bin.readASCII(buff, p, l);\n      }\n      return ns;\n    }\n  };\n  UPNG._copyTile = function (sb, sw, sh, tb, tw, th, xoff, yoff, mode) {\n    var w = Math.min(sw, tw),\n      h = Math.min(sh, th);\n    var si = 0,\n      ti = 0;\n    for (var y = 0; y < h; y++) {\n      for (var x = 0; x < w; x++) {\n        if (xoff >= 0 && yoff >= 0) {\n          si = y * sw + x << 2;\n          ti = (yoff + y) * tw + xoff + x << 2;\n        } else {\n          si = (-yoff + y) * sw - xoff + x << 2;\n          ti = y * tw + x << 2;\n        }\n        if (mode == 0) {\n          tb[ti] = sb[si];\n          tb[ti + 1] = sb[si + 1];\n          tb[ti + 2] = sb[si + 2];\n          tb[ti + 3] = sb[si + 3];\n        } else if (mode == 1) {\n          var fa = sb[si + 3] * (1 / 255),\n            fr = sb[si] * fa,\n            fg = sb[si + 1] * fa,\n            fb = sb[si + 2] * fa;\n          var ba = tb[ti + 3] * (1 / 255),\n            br = tb[ti] * ba,\n            bg = tb[ti + 1] * ba,\n            bb = tb[ti + 2] * ba;\n          var ifa = 1 - fa,\n            oa = fa + ba * ifa,\n            ioa = oa == 0 ? 0 : 1 / oa;\n          tb[ti + 3] = 255 * oa;\n          tb[ti + 0] = (fr + br * ifa) * ioa;\n          tb[ti + 1] = (fg + bg * ifa) * ioa;\n          tb[ti + 2] = (fb + bb * ifa) * ioa;\n        } else if (mode == 2) {\n          var fa = sb[si + 3],\n            fr = sb[si],\n            fg = sb[si + 1],\n            fb = sb[si + 2];\n          var ba = tb[ti + 3],\n            br = tb[ti],\n            bg = tb[ti + 1],\n            bb = tb[ti + 2];\n          if (fa == ba && fr == br && fg == bg && fb == bb) {\n            tb[ti] = 0;\n            tb[ti + 1] = 0;\n            tb[ti + 2] = 0;\n            tb[ti + 3] = 0;\n          } else {\n            tb[ti] = fr;\n            tb[ti + 1] = fg;\n            tb[ti + 2] = fb;\n            tb[ti + 3] = fa;\n          }\n        } else if (mode == 3) {\n          var fa = sb[si + 3],\n            fr = sb[si],\n            fg = sb[si + 1],\n            fb = sb[si + 2];\n          var ba = tb[ti + 3],\n            br = tb[ti],\n            bg = tb[ti + 1],\n            bb = tb[ti + 2];\n          if (fa == ba && fr == br && fg == bg && fb == bb) continue;\n          if (fa < 220 && ba > 20) return false;\n        }\n      }\n    }\n    return true;\n  };\n}\nclass RGBMLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = HalfFloatType;\n    this.maxRange = 7;\n  }\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n  setMaxRange(value) {\n    this.maxRange = value;\n    return this;\n  }\n  loadCubemap(urls, onLoad, onProgress, onError) {\n    const texture = new CubeTexture();\n    let loaded = 0;\n    const scope = this;\n    function loadTexture(i) {\n      scope.load(urls[i], function (image) {\n        texture.images[i] = image;\n        loaded++;\n        if (loaded === 6) {\n          texture.needsUpdate = true;\n          if (onLoad) onLoad(texture);\n        }\n      }, void 0, onError);\n    }\n    for (let i = 0; i < urls.length; ++i) {\n      loadTexture(i);\n    }\n    texture.type = this.type;\n    texture.format = RGBAFormat;\n    texture.minFilter = LinearFilter;\n    texture.generateMipmaps = false;\n    return texture;\n  }\n  parse(buffer) {\n    init();\n    const img = UPNG.decode(buffer);\n    const rgba = UPNG.toRGBA8(img)[0];\n    const data = new Uint8Array(rgba);\n    const size = img.width * img.height * 4;\n    const output = this.type === HalfFloatType ? new Uint16Array(size) : new Float32Array(size);\n    for (let i = 0; i < data.length; i += 4) {\n      const r = data[i + 0] / 255;\n      const g = data[i + 1] / 255;\n      const b = data[i + 2] / 255;\n      const a = data[i + 3] / 255;\n      if (this.type === HalfFloatType) {\n        output[i + 0] = DataUtils.toHalfFloat(Math.min(r * a * this.maxRange, 65504));\n        output[i + 1] = DataUtils.toHalfFloat(Math.min(g * a * this.maxRange, 65504));\n        output[i + 2] = DataUtils.toHalfFloat(Math.min(b * a * this.maxRange, 65504));\n        output[i + 3] = DataUtils.toHalfFloat(1);\n      } else {\n        output[i + 0] = r * a * this.maxRange;\n        output[i + 1] = g * a * this.maxRange;\n        output[i + 2] = b * a * this.maxRange;\n        output[i + 3] = 1;\n      }\n    }\n    return {\n      width: img.width,\n      height: img.height,\n      data: output,\n      format: RGBAFormat,\n      type: this.type,\n      flipY: true\n    };\n  }\n}\nexport { RGBMLoader };\n//# sourceMappingURL=RGBMLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}