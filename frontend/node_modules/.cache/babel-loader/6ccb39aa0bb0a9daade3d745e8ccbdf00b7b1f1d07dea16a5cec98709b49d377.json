{"ast":null,"code":"import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */new Box3();\nconst triangle = /* @__PURE__ */new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */new Matrix4();\nconst obb = /* @__PURE__ */new OrientedBox();\nconst obb2 = /* @__PURE__ */new OrientedBox();\nfunction intersectsGeometry(bvh, root, otherGeometry, geometryToBvh) {\n  BufferStack.setBuffer(bvh._roots[root]);\n  const result = _intersectsGeometry(0, bvh, otherGeometry, geometryToBvh);\n  BufferStack.clearBuffer();\n  return result;\n}\nfunction _intersectsGeometry(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {\n  const {\n    float32Array,\n    uint16Array,\n    uint32Array\n  } = BufferStack;\n  let nodeIndex16 = nodeIndex32 * 2;\n  if (cachedObb === null) {\n    if (!otherGeometry.boundingBox) {\n      otherGeometry.computeBoundingBox();\n    }\n    obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n    cachedObb = obb;\n  }\n  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n  if (isLeaf) {\n    const thisGeometry = bvh.geometry;\n    const thisIndex = thisGeometry.index;\n    const thisPos = thisGeometry.attributes.position;\n    const index = otherGeometry.index;\n    const pos = otherGeometry.attributes.position;\n    const offset = OFFSET(nodeIndex32, uint32Array);\n    const count = COUNT(nodeIndex16, uint16Array);\n\n    // get the inverse of the geometry matrix so we can transform our triangles into the\n    // geometry space we're trying to test. We assume there are fewer triangles being checked\n    // here.\n    invertedMat.copy(geometryToBvh).invert();\n    if (otherGeometry.boundsTree) {\n      // if there's a bounds tree\n      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, obb2);\n      obb2.matrix.copy(invertedMat);\n      obb2.needsUpdate = true;\n\n      // TODO: use a triangle iteration function here\n      const res = otherGeometry.boundsTree.shapecast({\n        intersectsBounds: box => obb2.intersectsBox(box),\n        intersectsTriangle: tri => {\n          tri.a.applyMatrix4(geometryToBvh);\n          tri.b.applyMatrix4(geometryToBvh);\n          tri.c.applyMatrix4(geometryToBvh);\n          tri.needsUpdate = true;\n          for (let i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {\n            // this triangle needs to be transformed into the current BVH coordinate frame\n            setTriangle(triangle2, i, thisIndex, thisPos);\n            triangle2.needsUpdate = true;\n            if (tri.intersectsTriangle(triangle2)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      });\n      return res;\n    } else {\n      // if we're just dealing with raw geometry\n\n      for (let i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {\n        // this triangle needs to be transformed into the current BVH coordinate frame\n        setTriangle(triangle, i, thisIndex, thisPos);\n        triangle.a.applyMatrix4(invertedMat);\n        triangle.b.applyMatrix4(invertedMat);\n        triangle.c.applyMatrix4(invertedMat);\n        triangle.needsUpdate = true;\n        for (let i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {\n          setTriangle(triangle2, i2, index, pos);\n          triangle2.needsUpdate = true;\n          if (triangle.intersectsTriangle(triangle2)) {\n            return true;\n          }\n        }\n      }\n    }\n  } else {\n    const left = nodeIndex32 + 8;\n    const right = uint32Array[nodeIndex32 + 6];\n    arrayToBox(BOUNDING_DATA_INDEX(left), float32Array, boundingBox);\n    const leftIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(left, bvh, otherGeometry, geometryToBvh, cachedObb);\n    if (leftIntersection) return true;\n    arrayToBox(BOUNDING_DATA_INDEX(right), float32Array, boundingBox);\n    const rightIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(right, bvh, otherGeometry, geometryToBvh, cachedObb);\n    if (rightIntersection) return true;\n    return false;\n  }\n}\nexport { intersectsGeometry };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}