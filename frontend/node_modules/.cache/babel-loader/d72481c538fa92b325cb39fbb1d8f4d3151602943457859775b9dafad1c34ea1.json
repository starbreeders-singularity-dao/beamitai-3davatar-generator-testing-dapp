{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b;\nconst $retainerCount = Symbol('retainerCount');\nconst $recentlyUsed = Symbol('recentlyUsed');\nconst $evict = Symbol('evict');\nconst $evictionThreshold = Symbol('evictionThreshold');\nconst $cache = Symbol('cache');\n/**\n * The CacheEvictionPolicy manages the lifecycle for items in a cache,\n * evicting any items outside some threshold bounds in \"recently used\" order,\n * if they are evictable.\n *\n * Items are considered cached as they are retained. When all retainers\n * of an item release it, that item is considered evictable.\n */\nexport class CacheEvictionPolicy {\n  constructor(cache, evictionThreshold = 5) {\n    this[_a] = new Map();\n    this[_b] = [];\n    this[$cache] = cache;\n    this[$evictionThreshold] = evictionThreshold;\n  }\n  /**\n   * The eviction threshold is the maximum number of items to hold\n   * in cache indefinitely. Items within the threshold (in recently\n   * used order) will continue to be cached even if they have zero\n   * retainers.\n   */\n  set evictionThreshold(value) {\n    this[$evictionThreshold] = value;\n    this[$evict]();\n  }\n  get evictionThreshold() {\n    return this[$evictionThreshold];\n  }\n  /**\n   * A reference to the cache that operates under this policy\n   */\n  get cache() {\n    return this[$cache];\n  }\n  /**\n   * Given an item key, returns the number of retainers of that item\n   */\n  retainerCount(key) {\n    return this[$retainerCount].get(key) || 0;\n  }\n  /**\n   * Resets the internal tracking of cache item retainers. Use only in cases\n   * where it is certain that all retained cache items have been accounted for!\n   */\n  reset() {\n    this[$retainerCount].clear();\n    this[$recentlyUsed] = [];\n  }\n  /**\n   * Mark a given cache item as retained, where the item is represented\n   * by its key. An item can have any number of retainers.\n   */\n  retain(key) {\n    if (!this[$retainerCount].has(key)) {\n      this[$retainerCount].set(key, 0);\n    }\n    this[$retainerCount].set(key, this[$retainerCount].get(key) + 1);\n    const recentlyUsedIndex = this[$recentlyUsed].indexOf(key);\n    if (recentlyUsedIndex !== -1) {\n      this[$recentlyUsed].splice(recentlyUsedIndex, 1);\n    }\n    this[$recentlyUsed].unshift(key);\n    // Evict, in case retaining a new item pushed an evictable item beyond the\n    // eviction threshold\n    this[$evict]();\n  }\n  /**\n   * Mark a given cache item as released by one of its retainers, where the item\n   * is represented by its key. When all retainers of an item have released it,\n   * the item is considered evictable.\n   */\n  release(key) {\n    if (this[$retainerCount].has(key)) {\n      this[$retainerCount].set(key, Math.max(this[$retainerCount].get(key) - 1, 0));\n    }\n    this[$evict]();\n  }\n  [(_a = $retainerCount, _b = $recentlyUsed, $evict)]() {\n    if (this[$recentlyUsed].length < this[$evictionThreshold]) {\n      return;\n    }\n    for (let i = this[$recentlyUsed].length - 1; i >= this[$evictionThreshold]; --i) {\n      const key = this[$recentlyUsed][i];\n      const retainerCount = this[$retainerCount].get(key);\n      if (retainerCount === 0) {\n        this[$cache].delete(key);\n        this[$recentlyUsed].splice(i, 1);\n      }\n    }\n  }\n}\n//# sourceMappingURL=cache-eviction-policy.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}