{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { ConnectionError, ConnectionNotOpenError, InvalidClientError, MaxAttemptsReachedOnReconnectingError, PendingRequestsOnReconnectingError, RequestAlreadySentError, Web3WSProviderError } from 'web3-errors';\nimport { Eip1193Provider } from './web3_eip1193_provider.js';\nimport { ChunkResponseParser } from './chunk_response_parser.js';\nimport { isNullish } from './validation.js';\nimport { Web3DeferredPromise } from './web3_deferred_promise.js';\nimport * as jsonRpc from './json_rpc.js';\nconst DEFAULT_RECONNECTION_OPTIONS = {\n  autoReconnect: true,\n  delay: 5000,\n  maxAttempts: 5\n};\nconst NORMAL_CLOSE_CODE = 1000; // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close\nexport class SocketProvider extends Eip1193Provider {\n  get SocketConnection() {\n    return this._socketConnection;\n  }\n  /**\n   * This is an abstract class for implementing a socket provider (e.g. WebSocket, IPC). It extends the EIP-1193 provider {@link EIP1193Provider}.\n   * @param socketPath - The path to the socket (e.g. /ipc/path or ws://localhost:8546)\n   * @param socketOptions - The options for the socket connection. Its type is supposed to be specified in the inherited classes.\n   * @param reconnectOptions - The options for the socket reconnection {@link ReconnectOptions}\n   */\n  constructor(socketPath, socketOptions, reconnectOptions) {\n    super();\n    this._connectionStatus = 'connecting';\n    // Message handlers. Due to bounding of `this` and removing the listeners we have to keep it's reference.\n    this._onMessageHandler = this._onMessage.bind(this);\n    this._onOpenHandler = this._onConnect.bind(this);\n    this._onCloseHandler = this._onCloseEvent.bind(this);\n    this._onErrorHandler = this._onError.bind(this);\n    if (!this._validateProviderPath(socketPath)) throw new InvalidClientError(socketPath);\n    this._socketPath = socketPath;\n    this._socketOptions = socketOptions;\n    this._reconnectOptions = Object.assign(Object.assign({}, DEFAULT_RECONNECTION_OPTIONS), reconnectOptions !== null && reconnectOptions !== void 0 ? reconnectOptions : {});\n    this._pendingRequestsQueue = new Map();\n    this._sentRequestsQueue = new Map();\n    this._init();\n    this.connect();\n    this.chunkResponseParser = new ChunkResponseParser(this._eventEmitter, this._reconnectOptions.autoReconnect);\n    this.chunkResponseParser.onError(() => {\n      this._clearQueues();\n    });\n    this.isReconnecting = false;\n  }\n  _init() {\n    this._reconnectAttempts = 0;\n  }\n  /**\n   * Try to establish a connection to the socket\n   */\n  connect() {\n    try {\n      this._openSocketConnection();\n      this._connectionStatus = 'connecting';\n      this._addSocketListeners();\n    } catch (e) {\n      if (!this.isReconnecting) {\n        this._connectionStatus = 'disconnected';\n        if (e && e.message) {\n          throw new ConnectionError(`Error while connecting to ${this._socketPath}. Reason: ${e.message}`);\n        } else {\n          throw new InvalidClientError(this._socketPath);\n        }\n      } else {\n        setImmediate(() => {\n          this._reconnect();\n        });\n      }\n    }\n  }\n  // eslint-disable-next-line class-methods-use-this\n  _validateProviderPath(path) {\n    return !!path;\n  }\n  /**\n   *\n   * @returns the pendingRequestQueue size\n   */\n  // eslint-disable-next-line class-methods-use-this\n  getPendingRequestQueueSize() {\n    return this._pendingRequestsQueue.size;\n  }\n  /**\n   *\n   * @returns the sendPendingRequests size\n   */\n  // eslint-disable-next-line class-methods-use-this\n  getSentRequestsQueueSize() {\n    return this._sentRequestsQueue.size;\n  }\n  /**\n   *\n   * @returns `true` if the socket supports subscriptions\n   */\n  // eslint-disable-next-line class-methods-use-this\n  supportsSubscriptions() {\n    return true;\n  }\n  on(type, listener) {\n    this._eventEmitter.on(type, listener);\n  }\n  once(type, listener) {\n    this._eventEmitter.once(type, listener);\n  }\n  removeListener(type, listener) {\n    this._eventEmitter.removeListener(type, listener);\n  }\n  _onDisconnect(code, data) {\n    this._connectionStatus = 'disconnected';\n    super._onDisconnect(code, data);\n  }\n  /**\n   * Disconnects the socket\n   * @param code - The code to be sent to the server\n   * @param data - The data to be sent to the server\n   */\n  disconnect(code, data) {\n    const disconnectCode = code !== null && code !== void 0 ? code : NORMAL_CLOSE_CODE;\n    this._removeSocketListeners();\n    if (this.getStatus() !== 'disconnected') {\n      this._closeSocketConnection(disconnectCode, data);\n    }\n    this._onDisconnect(disconnectCode, data);\n  }\n  /**\n   * Safely disconnects the socket, async and waits for request size to be 0 before disconnecting\n   * @param forceDisconnect - If true, will clear queue after 5 attempts of waiting for both pending and sent queue to be 0\n   * @param ms - Determines the ms of setInterval\n   * @param code - The code to be sent to the server\n   * @param data - The data to be sent to the server\n   */\n  safeDisconnect(code_1, data_1) {\n    return __awaiter(this, arguments, void 0, function* (code, data, forceDisconnect = false, ms = 1000) {\n      let retryAttempt = 0;\n      const checkQueue = () => __awaiter(this, void 0, void 0, function* () {\n        return new Promise(resolve => {\n          const interval = setInterval(() => {\n            if (forceDisconnect && retryAttempt >= 5) {\n              this.clearQueues();\n            }\n            if (this.getPendingRequestQueueSize() === 0 && this.getSentRequestsQueueSize() === 0) {\n              clearInterval(interval);\n              resolve(true);\n            }\n            retryAttempt += 1;\n          }, ms);\n        });\n      });\n      yield checkQueue();\n      this.disconnect(code, data);\n    });\n  }\n  /**\n   * Removes all listeners for the specified event type.\n   * @param type - The event type to remove the listeners for\n   */\n  removeAllListeners(type) {\n    this._eventEmitter.removeAllListeners(type);\n  }\n  _onError(event) {\n    // do not emit error while trying to reconnect\n    if (this.isReconnecting) {\n      this._reconnect();\n    } else {\n      this._eventEmitter.emit('error', event);\n    }\n  }\n  /**\n   * Resets the socket, removing all listeners and pending requests\n   */\n  reset() {\n    this._sentRequestsQueue.clear();\n    this._pendingRequestsQueue.clear();\n    this._init();\n    this._removeSocketListeners();\n    this._addSocketListeners();\n  }\n  _reconnect() {\n    if (this.isReconnecting) {\n      return;\n    }\n    this.isReconnecting = true;\n    if (this._sentRequestsQueue.size > 0) {\n      this._sentRequestsQueue.forEach((request, key) => {\n        request.deferredPromise.reject(new PendingRequestsOnReconnectingError());\n        this._sentRequestsQueue.delete(key);\n      });\n    }\n    if (this._reconnectAttempts < this._reconnectOptions.maxAttempts) {\n      this._reconnectAttempts += 1;\n      setTimeout(() => {\n        this._removeSocketListeners();\n        this.connect(); // this can error out\n        this.isReconnecting = false;\n      }, this._reconnectOptions.delay);\n    } else {\n      this.isReconnecting = false;\n      this._clearQueues();\n      this._removeSocketListeners();\n      this._eventEmitter.emit('error', new MaxAttemptsReachedOnReconnectingError(this._reconnectOptions.maxAttempts));\n    }\n  }\n  /**\n   *  Creates a request object to be sent to the server\n   */\n  request(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (isNullish(this._socketConnection)) {\n        throw new Error('Connection is undefined');\n      }\n      // if socket disconnected - open connection\n      if (this.getStatus() === 'disconnected') {\n        this.connect();\n      }\n      const requestId = jsonRpc.isBatchRequest(request) ? request[0].id : request.id;\n      if (!requestId) {\n        throw new Web3WSProviderError('Request Id not defined');\n      }\n      if (this._sentRequestsQueue.has(requestId)) {\n        throw new RequestAlreadySentError(requestId);\n      }\n      const deferredPromise = new Web3DeferredPromise();\n      deferredPromise.catch(error => {\n        this._eventEmitter.emit('error', error);\n      });\n      const reqItem = {\n        payload: request,\n        deferredPromise\n      };\n      if (this.getStatus() === 'connecting') {\n        this._pendingRequestsQueue.set(requestId, reqItem);\n        return reqItem.deferredPromise;\n      }\n      this._sentRequestsQueue.set(requestId, reqItem);\n      try {\n        this._sendToSocket(reqItem.payload);\n      } catch (error) {\n        this._sentRequestsQueue.delete(requestId);\n        this._eventEmitter.emit('error', error);\n      }\n      return deferredPromise;\n    });\n  }\n  _onConnect() {\n    this._connectionStatus = 'connected';\n    this._reconnectAttempts = 0;\n    super._onConnect();\n    this._sendPendingRequests();\n  }\n  _sendPendingRequests() {\n    for (const [id, value] of this._pendingRequestsQueue.entries()) {\n      try {\n        this._sendToSocket(value.payload);\n        this._pendingRequestsQueue.delete(id);\n        this._sentRequestsQueue.set(id, value);\n      } catch (error) {\n        // catches if sendTosocket fails\n        this._pendingRequestsQueue.delete(id);\n        this._eventEmitter.emit('error', error);\n      }\n    }\n  }\n  _onMessage(event) {\n    const responses = this._parseResponses(event);\n    if (isNullish(responses) || responses.length === 0) {\n      return;\n    }\n    for (const response of responses) {\n      if (jsonRpc.isResponseWithNotification(response) && response.method.endsWith('_subscription')) {\n        this._eventEmitter.emit('message', response);\n        return;\n      }\n      const requestId = jsonRpc.isBatchResponse(response) ? response[0].id : response.id;\n      const requestItem = this._sentRequestsQueue.get(requestId);\n      if (!requestItem) {\n        return;\n      }\n      if (jsonRpc.isBatchResponse(response) || jsonRpc.isResponseWithResult(response) || jsonRpc.isResponseWithError(response)) {\n        this._eventEmitter.emit('message', response);\n        requestItem.deferredPromise.resolve(response);\n      }\n      this._sentRequestsQueue.delete(requestId);\n    }\n  }\n  clearQueues(event) {\n    this._clearQueues(event);\n  }\n  _clearQueues(event) {\n    if (this._pendingRequestsQueue.size > 0) {\n      this._pendingRequestsQueue.forEach((request, key) => {\n        request.deferredPromise.reject(new ConnectionNotOpenError(event));\n        this._pendingRequestsQueue.delete(key);\n      });\n    }\n    if (this._sentRequestsQueue.size > 0) {\n      this._sentRequestsQueue.forEach((request, key) => {\n        request.deferredPromise.reject(new ConnectionNotOpenError(event));\n        this._sentRequestsQueue.delete(key);\n      });\n    }\n    this._removeSocketListeners();\n  }\n}\n//# sourceMappingURL=socket_provider.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}