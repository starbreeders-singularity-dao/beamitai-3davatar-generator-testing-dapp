{"ast":null,"code":"import { Ray, Matrix4, Mesh, Vector3, Sphere, REVISION } from 'three';\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\nimport * as THREE from 'three';\nconst BatchedMesh = THREE.BatchedMesh || null; // this is necessary to not break three.js r157-\nconst IS_REVISION_166 = parseInt(REVISION) >= 166;\nconst ray = /* @__PURE__ */new Ray();\nconst direction = /* @__PURE__ */new Vector3();\nconst tmpInverseMatrix = /* @__PURE__ */new Matrix4();\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\nconst origBatchedRaycastFunc = BatchedMesh !== null ? BatchedMesh.prototype.raycast : null;\nconst _worldScale = /* @__PURE__ */new Vector3();\nconst _mesh = /* @__PURE__ */new Mesh();\nconst _batchIntersects = [];\nexport function acceleratedRaycast(raycaster, intersects) {\n  if (this.isBatchedMesh) {\n    acceleratedBatchedMeshRaycast.call(this, raycaster, intersects);\n  } else {\n    acceleratedMeshRaycast.call(this, raycaster, intersects);\n  }\n}\nfunction acceleratedBatchedMeshRaycast(raycaster, intersects) {\n  if (this.boundsTrees) {\n    const boundsTrees = this.boundsTrees;\n    const drawInfo = this._drawInfo;\n    const drawRanges = this._drawRanges;\n    const matrixWorld = this.matrixWorld;\n    _mesh.material = this.material;\n    _mesh.geometry = this.geometry;\n    const oldBoundsTree = _mesh.geometry.boundsTree;\n    const oldDrawRange = _mesh.geometry.drawRange;\n    if (_mesh.geometry.boundingSphere === null) {\n      _mesh.geometry.boundingSphere = new Sphere();\n    }\n\n    // TODO: provide new method to get instances count instead of 'drawInfo.length'\n    for (let i = 0, l = drawInfo.length; i < l; i++) {\n      if (!this.getVisibleAt(i)) {\n        continue;\n      }\n\n      // TODO: use getGeometryIndex\n      const geometryId = drawInfo[i].geometryIndex;\n      _mesh.geometry.boundsTree = boundsTrees[geometryId];\n      this.getMatrixAt(i, _mesh.matrixWorld).premultiply(matrixWorld);\n      if (!_mesh.geometry.boundsTree) {\n        this.getBoundingBoxAt(geometryId, _mesh.geometry.boundingBox);\n        this.getBoundingSphereAt(geometryId, _mesh.geometry.boundingSphere);\n        const drawRange = drawRanges[geometryId];\n        _mesh.geometry.setDrawRange(drawRange.start, drawRange.count);\n      }\n      _mesh.raycast(raycaster, _batchIntersects);\n      for (let j = 0, l = _batchIntersects.length; j < l; j++) {\n        const intersect = _batchIntersects[j];\n        intersect.object = this;\n        intersect.batchId = i;\n        intersects.push(intersect);\n      }\n      _batchIntersects.length = 0;\n    }\n    _mesh.geometry.boundsTree = oldBoundsTree;\n    _mesh.geometry.drawRange = oldDrawRange;\n    _mesh.material = null;\n    _mesh.geometry = null;\n  } else {\n    origBatchedRaycastFunc.call(this, raycaster, intersects);\n  }\n}\nfunction acceleratedMeshRaycast(raycaster, intersects) {\n  if (this.geometry.boundsTree) {\n    if (this.material === undefined) return;\n    tmpInverseMatrix.copy(this.matrixWorld).invert();\n    ray.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);\n    _worldScale.setFromMatrixScale(this.matrixWorld);\n    direction.copy(ray.direction).multiply(_worldScale);\n    const scaleFactor = direction.length();\n    const near = raycaster.near / scaleFactor;\n    const far = raycaster.far / scaleFactor;\n    const bvh = this.geometry.boundsTree;\n    if (raycaster.firstHitOnly === true) {\n      const hit = convertRaycastIntersect(bvh.raycastFirst(ray, this.material, near, far), this, raycaster);\n      if (hit) {\n        intersects.push(hit);\n      }\n    } else {\n      const hits = bvh.raycast(ray, this.material, near, far);\n      for (let i = 0, l = hits.length; i < l; i++) {\n        const hit = convertRaycastIntersect(hits[i], this, raycaster);\n        if (hit) {\n          intersects.push(hit);\n        }\n      }\n    }\n  } else {\n    origMeshRaycastFunc.call(this, raycaster, intersects);\n  }\n}\nexport function computeBoundsTree(options = {}) {\n  this.boundsTree = new MeshBVH(this, options);\n  return this.boundsTree;\n}\nexport function disposeBoundsTree() {\n  this.boundsTree = null;\n}\nexport function computeBatchedBoundsTree(index = -1, options = {}) {\n  if (!IS_REVISION_166) {\n    throw new Error('BatchedMesh: Three r166+ is required to compute bounds trees.');\n  }\n  if (options.indirect) {\n    console.warn('\"Indirect\" is set to false because it is not supported for BatchedMesh.');\n  }\n  options = {\n    ...options,\n    indirect: false,\n    range: null\n  };\n  const drawRanges = this._drawRanges;\n  const geometryCount = this._geometryCount;\n  if (!this.boundsTrees) {\n    this.boundsTrees = new Array(geometryCount).fill(null);\n  }\n  const boundsTrees = this.boundsTrees;\n  while (boundsTrees.length < geometryCount) {\n    boundsTrees.push(null);\n  }\n  if (index < 0) {\n    for (let i = 0; i < geometryCount; i++) {\n      options.range = drawRanges[i];\n      boundsTrees[i] = new MeshBVH(this.geometry, options);\n    }\n    return boundsTrees;\n  } else {\n    if (index < drawRanges.length) {\n      options.range = drawRanges[index];\n      boundsTrees[index] = new MeshBVH(this.geometry, options);\n    }\n    return boundsTrees[index] || null;\n  }\n}\nexport function disposeBatchedBoundsTree(index = -1) {\n  if (index < 0) {\n    this.boundsTrees.fill(null);\n  } else {\n    if (index < this.boundsTree.length) {\n      this.boundsTrees[index] = null;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}