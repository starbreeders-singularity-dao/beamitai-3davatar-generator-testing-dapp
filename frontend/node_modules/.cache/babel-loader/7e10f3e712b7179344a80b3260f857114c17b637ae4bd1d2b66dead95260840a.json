{"ast":null,"code":"import { Vector3, Vector2, Triangle, DoubleSide, BackSide } from 'three';\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst _vA = /* @__PURE__ */new Vector3();\nconst _vB = /* @__PURE__ */new Vector3();\nconst _vC = /* @__PURE__ */new Vector3();\nconst _uvA = /* @__PURE__ */new Vector2();\nconst _uvB = /* @__PURE__ */new Vector2();\nconst _uvC = /* @__PURE__ */new Vector2();\nconst _normalA = /* @__PURE__ */new Vector3();\nconst _normalB = /* @__PURE__ */new Vector3();\nconst _normalC = /* @__PURE__ */new Vector3();\nconst _intersectionPoint = /* @__PURE__ */new Vector3();\nfunction checkIntersection(ray, pA, pB, pC, point, side, near, far) {\n  let intersect;\n  if (side === BackSide) {\n    intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n  } else {\n    intersect = ray.intersectTriangle(pA, pB, pC, side !== DoubleSide, point);\n  }\n  if (intersect === null) return null;\n  const distance = ray.origin.distanceTo(point);\n  if (distance < near || distance > far) return null;\n  return {\n    distance: distance,\n    point: point.clone()\n  };\n}\nfunction checkBufferGeometryIntersection(ray, position, normal, uv, uv1, a, b, c, side, near, far) {\n  _vA.fromBufferAttribute(position, a);\n  _vB.fromBufferAttribute(position, b);\n  _vC.fromBufferAttribute(position, c);\n  const intersection = checkIntersection(ray, _vA, _vB, _vC, _intersectionPoint, side, near, far);\n  if (intersection) {\n    if (uv) {\n      _uvA.fromBufferAttribute(uv, a);\n      _uvB.fromBufferAttribute(uv, b);\n      _uvC.fromBufferAttribute(uv, c);\n      intersection.uv = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());\n    }\n    if (uv1) {\n      _uvA.fromBufferAttribute(uv1, a);\n      _uvB.fromBufferAttribute(uv1, b);\n      _uvC.fromBufferAttribute(uv1, c);\n      intersection.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());\n    }\n    if (normal) {\n      _normalA.fromBufferAttribute(normal, a);\n      _normalB.fromBufferAttribute(normal, b);\n      _normalC.fromBufferAttribute(normal, c);\n      intersection.normal = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3());\n      if (intersection.normal.dot(ray.direction) > 0) {\n        intersection.normal.multiplyScalar(-1);\n      }\n    }\n    const face = {\n      a: a,\n      b: b,\n      c: c,\n      normal: new Vector3(),\n      materialIndex: 0\n    };\n    Triangle.getNormal(_vA, _vB, _vC, face.normal);\n    intersection.face = face;\n    intersection.faceIndex = a;\n  }\n  return intersection;\n}\n\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction intersectTri(geo, side, ray, tri, intersections, near, far) {\n  const triOffset = tri * 3;\n  let a = triOffset + 0;\n  let b = triOffset + 1;\n  let c = triOffset + 2;\n  const index = geo.index;\n  if (geo.index) {\n    a = index.getX(a);\n    b = index.getX(b);\n    c = index.getX(c);\n  }\n  const {\n    position,\n    normal,\n    uv,\n    uv1\n  } = geo.attributes;\n  const intersection = checkBufferGeometryIntersection(ray, position, normal, uv, uv1, a, b, c, side, near, far);\n  if (intersection) {\n    intersection.faceIndex = tri;\n    if (intersections) intersections.push(intersection);\n    return intersection;\n  }\n  return null;\n}\nexport { intersectTri };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}