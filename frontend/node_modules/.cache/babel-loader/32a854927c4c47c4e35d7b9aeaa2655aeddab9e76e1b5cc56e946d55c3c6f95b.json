{"ast":null,"code":"import { BufferAttribute, BufferGeometry, Color, Group, Matrix4, Mesh, Vector3 } from 'three';\nimport { mergeGroups, deepCloneAttribute } from './BufferGeometryUtils.js';\nconst _color = /*@__PURE__*/new Color();\nconst _matrix = /*@__PURE__*/new Matrix4();\nfunction createMeshesFromInstancedMesh(instancedMesh) {\n  const group = new Group();\n  const count = instancedMesh.count;\n  const geometry = instancedMesh.geometry;\n  const material = instancedMesh.material;\n  for (let i = 0; i < count; i++) {\n    const mesh = new Mesh(geometry, material);\n    instancedMesh.getMatrixAt(i, mesh.matrix);\n    mesh.matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);\n    group.add(mesh);\n  }\n  group.copy(instancedMesh);\n  group.updateMatrixWorld(); // ensure correct world matrices of meshes\n\n  return group;\n}\nfunction createMeshesFromMultiMaterialMesh(mesh) {\n  if (Array.isArray(mesh.material) === false) {\n    console.warn('THREE.SceneUtils.createMeshesFromMultiMaterialMesh(): The given mesh has no multiple materials.');\n    return mesh;\n  }\n  const object = new Group();\n  object.copy(mesh);\n\n  // merge groups (which automatically sorts them)\n\n  const geometry = mergeGroups(mesh.geometry);\n  const index = geometry.index;\n  const groups = geometry.groups;\n  const attributeNames = Object.keys(geometry.attributes);\n\n  // create a mesh for each group by extracting the buffer data into a new geometry\n\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    const start = group.start;\n    const end = start + group.count;\n    const newGeometry = new BufferGeometry();\n    const newMaterial = mesh.material[group.materialIndex];\n\n    // process all buffer attributes\n\n    for (let j = 0; j < attributeNames.length; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.attributes[name];\n      const itemSize = attribute.itemSize;\n      const newLength = group.count * itemSize;\n      const type = attribute.array.constructor;\n      const newArray = new type(newLength);\n      const newAttribute = new BufferAttribute(newArray, itemSize);\n      for (let k = start, n = 0; k < end; k++, n++) {\n        const ind = index.getX(k);\n        if (itemSize >= 1) newAttribute.setX(n, attribute.getX(ind));\n        if (itemSize >= 2) newAttribute.setY(n, attribute.getY(ind));\n        if (itemSize >= 3) newAttribute.setZ(n, attribute.getZ(ind));\n        if (itemSize >= 4) newAttribute.setW(n, attribute.getW(ind));\n      }\n      newGeometry.setAttribute(name, newAttribute);\n    }\n    const newMesh = new Mesh(newGeometry, newMaterial);\n    object.add(newMesh);\n  }\n  return object;\n}\nfunction createMultiMaterialObject(geometry, materials) {\n  const group = new Group();\n  for (let i = 0, l = materials.length; i < l; i++) {\n    group.add(new Mesh(geometry, materials[i]));\n  }\n  return group;\n}\nfunction reduceVertices(object, func, initialValue) {\n  let value = initialValue;\n  const vertex = new Vector3();\n  object.updateWorldMatrix(true, true);\n  object.traverseVisible(child => {\n    const {\n      geometry\n    } = child;\n    if (geometry !== undefined) {\n      const {\n        position\n      } = geometry.attributes;\n      if (position !== undefined) {\n        for (let i = 0, l = position.count; i < l; i++) {\n          if (child.isMesh) {\n            child.getVertexPosition(i, vertex);\n          } else {\n            vertex.fromBufferAttribute(position, i);\n          }\n          if (!child.isSkinnedMesh) {\n            vertex.applyMatrix4(child.matrixWorld);\n          }\n          value = func(value, vertex);\n        }\n      }\n    }\n  });\n  return value;\n}\n\n/**\n * @param {InstancedMesh}\n * @param {function(int, int):int}\n */\nfunction sortInstancedMesh(mesh, compareFn) {\n  // store copy of instanced attributes for lookups\n\n  const instanceMatrixRef = deepCloneAttribute(mesh.instanceMatrix);\n  const instanceColorRef = mesh.instanceColor ? deepCloneAttribute(mesh.instanceColor) : null;\n  const attributeRefs = new Map();\n  for (const name in mesh.geometry.attributes) {\n    const attribute = mesh.geometry.attributes[name];\n    if (attribute.isInstancedBufferAttribute) {\n      attributeRefs.set(attribute, deepCloneAttribute(attribute));\n    }\n  }\n\n  // compute sort order\n\n  const tokens = [];\n  for (let i = 0; i < mesh.count; i++) tokens.push(i);\n  tokens.sort(compareFn);\n\n  // apply sort order\n\n  for (let i = 0; i < tokens.length; i++) {\n    const refIndex = tokens[i];\n    _matrix.fromArray(instanceMatrixRef.array, refIndex * mesh.instanceMatrix.itemSize);\n    _matrix.toArray(mesh.instanceMatrix.array, i * mesh.instanceMatrix.itemSize);\n    if (mesh.instanceColor) {\n      _color.fromArray(instanceColorRef.array, refIndex * mesh.instanceColor.itemSize);\n      _color.toArray(mesh.instanceColor.array, i * mesh.instanceColor.itemSize);\n    }\n    for (const name in mesh.geometry.attributes) {\n      const attribute = mesh.geometry.attributes[name];\n      if (attribute.isInstancedBufferAttribute) {\n        const attributeRef = attributeRefs.get(attribute);\n        attribute.setX(i, attributeRef.getX(refIndex));\n        if (attribute.itemSize > 1) attribute.setY(i, attributeRef.getY(refIndex));\n        if (attribute.itemSize > 2) attribute.setZ(i, attributeRef.getZ(refIndex));\n        if (attribute.itemSize > 3) attribute.setW(i, attributeRef.getW(refIndex));\n      }\n    }\n  }\n}\n\n/**\n * @param {Object3D} object Object to traverse.\n * @yields {Object3D} Objects that passed the filter condition.\n */\nfunction* traverseGenerator(object) {\n  yield object;\n  const children = object.children;\n  for (let i = 0, l = children.length; i < l; i++) {\n    yield* traverseGenerator(children[i]);\n  }\n}\n\n/**\n * @param {Object3D} object Object to traverse.\n * @yields {Object3D} Objects that passed the filter condition.\n */\nfunction* traverseVisibleGenerator(object) {\n  if (object.visible === false) return;\n  yield object;\n  const children = object.children;\n  for (let i = 0, l = children.length; i < l; i++) {\n    yield* traverseVisibleGenerator(children[i]);\n  }\n}\n\n/**\n * @param {Object3D} object Object to traverse.\n * @yields {Object3D} Objects that passed the filter condition.\n */\nfunction* traverseAncestorsGenerator(object) {\n  const parent = object.parent;\n  if (parent !== null) {\n    yield parent;\n    yield* traverseAncestorsGenerator(parent);\n  }\n}\nexport { createMeshesFromInstancedMesh, createMeshesFromMultiMaterialMesh, createMultiMaterialObject, reduceVertices, sortInstancedMesh, traverseGenerator, traverseVisibleGenerator, traverseAncestorsGenerator };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}