{"ast":null,"code":"import { Vector3 } from 'three';\nconst temp = /* @__PURE__ */new Vector3();\nconst temp1 = /* @__PURE__ */new Vector3();\nexport function closestPointToPoint(bvh, point, target = {}, minThreshold = 0, maxThreshold = Infinity) {\n  // early out if under minThreshold\n  // skip checking if over maxThreshold\n  // set minThreshold = maxThreshold to quickly check if a point is within a threshold\n  // returns Infinity if no value found\n  const minThresholdSq = minThreshold * minThreshold;\n  const maxThresholdSq = maxThreshold * maxThreshold;\n  let closestDistanceSq = Infinity;\n  let closestDistanceTriIndex = null;\n  bvh.shapecast({\n    boundsTraverseOrder: box => {\n      temp.copy(point).clamp(box.min, box.max);\n      return temp.distanceToSquared(point);\n    },\n    intersectsBounds: (box, isLeaf, score) => {\n      return score < closestDistanceSq && score < maxThresholdSq;\n    },\n    intersectsTriangle: (tri, triIndex) => {\n      tri.closestPointToPoint(point, temp);\n      const distSq = point.distanceToSquared(temp);\n      if (distSq < closestDistanceSq) {\n        temp1.copy(temp);\n        closestDistanceSq = distSq;\n        closestDistanceTriIndex = triIndex;\n      }\n      if (distSq < minThresholdSq) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  });\n  if (closestDistanceSq === Infinity) return null;\n  const closestDistance = Math.sqrt(closestDistanceSq);\n  if (!target.point) target.point = temp1.clone();else target.point.copy(temp1);\n  target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;\n  return target;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}