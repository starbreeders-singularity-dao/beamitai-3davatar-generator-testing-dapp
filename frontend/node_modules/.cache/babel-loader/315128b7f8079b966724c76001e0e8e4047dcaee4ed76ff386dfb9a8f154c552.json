{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Matrix4, Vector3 } from 'three';\nimport { $needsRender, $onModelLoad, $scene, $tick, toVector2D, toVector3D } from '../model-viewer-base.js';\nimport { Hotspot } from '../three-components/Hotspot.js';\nconst $hotspotMap = Symbol('hotspotMap');\nconst $mutationCallback = Symbol('mutationCallback');\nconst $observer = Symbol('observer');\nconst $addHotspot = Symbol('addHotspot');\nconst $removeHotspot = Symbol('removeHotspot');\nconst worldToModel = new Matrix4();\n/**\n * AnnotationMixin implements a declarative API to add hotspots and annotations.\n * Child elements of the <model-viewer> element that have a slot name that\n * begins with \"hotspot\" and data-position and data-normal attributes in\n * the format of the camera-target attribute will be added to the scene and\n * track the specified model coordinates.\n */\nexport const AnnotationMixin = ModelViewerElement => {\n  var _a, _b, _c;\n  class AnnotationModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this[_a] = new Map();\n      this[_b] = mutations => {\n        mutations.forEach(mutation => {\n          // NOTE: Be wary that in ShadyDOM cases, the MutationRecord\n          // only has addedNodes and removedNodes (and no other details).\n          if (!(mutation instanceof MutationRecord) || mutation.type === 'childList') {\n            mutation.addedNodes.forEach(node => {\n              this[$addHotspot](node);\n            });\n            mutation.removedNodes.forEach(node => {\n              this[$removeHotspot](node);\n            });\n            this[$needsRender]();\n          }\n        });\n      };\n      this[_c] = new MutationObserver(this[$mutationCallback]);\n    }\n    connectedCallback() {\n      super.connectedCallback();\n      for (let i = 0; i < this.children.length; ++i) {\n        this[$addHotspot](this.children[i]);\n      }\n      const {\n        ShadyDOM\n      } = self;\n      if (ShadyDOM == null) {\n        this[$observer].observe(this, {\n          childList: true\n        });\n      } else {\n        this[$observer] = ShadyDOM.observeChildren(this, this[$mutationCallback]);\n      }\n    }\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      const {\n        ShadyDOM\n      } = self;\n      if (ShadyDOM == null) {\n        this[$observer].disconnect();\n      } else {\n        ShadyDOM.unobserveChildren(this[$observer]);\n      }\n    }\n    [(_a = $hotspotMap, _b = $mutationCallback, _c = $observer, $onModelLoad)]() {\n      super[$onModelLoad]();\n      const scene = this[$scene];\n      scene.forHotspots(hotspot => {\n        scene.updateSurfaceHotspot(hotspot);\n      });\n    }\n    [$tick](time, delta) {\n      super[$tick](time, delta);\n      const scene = this[$scene];\n      const {\n        annotationRenderer\n      } = scene;\n      const camera = scene.getCamera();\n      if (scene.shouldRender()) {\n        scene.animateSurfaceHotspots();\n        scene.updateHotspotsVisibility(camera.position);\n        annotationRenderer.domElement.style.display = '';\n        annotationRenderer.render(scene, camera);\n      }\n    }\n    /**\n     * Since the data-position and data-normal attributes are not observed, use\n     * this method to move a hotspot. Keep in mind that all hotspots with the\n     * same slot name use a single location and the first definition takes\n     * precedence, until updated with this method.\n     */\n    updateHotspot(config) {\n      const hotspot = this[$hotspotMap].get(config.name);\n      if (hotspot == null) {\n        return;\n      }\n      hotspot.updatePosition(config.position);\n      hotspot.updateNormal(config.normal);\n      hotspot.surface = config.surface;\n      this[$scene].updateSurfaceHotspot(hotspot);\n      this[$needsRender]();\n    }\n    /**\n     * This method returns in-scene data about a requested hotspot including\n     * its position in screen (canvas) space and its current visibility.\n     */\n    queryHotspot(name) {\n      const hotspot = this[$hotspotMap].get(name);\n      if (hotspot == null) {\n        return null;\n      }\n      const position = toVector3D(hotspot.position);\n      const normal = toVector3D(hotspot.normal);\n      const facingCamera = hotspot.facingCamera;\n      const scene = this[$scene];\n      const camera = scene.getCamera();\n      const vector = new Vector3();\n      vector.setFromMatrixPosition(hotspot.matrixWorld);\n      vector.project(camera);\n      const widthHalf = scene.width / 2;\n      const heightHalf = scene.height / 2;\n      vector.x = vector.x * widthHalf + widthHalf;\n      vector.y = -(vector.y * heightHalf) + heightHalf;\n      const canvasPosition = toVector3D(new Vector3(vector.x, vector.y, vector.z));\n      if (!Number.isFinite(canvasPosition.x) || !Number.isFinite(canvasPosition.y)) {\n        return null;\n      }\n      return {\n        position,\n        normal,\n        canvasPosition,\n        facingCamera\n      };\n    }\n    /**\n     * This method returns the model position, normal and texture coordinate\n     * of the point on the mesh corresponding to the input pixel coordinates\n     * given relative to the model-viewer element. The position and normal\n     * are returned as strings in the format suitable for putting in a\n     * hotspot's data-position and data-normal attributes. If the mesh is\n     * not hit, the result is null.\n     */\n    positionAndNormalFromPoint(pixelX, pixelY) {\n      const scene = this[$scene];\n      const ndcPosition = scene.getNDC(pixelX, pixelY);\n      const hit = scene.positionAndNormalFromPoint(ndcPosition);\n      if (hit == null) {\n        return null;\n      }\n      worldToModel.copy(scene.target.matrixWorld).invert();\n      const position = toVector3D(hit.position.applyMatrix4(worldToModel));\n      const normal = toVector3D(hit.normal.transformDirection(worldToModel));\n      let uv = null;\n      if (hit.uv != null) {\n        uv = toVector2D(hit.uv);\n      }\n      return {\n        position: position,\n        normal: normal,\n        uv: uv\n      };\n    }\n    /**\n     * This method returns a dynamic hotspot ID string of the point on the mesh\n     * corresponding to the input pixel coordinates given relative to the\n     * model-viewer element. The ID string can be used in the data-surface\n     * attribute of the hotspot to make it follow this point on the surface even\n     * as the model animates. If the mesh is not hit, the result is null.\n     */\n    surfaceFromPoint(pixelX, pixelY) {\n      const scene = this[$scene];\n      const ndcPosition = scene.getNDC(pixelX, pixelY);\n      return scene.surfaceFromPoint(ndcPosition);\n    }\n    [$addHotspot](node) {\n      if (!(node instanceof HTMLElement && node.slot.indexOf('hotspot') === 0)) {\n        return;\n      }\n      let hotspot = this[$hotspotMap].get(node.slot);\n      if (hotspot != null) {\n        hotspot.increment();\n      } else {\n        hotspot = new Hotspot({\n          name: node.slot,\n          position: node.dataset.position,\n          normal: node.dataset.normal,\n          surface: node.dataset.surface\n        });\n        this[$hotspotMap].set(node.slot, hotspot);\n        this[$scene].addHotspot(hotspot);\n      }\n      this[$scene].queueRender();\n    }\n    [$removeHotspot](node) {\n      if (!(node instanceof HTMLElement)) {\n        return;\n      }\n      const hotspot = this[$hotspotMap].get(node.slot);\n      if (!hotspot) {\n        return;\n      }\n      if (hotspot.decrement()) {\n        this[$scene].removeHotspot(hotspot);\n        this[$hotspotMap].delete(node.slot);\n      }\n      this[$scene].queueRender();\n    }\n  }\n  return AnnotationModelViewerElement;\n};\n//# sourceMappingURL=annotation.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}