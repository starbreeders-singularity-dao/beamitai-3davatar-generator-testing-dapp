{"ast":null,"code":"import { Loader, FileLoader, Group, MeshPhongMaterial, Float32BufferAttribute, Color, BufferGeometry, Mesh } from \"three\";\nimport { unzipSync } from \"fflate\";\nimport { decodeText } from \"../_polyfill/LoaderUtils.js\";\nclass AMFLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(data) {\n    function loadDocument(data2) {\n      let view = new DataView(data2);\n      const magic = String.fromCharCode(view.getUint8(0), view.getUint8(1));\n      if (magic === \"PK\") {\n        let zip = null;\n        let file = null;\n        console.log(\"THREE.AMFLoader: Loading Zip\");\n        try {\n          zip = unzipSync(new Uint8Array(data2));\n        } catch (e) {\n          if (e instanceof ReferenceError) {\n            console.log(\"THREE.AMFLoader: fflate missing and file is compressed.\");\n            return null;\n          }\n        }\n        for (file in zip) {\n          if (file.toLowerCase().substr(-4) === \".amf\") {\n            break;\n          }\n        }\n        console.log(\"THREE.AMFLoader: Trying to load file asset: \" + file);\n        view = new DataView(zip[file].buffer);\n      }\n      const fileText = decodeText(view);\n      const xmlData2 = new DOMParser().parseFromString(fileText, \"application/xml\");\n      if (xmlData2.documentElement.nodeName.toLowerCase() !== \"amf\") {\n        console.log(\"THREE.AMFLoader: Error loading AMF - no AMF document found.\");\n        return null;\n      }\n      return xmlData2;\n    }\n    function loadDocumentScale(node) {\n      let scale = 1;\n      let unit = \"millimeter\";\n      if (node.documentElement.attributes.unit !== void 0) {\n        unit = node.documentElement.attributes.unit.value.toLowerCase();\n      }\n      const scaleUnits = {\n        millimeter: 1,\n        inch: 25.4,\n        feet: 304.8,\n        meter: 1e3,\n        micron: 1e-3\n      };\n      if (scaleUnits[unit] !== void 0) {\n        scale = scaleUnits[unit];\n      }\n      console.log(\"THREE.AMFLoader: Unit scale: \" + scale);\n      return scale;\n    }\n    function loadMaterials(node) {\n      let matName = \"AMF Material\";\n      const matId = node.attributes.id.textContent;\n      let color = {\n        r: 1,\n        g: 1,\n        b: 1,\n        a: 1\n      };\n      let loadedMaterial = null;\n      for (let i2 = 0; i2 < node.childNodes.length; i2++) {\n        const matChildEl = node.childNodes[i2];\n        if (matChildEl.nodeName === \"metadata\" && matChildEl.attributes.type !== void 0) {\n          if (matChildEl.attributes.type.value === \"name\") {\n            matName = matChildEl.textContent;\n          }\n        } else if (matChildEl.nodeName === \"color\") {\n          color = loadColor(matChildEl);\n        }\n      }\n      loadedMaterial = new MeshPhongMaterial({\n        flatShading: true,\n        color: new Color(color.r, color.g, color.b),\n        name: matName\n      });\n      if (color.a !== 1) {\n        loadedMaterial.transparent = true;\n        loadedMaterial.opacity = color.a;\n      }\n      return {\n        id: matId,\n        material: loadedMaterial\n      };\n    }\n    function loadColor(node) {\n      const color = {\n        r: 1,\n        g: 1,\n        b: 1,\n        a: 1\n      };\n      for (let i2 = 0; i2 < node.childNodes.length; i2++) {\n        const matColor = node.childNodes[i2];\n        if (matColor.nodeName === \"r\") {\n          color.r = matColor.textContent;\n        } else if (matColor.nodeName === \"g\") {\n          color.g = matColor.textContent;\n        } else if (matColor.nodeName === \"b\") {\n          color.b = matColor.textContent;\n        } else if (matColor.nodeName === \"a\") {\n          color.a = matColor.textContent;\n        }\n      }\n      return color;\n    }\n    function loadMeshVolume(node) {\n      const volume = {\n        name: \"\",\n        triangles: [],\n        materialid: null\n      };\n      let currVolumeNode = node.firstElementChild;\n      if (node.attributes.materialid !== void 0) {\n        volume.materialId = node.attributes.materialid.nodeValue;\n      }\n      while (currVolumeNode) {\n        if (currVolumeNode.nodeName === \"metadata\") {\n          if (currVolumeNode.attributes.type !== void 0) {\n            if (currVolumeNode.attributes.type.value === \"name\") {\n              volume.name = currVolumeNode.textContent;\n            }\n          }\n        } else if (currVolumeNode.nodeName === \"triangle\") {\n          const v1 = currVolumeNode.getElementsByTagName(\"v1\")[0].textContent;\n          const v2 = currVolumeNode.getElementsByTagName(\"v2\")[0].textContent;\n          const v3 = currVolumeNode.getElementsByTagName(\"v3\")[0].textContent;\n          volume.triangles.push(v1, v2, v3);\n        }\n        currVolumeNode = currVolumeNode.nextElementSibling;\n      }\n      return volume;\n    }\n    function loadMeshVertices(node) {\n      const vertArray = [];\n      const normalArray = [];\n      let currVerticesNode = node.firstElementChild;\n      while (currVerticesNode) {\n        if (currVerticesNode.nodeName === \"vertex\") {\n          let vNode = currVerticesNode.firstElementChild;\n          while (vNode) {\n            if (vNode.nodeName === \"coordinates\") {\n              const x = vNode.getElementsByTagName(\"x\")[0].textContent;\n              const y = vNode.getElementsByTagName(\"y\")[0].textContent;\n              const z = vNode.getElementsByTagName(\"z\")[0].textContent;\n              vertArray.push(x, y, z);\n            } else if (vNode.nodeName === \"normal\") {\n              const nx = vNode.getElementsByTagName(\"nx\")[0].textContent;\n              const ny = vNode.getElementsByTagName(\"ny\")[0].textContent;\n              const nz = vNode.getElementsByTagName(\"nz\")[0].textContent;\n              normalArray.push(nx, ny, nz);\n            }\n            vNode = vNode.nextElementSibling;\n          }\n        }\n        currVerticesNode = currVerticesNode.nextElementSibling;\n      }\n      return {\n        vertices: vertArray,\n        normals: normalArray\n      };\n    }\n    function loadObject(node) {\n      const objId = node.attributes.id.textContent;\n      const loadedObject = {\n        name: \"amfobject\",\n        meshes: []\n      };\n      let currColor = null;\n      let currObjNode = node.firstElementChild;\n      while (currObjNode) {\n        if (currObjNode.nodeName === \"metadata\") {\n          if (currObjNode.attributes.type !== void 0) {\n            if (currObjNode.attributes.type.value === \"name\") {\n              loadedObject.name = currObjNode.textContent;\n            }\n          }\n        } else if (currObjNode.nodeName === \"color\") {\n          currColor = loadColor(currObjNode);\n        } else if (currObjNode.nodeName === \"mesh\") {\n          let currMeshNode = currObjNode.firstElementChild;\n          const mesh = {\n            vertices: [],\n            normals: [],\n            volumes: [],\n            color: currColor\n          };\n          while (currMeshNode) {\n            if (currMeshNode.nodeName === \"vertices\") {\n              const loadedVertices = loadMeshVertices(currMeshNode);\n              mesh.normals = mesh.normals.concat(loadedVertices.normals);\n              mesh.vertices = mesh.vertices.concat(loadedVertices.vertices);\n            } else if (currMeshNode.nodeName === \"volume\") {\n              mesh.volumes.push(loadMeshVolume(currMeshNode));\n            }\n            currMeshNode = currMeshNode.nextElementSibling;\n          }\n          loadedObject.meshes.push(mesh);\n        }\n        currObjNode = currObjNode.nextElementSibling;\n      }\n      return {\n        id: objId,\n        obj: loadedObject\n      };\n    }\n    const xmlData = loadDocument(data);\n    let amfName = \"\";\n    let amfAuthor = \"\";\n    const amfScale = loadDocumentScale(xmlData);\n    const amfMaterials = {};\n    const amfObjects = {};\n    const childNodes = xmlData.documentElement.childNodes;\n    let i, j;\n    for (i = 0; i < childNodes.length; i++) {\n      const child = childNodes[i];\n      if (child.nodeName === \"metadata\") {\n        if (child.attributes.type !== void 0) {\n          if (child.attributes.type.value === \"name\") {\n            amfName = child.textContent;\n          } else if (child.attributes.type.value === \"author\") {\n            amfAuthor = child.textContent;\n          }\n        }\n      } else if (child.nodeName === \"material\") {\n        const loadedMaterial = loadMaterials(child);\n        amfMaterials[loadedMaterial.id] = loadedMaterial.material;\n      } else if (child.nodeName === \"object\") {\n        const loadedObject = loadObject(child);\n        amfObjects[loadedObject.id] = loadedObject.obj;\n      }\n    }\n    const sceneObject = new Group();\n    const defaultMaterial = new MeshPhongMaterial({\n      color: 11184895,\n      flatShading: true\n    });\n    sceneObject.name = amfName;\n    sceneObject.userData.author = amfAuthor;\n    sceneObject.userData.loader = \"AMF\";\n    for (const id in amfObjects) {\n      const part = amfObjects[id];\n      const meshes = part.meshes;\n      const newObject = new Group();\n      newObject.name = part.name || \"\";\n      for (i = 0; i < meshes.length; i++) {\n        let objDefaultMaterial = defaultMaterial;\n        const mesh = meshes[i];\n        const vertices = new Float32BufferAttribute(mesh.vertices, 3);\n        let normals = null;\n        if (mesh.normals.length) {\n          normals = new Float32BufferAttribute(mesh.normals, 3);\n        }\n        if (mesh.color) {\n          const color = mesh.color;\n          objDefaultMaterial = defaultMaterial.clone();\n          objDefaultMaterial.color = new Color(color.r, color.g, color.b);\n          if (color.a !== 1) {\n            objDefaultMaterial.transparent = true;\n            objDefaultMaterial.opacity = color.a;\n          }\n        }\n        const volumes = mesh.volumes;\n        for (j = 0; j < volumes.length; j++) {\n          const volume = volumes[j];\n          const newGeometry = new BufferGeometry();\n          let material = objDefaultMaterial;\n          newGeometry.setIndex(volume.triangles);\n          newGeometry.setAttribute(\"position\", vertices.clone());\n          if (normals) {\n            newGeometry.setAttribute(\"normal\", normals.clone());\n          }\n          if (amfMaterials[volume.materialId] !== void 0) {\n            material = amfMaterials[volume.materialId];\n          }\n          newGeometry.scale(amfScale, amfScale, amfScale);\n          newObject.add(new Mesh(newGeometry, material.clone()));\n        }\n      }\n      sceneObject.add(newObject);\n    }\n    return sceneObject;\n  }\n}\nexport { AMFLoader };\n//# sourceMappingURL=AMFLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}