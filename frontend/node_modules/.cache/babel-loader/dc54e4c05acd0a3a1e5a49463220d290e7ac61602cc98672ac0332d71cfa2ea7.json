{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { format, toHex } from 'web3-utils';\nimport { HardforksOrdered, ETH_DATA_FORMAT } from 'web3-types';\nimport { Web3ValidatorError, isNullish, validator } from 'web3-validator';\nimport { InvalidPropertiesForTransactionTypeError } from 'web3-errors';\n// undefined is treated as null for JSON schema validator\nconst transactionType0x0Schema = {\n  type: 'object',\n  properties: {\n    accessList: {\n      type: 'null'\n    },\n    maxFeePerGas: {\n      type: 'null'\n    },\n    maxPriorityFeePerGas: {\n      type: 'null'\n    }\n  }\n};\nconst transactionType0x1Schema = {\n  type: 'object',\n  properties: {\n    maxFeePerGas: {\n      type: 'null'\n    },\n    maxPriorityFeePerGas: {\n      type: 'null'\n    }\n  }\n};\nconst transactionType0x2Schema = {\n  type: 'object',\n  properties: {\n    gasPrice: {\n      type: 'null'\n    }\n  }\n};\nconst validateTxTypeAndHandleErrors = (txSchema, tx, txType) => {\n  try {\n    validator.validateJSONSchema(txSchema, tx);\n  } catch (error) {\n    if (error instanceof Web3ValidatorError)\n      // Erroneously reported error\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      throw new InvalidPropertiesForTransactionTypeError(error.errors, txType);\n    throw error;\n  }\n};\nexport const defaultTransactionTypeParser = transaction => {\n  var _a, _b;\n  const tx = transaction;\n  if (!isNullish(tx.type)) {\n    let txSchema;\n    switch (tx.type) {\n      case '0x0':\n        txSchema = transactionType0x0Schema;\n        break;\n      case '0x1':\n        txSchema = transactionType0x1Schema;\n        break;\n      case '0x2':\n        txSchema = transactionType0x2Schema;\n        break;\n      default:\n        return format({\n          format: 'uint'\n        }, tx.type, ETH_DATA_FORMAT);\n    }\n    validateTxTypeAndHandleErrors(txSchema, tx, tx.type);\n    return format({\n      format: 'uint'\n    }, tx.type, ETH_DATA_FORMAT);\n  }\n  if (!isNullish(tx.maxFeePerGas) || !isNullish(tx.maxPriorityFeePerGas)) {\n    validateTxTypeAndHandleErrors(transactionType0x2Schema, tx, '0x2');\n    return '0x2';\n  }\n  if (!isNullish(tx.accessList)) {\n    validateTxTypeAndHandleErrors(transactionType0x1Schema, tx, '0x1');\n    return '0x1';\n  }\n  const givenHardfork = (_a = tx.hardfork) !== null && _a !== void 0 ? _a : (_b = tx.common) === null || _b === void 0 ? void 0 : _b.hardfork;\n  if (!isNullish(givenHardfork)) {\n    const hardforkIndex = Object.keys(HardforksOrdered).indexOf(givenHardfork);\n    // givenHardfork is London or later, so EIP-2718 is supported\n    if (hardforkIndex >= Object.keys(HardforksOrdered).indexOf('london')) return !isNullish(tx.gasPrice) ? '0x0' : '0x2';\n    // givenHardfork is Berlin, tx.accessList is undefined, assume type is 0x0\n    if (hardforkIndex === Object.keys(HardforksOrdered).indexOf('berlin')) return '0x0';\n  }\n  // gasprice is defined\n  if (!isNullish(tx.gasPrice)) {\n    validateTxTypeAndHandleErrors(transactionType0x0Schema, tx, '0x0');\n    return '0x0';\n  }\n  // no transaction type can be inferred from properties, use default transaction type\n  return undefined;\n};\nexport const detectTransactionType = (transaction, web3Context) => {\n  var _a;\n  return ((_a = web3Context === null || web3Context === void 0 ? void 0 : web3Context.transactionTypeParser) !== null && _a !== void 0 ? _a : defaultTransactionTypeParser)(transaction);\n};\nexport const detectRawTransactionType = transaction => transaction[0] > 0x7f ? '0x0' : toHex(transaction[0]);\n//# sourceMappingURL=detect_transaction_type.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}