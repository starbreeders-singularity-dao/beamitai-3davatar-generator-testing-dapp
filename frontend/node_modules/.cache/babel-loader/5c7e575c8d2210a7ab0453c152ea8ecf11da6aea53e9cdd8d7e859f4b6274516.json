{"ast":null,"code":"import { Box3 } from 'three';\nimport { CONTAINED } from '../Constants.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nlet _box1, _box2;\nconst boxStack = [];\nconst boxPool = /* @__PURE__ */new PrimitivePool(() => new Box3());\nexport function shapecast(bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset) {\n  // setup\n  _box1 = boxPool.getPrimitive();\n  _box2 = boxPool.getPrimitive();\n  boxStack.push(_box1, _box2);\n  BufferStack.setBuffer(bvh._roots[root]);\n  const result = shapecastTraverse(0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n\n  // cleanup\n  BufferStack.clearBuffer();\n  boxPool.releasePrimitive(_box1);\n  boxPool.releasePrimitive(_box2);\n  boxStack.pop();\n  boxStack.pop();\n  const length = boxStack.length;\n  if (length > 0) {\n    _box2 = boxStack[length - 1];\n    _box1 = boxStack[length - 2];\n  }\n  return result;\n}\nfunction shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc = null, nodeIndexByteOffset = 0,\n// offset for unique node identifier\ndepth = 0) {\n  const {\n    float32Array,\n    uint16Array,\n    uint32Array\n  } = BufferStack;\n  let nodeIndex16 = nodeIndex32 * 2;\n  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n  if (isLeaf) {\n    const offset = OFFSET(nodeIndex32, uint32Array);\n    const count = COUNT(nodeIndex16, uint16Array);\n    arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, _box1);\n    return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1);\n  } else {\n    const left = LEFT_NODE(nodeIndex32);\n    const right = RIGHT_NODE(nodeIndex32, uint32Array);\n    let c1 = left;\n    let c2 = right;\n    let score1, score2;\n    let box1, box2;\n    if (nodeScoreFunc) {\n      box1 = _box1;\n      box2 = _box2;\n\n      // bounding data is not offset\n      arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);\n      arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);\n      score1 = nodeScoreFunc(box1);\n      score2 = nodeScoreFunc(box2);\n      if (score2 < score1) {\n        c1 = right;\n        c2 = left;\n        const temp = score1;\n        score1 = score2;\n        score2 = temp;\n        box1 = box2;\n        // box2 is always set before use below\n      }\n    }\n\n    // Check box 1 intersection\n    if (!box1) {\n      box1 = _box1;\n      arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);\n    }\n    const isC1Leaf = IS_LEAF(c1 * 2, uint16Array);\n    const c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);\n    let c1StopTraversal;\n    if (c1Intersection === CONTAINED) {\n      const offset = getLeftOffset(c1);\n      const end = getRightEndOffset(c1);\n      const count = end - offset;\n      c1StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1);\n    } else {\n      c1StopTraversal = c1Intersection && shapecastTraverse(c1, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n    }\n    if (c1StopTraversal) return true;\n\n    // Check box 2 intersection\n    // cached box2 will have been overwritten by previous traversal\n    box2 = _box2;\n    arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);\n    const isC2Leaf = IS_LEAF(c2 * 2, uint16Array);\n    const c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);\n    let c2StopTraversal;\n    if (c2Intersection === CONTAINED) {\n      const offset = getLeftOffset(c2);\n      const end = getRightEndOffset(c2);\n      const count = end - offset;\n      c2StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2);\n    } else {\n      c2StopTraversal = c2Intersection && shapecastTraverse(c2, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n    }\n    if (c2StopTraversal) return true;\n    return false;\n\n    // Define these inside the function so it has access to the local variables needed\n    // when converting to the buffer equivalents\n    function getLeftOffset(nodeIndex32) {\n      const {\n        uint16Array,\n        uint32Array\n      } = BufferStack;\n      let nodeIndex16 = nodeIndex32 * 2;\n\n      // traverse until we find a leaf\n      while (!IS_LEAF(nodeIndex16, uint16Array)) {\n        nodeIndex32 = LEFT_NODE(nodeIndex32);\n        nodeIndex16 = nodeIndex32 * 2;\n      }\n      return OFFSET(nodeIndex32, uint32Array);\n    }\n    function getRightEndOffset(nodeIndex32) {\n      const {\n        uint16Array,\n        uint32Array\n      } = BufferStack;\n      let nodeIndex16 = nodeIndex32 * 2;\n\n      // traverse until we find a leaf\n      while (!IS_LEAF(nodeIndex16, uint16Array)) {\n        // adjust offset to point to the right node\n        nodeIndex32 = RIGHT_NODE(nodeIndex32, uint32Array);\n        nodeIndex16 = nodeIndex32 * 2;\n      }\n\n      // return the end offset of the triangle range\n      return OFFSET(nodeIndex32, uint32Array) + COUNT(nodeIndex16, uint16Array);\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}