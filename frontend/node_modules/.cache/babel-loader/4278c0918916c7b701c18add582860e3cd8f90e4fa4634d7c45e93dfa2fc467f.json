{"ast":null,"code":"import { Loader, FileLoader, Vector3, Matrix4 } from \"three\";\nimport { gunzipSync } from \"fflate\";\nimport { Volume } from \"../misc/Volume.js\";\nclass NRRDLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        onLoad(scope.parse(data));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(data) {\n    let _data = data;\n    let _dataPointer = 0;\n    const _nativeLittleEndian = new Int8Array(new Int16Array([1]).buffer)[0] > 0;\n    const _littleEndian = true;\n    const headerObject = {};\n    function scan(type, chunks) {\n      if (chunks === void 0 || chunks === null) {\n        chunks = 1;\n      }\n      let _chunkSize = 1;\n      let _array_type = Uint8Array;\n      switch (type) {\n        case \"uchar\":\n          break;\n        case \"schar\":\n          _array_type = Int8Array;\n          break;\n        case \"ushort\":\n          _array_type = Uint16Array;\n          _chunkSize = 2;\n          break;\n        case \"sshort\":\n          _array_type = Int16Array;\n          _chunkSize = 2;\n          break;\n        case \"uint\":\n          _array_type = Uint32Array;\n          _chunkSize = 4;\n          break;\n        case \"sint\":\n          _array_type = Int32Array;\n          _chunkSize = 4;\n          break;\n        case \"float\":\n          _array_type = Float32Array;\n          _chunkSize = 4;\n          break;\n        case \"complex\":\n          _array_type = Float64Array;\n          _chunkSize = 8;\n          break;\n        case \"double\":\n          _array_type = Float64Array;\n          _chunkSize = 8;\n          break;\n      }\n      let _bytes2 = new _array_type(_data.slice(_dataPointer, _dataPointer += chunks * _chunkSize));\n      if (_nativeLittleEndian != _littleEndian) {\n        _bytes2 = flipEndianness(_bytes2, _chunkSize);\n      }\n      if (chunks == 1) {\n        return _bytes2[0];\n      }\n      return _bytes2;\n    }\n    function flipEndianness(array, chunkSize) {\n      const u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n      for (let i2 = 0; i2 < array.byteLength; i2 += chunkSize) {\n        for (let j = i2 + chunkSize - 1, k = i2; j > k; j--, k++) {\n          const tmp = u8[k];\n          u8[k] = u8[j];\n          u8[j] = tmp;\n        }\n      }\n      return array;\n    }\n    function parseHeader(header) {\n      let data2, field, fn, i2, l, m, _i, _len;\n      const lines = header.split(/\\r?\\n/);\n      for (_i = 0, _len = lines.length; _i < _len; _i++) {\n        l = lines[_i];\n        if (l.match(/NRRD\\d+/)) {\n          headerObject.isNrrd = true;\n        } else if (l.match(/^#/)) ;else if (m = l.match(/(.*):(.*)/)) {\n          field = m[1].trim();\n          data2 = m[2].trim();\n          fn = _fieldFunctions[field];\n          if (fn) {\n            fn.call(headerObject, data2);\n          } else {\n            headerObject[field] = data2;\n          }\n        }\n      }\n      if (!headerObject.isNrrd) {\n        throw new Error(\"Not an NRRD file\");\n      }\n      if (headerObject.encoding === \"bz2\" || headerObject.encoding === \"bzip2\") {\n        throw new Error(\"Bzip is not supported\");\n      }\n      if (!headerObject.vectors) {\n        headerObject.vectors = [new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1)];\n        if (headerObject.spacings) {\n          for (i2 = 0; i2 <= 2; i2++) {\n            if (!isNaN(headerObject.spacings[i2])) {\n              headerObject.vectors[i2].multiplyScalar(headerObject.spacings[i2]);\n            }\n          }\n        }\n      }\n    }\n    function parseDataAsText(data2, start, end) {\n      let number = \"\";\n      start = start || 0;\n      end = end || data2.length;\n      let value;\n      const lengthOfTheResult = headerObject.sizes.reduce(function (previous, current) {\n        return previous * current;\n      }, 1);\n      let base = 10;\n      if (headerObject.encoding === \"hex\") {\n        base = 16;\n      }\n      const result = new headerObject.__array(lengthOfTheResult);\n      let resultIndex = 0;\n      let parsingFunction = parseInt;\n      if (headerObject.__array === Float32Array || headerObject.__array === Float64Array) {\n        parsingFunction = parseFloat;\n      }\n      for (let i2 = start; i2 < end; i2++) {\n        value = data2[i2];\n        if ((value < 9 || value > 13) && value !== 32) {\n          number += String.fromCharCode(value);\n        } else {\n          if (number !== \"\") {\n            result[resultIndex] = parsingFunction(number, base);\n            resultIndex++;\n          }\n          number = \"\";\n        }\n      }\n      if (number !== \"\") {\n        result[resultIndex] = parsingFunction(number, base);\n        resultIndex++;\n      }\n      return result;\n    }\n    const _bytes = scan(\"uchar\", data.byteLength);\n    const _length = _bytes.length;\n    let _header = null;\n    let _data_start = 0;\n    let i;\n    for (i = 1; i < _length; i++) {\n      if (_bytes[i - 1] == 10 && _bytes[i] == 10) {\n        _header = this.parseChars(_bytes, 0, i - 2);\n        _data_start = i + 1;\n        break;\n      }\n    }\n    parseHeader(_header);\n    _data = _bytes.subarray(_data_start);\n    if (headerObject.encoding.substring(0, 2) === \"gz\") {\n      _data = gunzipSync(new Uint8Array(_data));\n    } else if (headerObject.encoding === \"ascii\" || headerObject.encoding === \"text\" || headerObject.encoding === \"txt\" || headerObject.encoding === \"hex\") {\n      _data = parseDataAsText(_data);\n    } else if (headerObject.encoding === \"raw\") {\n      const _copy = new Uint8Array(_data.length);\n      for (let i2 = 0; i2 < _data.length; i2++) {\n        _copy[i2] = _data[i2];\n      }\n      _data = _copy;\n    }\n    _data = _data.buffer;\n    const volume = new Volume();\n    volume.header = headerObject;\n    volume.data = new headerObject.__array(_data);\n    const min_max = volume.computeMinMax();\n    const min = min_max[0];\n    const max = min_max[1];\n    volume.windowLow = min;\n    volume.windowHigh = max;\n    volume.dimensions = [headerObject.sizes[0], headerObject.sizes[1], headerObject.sizes[2]];\n    volume.xLength = volume.dimensions[0];\n    volume.yLength = volume.dimensions[1];\n    volume.zLength = volume.dimensions[2];\n    const spacingX = new Vector3(headerObject.vectors[0][0], headerObject.vectors[0][1], headerObject.vectors[0][2]).length();\n    const spacingY = new Vector3(headerObject.vectors[1][0], headerObject.vectors[1][1], headerObject.vectors[1][2]).length();\n    const spacingZ = new Vector3(headerObject.vectors[2][0], headerObject.vectors[2][1], headerObject.vectors[2][2]).length();\n    volume.spacing = [spacingX, spacingY, spacingZ];\n    volume.matrix = new Matrix4();\n    let _spaceX = 1;\n    let _spaceY = 1;\n    const _spaceZ = 1;\n    if (headerObject.space == \"left-posterior-superior\") {\n      _spaceX = -1;\n      _spaceY = -1;\n    } else if (headerObject.space === \"left-anterior-superior\") {\n      _spaceX = -1;\n    }\n    if (!headerObject.vectors) {\n      volume.matrix.set(_spaceX, 0, 0, 0, 0, _spaceY, 0, 0, 0, 0, _spaceZ, 0, 0, 0, 0, 1);\n    } else {\n      const v = headerObject.vectors;\n      volume.matrix.set(_spaceX * v[0][0], _spaceX * v[1][0], _spaceX * v[2][0], 0, _spaceY * v[0][1], _spaceY * v[1][1], _spaceY * v[2][1], 0, _spaceZ * v[0][2], _spaceZ * v[1][2], _spaceZ * v[2][2], 0, 0, 0, 0, 1);\n    }\n    volume.inverseMatrix = new Matrix4();\n    volume.inverseMatrix.copy(volume.matrix).invert();\n    volume.RASDimensions = new Vector3(volume.xLength, volume.yLength, volume.zLength).applyMatrix4(volume.matrix).round().toArray().map(Math.abs);\n    if (volume.lowerThreshold === -Infinity) {\n      volume.lowerThreshold = min;\n    }\n    if (volume.upperThreshold === Infinity) {\n      volume.upperThreshold = max;\n    }\n    return volume;\n  }\n  parseChars(array, start, end) {\n    if (start === void 0) {\n      start = 0;\n    }\n    if (end === void 0) {\n      end = array.length;\n    }\n    let output = \"\";\n    let i = 0;\n    for (i = start; i < end; ++i) {\n      output += String.fromCharCode(array[i]);\n    }\n    return output;\n  }\n}\nconst _fieldFunctions = {\n  type: function (data) {\n    switch (data) {\n      case \"uchar\":\n      case \"unsigned char\":\n      case \"uint8\":\n      case \"uint8_t\":\n        this.__array = Uint8Array;\n        break;\n      case \"signed char\":\n      case \"int8\":\n      case \"int8_t\":\n        this.__array = Int8Array;\n        break;\n      case \"short\":\n      case \"short int\":\n      case \"signed short\":\n      case \"signed short int\":\n      case \"int16\":\n      case \"int16_t\":\n        this.__array = Int16Array;\n        break;\n      case \"ushort\":\n      case \"unsigned short\":\n      case \"unsigned short int\":\n      case \"uint16\":\n      case \"uint16_t\":\n        this.__array = Uint16Array;\n        break;\n      case \"int\":\n      case \"signed int\":\n      case \"int32\":\n      case \"int32_t\":\n        this.__array = Int32Array;\n        break;\n      case \"uint\":\n      case \"unsigned int\":\n      case \"uint32\":\n      case \"uint32_t\":\n        this.__array = Uint32Array;\n        break;\n      case \"float\":\n        this.__array = Float32Array;\n        break;\n      case \"double\":\n        this.__array = Float64Array;\n        break;\n      default:\n        throw new Error(\"Unsupported NRRD data type: \" + data);\n    }\n    return this.type = data;\n  },\n  endian: function (data) {\n    return this.endian = data;\n  },\n  encoding: function (data) {\n    return this.encoding = data;\n  },\n  dimension: function (data) {\n    return this.dim = parseInt(data, 10);\n  },\n  sizes: function (data) {\n    let i;\n    return this.sizes = function () {\n      const _ref = data.split(/\\s+/);\n      const _results = [];\n      for (let _i = 0, _len = _ref.length; _i < _len; _i++) {\n        i = _ref[_i];\n        _results.push(parseInt(i, 10));\n      }\n      return _results;\n    }();\n  },\n  space: function (data) {\n    return this.space = data;\n  },\n  \"space origin\": function (data) {\n    return this.space_origin = data.split(\"(\")[1].split(\")\")[0].split(\",\");\n  },\n  \"space directions\": function (data) {\n    let f, v;\n    const parts = data.match(/\\(.*?\\)/g);\n    return this.vectors = function () {\n      const _results = [];\n      for (let _i = 0, _len = parts.length; _i < _len; _i++) {\n        v = parts[_i];\n        _results.push(function () {\n          const _ref = v.slice(1, -1).split(/,/);\n          const _results2 = [];\n          for (let _j = 0, _len2 = _ref.length; _j < _len2; _j++) {\n            f = _ref[_j];\n            _results2.push(parseFloat(f));\n          }\n          return _results2;\n        }());\n      }\n      return _results;\n    }();\n  },\n  spacings: function (data) {\n    let f;\n    const parts = data.split(/\\s+/);\n    return this.spacings = function () {\n      const _results = [];\n      for (let _i = 0, _len = parts.length; _i < _len; _i++) {\n        f = parts[_i];\n        _results.push(parseFloat(f));\n      }\n      return _results;\n    }();\n  }\n};\nexport { NRRDLoader };\n//# sourceMappingURL=NRRDLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}