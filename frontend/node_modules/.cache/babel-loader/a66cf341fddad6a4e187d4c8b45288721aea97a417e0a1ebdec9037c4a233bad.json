{"ast":null,"code":"import { Vector3, Matrix3, Box3, Matrix4, Ray, MathUtils } from \"three\";\nconst a = {\n  c: null,\n  // center\n  u: [new Vector3(), new Vector3(), new Vector3()],\n  // basis vectors\n  e: []\n  // half width\n};\nconst b = {\n  c: null,\n  // center\n  u: [new Vector3(), new Vector3(), new Vector3()],\n  // basis vectors\n  e: []\n  // half width\n};\nconst R = [[], [], []];\nconst AbsR = [[], [], []];\nconst t = [];\nconst xAxis = new Vector3();\nconst yAxis = new Vector3();\nconst zAxis = new Vector3();\nconst v1 = new Vector3();\nconst size = new Vector3();\nconst closestPoint = new Vector3();\nconst rotationMatrix = new Matrix3();\nconst aabb = new Box3();\nconst matrix = new Matrix4();\nconst inverse = new Matrix4();\nconst localRay = new Ray();\nclass OBB {\n  constructor(center = new Vector3(), halfSize = new Vector3(), rotation = new Matrix3()) {\n    this.center = center;\n    this.halfSize = halfSize;\n    this.rotation = rotation;\n  }\n  set(center, halfSize, rotation) {\n    this.center = center;\n    this.halfSize = halfSize;\n    this.rotation = rotation;\n    return this;\n  }\n  copy(obb2) {\n    this.center.copy(obb2.center);\n    this.halfSize.copy(obb2.halfSize);\n    this.rotation.copy(obb2.rotation);\n    return this;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  getSize(result) {\n    return result.copy(this.halfSize).multiplyScalar(2);\n  }\n  /**\n   * Reference: Closest Point on OBB to Point in Real-Time Collision Detection\n   * by Christer Ericson (chapter 5.1.4)\n   */\n  clampPoint(point, result) {\n    const halfSize = this.halfSize;\n    v1.subVectors(point, this.center);\n    this.rotation.extractBasis(xAxis, yAxis, zAxis);\n    result.copy(this.center);\n    const x = MathUtils.clamp(v1.dot(xAxis), -halfSize.x, halfSize.x);\n    result.add(xAxis.multiplyScalar(x));\n    const y = MathUtils.clamp(v1.dot(yAxis), -halfSize.y, halfSize.y);\n    result.add(yAxis.multiplyScalar(y));\n    const z = MathUtils.clamp(v1.dot(zAxis), -halfSize.z, halfSize.z);\n    result.add(zAxis.multiplyScalar(z));\n    return result;\n  }\n  containsPoint(point) {\n    v1.subVectors(point, this.center);\n    this.rotation.extractBasis(xAxis, yAxis, zAxis);\n    return Math.abs(v1.dot(xAxis)) <= this.halfSize.x && Math.abs(v1.dot(yAxis)) <= this.halfSize.y && Math.abs(v1.dot(zAxis)) <= this.halfSize.z;\n  }\n  intersectsBox3(box3) {\n    return this.intersectsOBB(obb.fromBox3(box3));\n  }\n  intersectsSphere(sphere) {\n    this.clampPoint(sphere.center, closestPoint);\n    return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n  }\n  /**\n   * Reference: OBB-OBB Intersection in Real-Time Collision Detection\n   * by Christer Ericson (chapter 4.4.1)\n   *\n   */\n  intersectsOBB(obb2, epsilon = Number.EPSILON) {\n    a.c = this.center;\n    a.e[0] = this.halfSize.x;\n    a.e[1] = this.halfSize.y;\n    a.e[2] = this.halfSize.z;\n    this.rotation.extractBasis(a.u[0], a.u[1], a.u[2]);\n    b.c = obb2.center;\n    b.e[0] = obb2.halfSize.x;\n    b.e[1] = obb2.halfSize.y;\n    b.e[2] = obb2.halfSize.z;\n    obb2.rotation.extractBasis(b.u[0], b.u[1], b.u[2]);\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        R[i][j] = a.u[i].dot(b.u[j]);\n      }\n    }\n    v1.subVectors(b.c, a.c);\n    t[0] = v1.dot(a.u[0]);\n    t[1] = v1.dot(a.u[1]);\n    t[2] = v1.dot(a.u[2]);\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        AbsR[i][j] = Math.abs(R[i][j]) + epsilon;\n      }\n    }\n    let ra, rb;\n    for (let i = 0; i < 3; i++) {\n      ra = a.e[i];\n      rb = b.e[0] * AbsR[i][0] + b.e[1] * AbsR[i][1] + b.e[2] * AbsR[i][2];\n      if (Math.abs(t[i]) > ra + rb) return false;\n    }\n    for (let i = 0; i < 3; i++) {\n      ra = a.e[0] * AbsR[0][i] + a.e[1] * AbsR[1][i] + a.e[2] * AbsR[2][i];\n      rb = b.e[i];\n      if (Math.abs(t[0] * R[0][i] + t[1] * R[1][i] + t[2] * R[2][i]) > ra + rb) return false;\n    }\n    ra = a.e[1] * AbsR[2][0] + a.e[2] * AbsR[1][0];\n    rb = b.e[1] * AbsR[0][2] + b.e[2] * AbsR[0][1];\n    if (Math.abs(t[2] * R[1][0] - t[1] * R[2][0]) > ra + rb) return false;\n    ra = a.e[1] * AbsR[2][1] + a.e[2] * AbsR[1][1];\n    rb = b.e[0] * AbsR[0][2] + b.e[2] * AbsR[0][0];\n    if (Math.abs(t[2] * R[1][1] - t[1] * R[2][1]) > ra + rb) return false;\n    ra = a.e[1] * AbsR[2][2] + a.e[2] * AbsR[1][2];\n    rb = b.e[0] * AbsR[0][1] + b.e[1] * AbsR[0][0];\n    if (Math.abs(t[2] * R[1][2] - t[1] * R[2][2]) > ra + rb) return false;\n    ra = a.e[0] * AbsR[2][0] + a.e[2] * AbsR[0][0];\n    rb = b.e[1] * AbsR[1][2] + b.e[2] * AbsR[1][1];\n    if (Math.abs(t[0] * R[2][0] - t[2] * R[0][0]) > ra + rb) return false;\n    ra = a.e[0] * AbsR[2][1] + a.e[2] * AbsR[0][1];\n    rb = b.e[0] * AbsR[1][2] + b.e[2] * AbsR[1][0];\n    if (Math.abs(t[0] * R[2][1] - t[2] * R[0][1]) > ra + rb) return false;\n    ra = a.e[0] * AbsR[2][2] + a.e[2] * AbsR[0][2];\n    rb = b.e[0] * AbsR[1][1] + b.e[1] * AbsR[1][0];\n    if (Math.abs(t[0] * R[2][2] - t[2] * R[0][2]) > ra + rb) return false;\n    ra = a.e[0] * AbsR[1][0] + a.e[1] * AbsR[0][0];\n    rb = b.e[1] * AbsR[2][2] + b.e[2] * AbsR[2][1];\n    if (Math.abs(t[1] * R[0][0] - t[0] * R[1][0]) > ra + rb) return false;\n    ra = a.e[0] * AbsR[1][1] + a.e[1] * AbsR[0][1];\n    rb = b.e[0] * AbsR[2][2] + b.e[2] * AbsR[2][0];\n    if (Math.abs(t[1] * R[0][1] - t[0] * R[1][1]) > ra + rb) return false;\n    ra = a.e[0] * AbsR[1][2] + a.e[1] * AbsR[0][2];\n    rb = b.e[0] * AbsR[2][1] + b.e[1] * AbsR[2][0];\n    if (Math.abs(t[1] * R[0][2] - t[0] * R[1][2]) > ra + rb) return false;\n    return true;\n  }\n  /**\n   * Reference: Testing Box Against Plane in Real-Time Collision Detection\n   * by Christer Ericson (chapter 5.2.3)\n   */\n  intersectsPlane(plane) {\n    this.rotation.extractBasis(xAxis, yAxis, zAxis);\n    const r = this.halfSize.x * Math.abs(plane.normal.dot(xAxis)) + this.halfSize.y * Math.abs(plane.normal.dot(yAxis)) + this.halfSize.z * Math.abs(plane.normal.dot(zAxis));\n    const d = plane.normal.dot(this.center) - plane.constant;\n    return Math.abs(d) <= r;\n  }\n  /**\n   * Performs a ray/OBB intersection test and stores the intersection point\n   * to the given 3D vector. If no intersection is detected, *null* is returned.\n   */\n  intersectRay(ray, result) {\n    this.getSize(size);\n    aabb.setFromCenterAndSize(v1.set(0, 0, 0), size);\n    matrix.setFromMatrix3(this.rotation);\n    matrix.setPosition(this.center);\n    inverse.copy(matrix).invert();\n    localRay.copy(ray).applyMatrix4(inverse);\n    if (localRay.intersectBox(aabb, result)) {\n      return result.applyMatrix4(matrix);\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Performs a ray/OBB intersection test. Returns either true or false if\n   * there is a intersection or not.\n   */\n  intersectsRay(ray) {\n    return this.intersectRay(ray, v1) !== null;\n  }\n  fromBox3(box3) {\n    box3.getCenter(this.center);\n    box3.getSize(this.halfSize).multiplyScalar(0.5);\n    this.rotation.identity();\n    return this;\n  }\n  equals(obb2) {\n    return obb2.center.equals(this.center) && obb2.halfSize.equals(this.halfSize) && obb2.rotation.equals(this.rotation);\n  }\n  applyMatrix4(matrix2) {\n    const e = matrix2.elements;\n    let sx = v1.set(e[0], e[1], e[2]).length();\n    const sy = v1.set(e[4], e[5], e[6]).length();\n    const sz = v1.set(e[8], e[9], e[10]).length();\n    const det = matrix2.determinant();\n    if (det < 0) sx = -sx;\n    rotationMatrix.setFromMatrix4(matrix2);\n    const invSX = 1 / sx;\n    const invSY = 1 / sy;\n    const invSZ = 1 / sz;\n    rotationMatrix.elements[0] *= invSX;\n    rotationMatrix.elements[1] *= invSX;\n    rotationMatrix.elements[2] *= invSX;\n    rotationMatrix.elements[3] *= invSY;\n    rotationMatrix.elements[4] *= invSY;\n    rotationMatrix.elements[5] *= invSY;\n    rotationMatrix.elements[6] *= invSZ;\n    rotationMatrix.elements[7] *= invSZ;\n    rotationMatrix.elements[8] *= invSZ;\n    this.rotation.multiply(rotationMatrix);\n    this.halfSize.x *= sx;\n    this.halfSize.y *= sy;\n    this.halfSize.z *= sz;\n    v1.setFromMatrixPosition(matrix2);\n    this.center.add(v1);\n    return this;\n  }\n}\nconst obb = new OBB();\nexport { OBB };\n//# sourceMappingURL=OBB.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}