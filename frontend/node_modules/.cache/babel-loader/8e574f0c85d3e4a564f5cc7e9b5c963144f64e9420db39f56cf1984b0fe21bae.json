{"ast":null,"code":"/* @license\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Euler, EventDispatcher, Matrix3, Spherical, Vector2, Vector3 } from 'three';\nimport { $panElement } from '../features/controls.js';\nimport { clamp } from '../utilities.js';\nimport { Damper, SETTLING_TIME } from './Damper.js';\nconst PAN_SENSITIVITY = 0.018;\nconst TAP_DISTANCE = 2;\nconst TAP_MS = 300;\nconst vector2 = new Vector2();\nconst vector3 = new Vector3();\nexport const DEFAULT_OPTIONS = Object.freeze({\n  minimumRadius: 0,\n  maximumRadius: Infinity,\n  minimumPolarAngle: 0,\n  maximumPolarAngle: Math.PI,\n  minimumAzimuthalAngle: -Infinity,\n  maximumAzimuthalAngle: Infinity,\n  minimumFieldOfView: 10,\n  maximumFieldOfView: 45,\n  touchAction: 'none'\n});\n// Constants\nconst KEYBOARD_ORBIT_INCREMENT = Math.PI / 8;\nconst ZOOM_SENSITIVITY = 0.04;\n// The move size on pan key event\nconst PAN_KEY_INCREMENT = 10;\nexport const KeyCode = {\n  PAGE_UP: 33,\n  PAGE_DOWN: 34,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40\n};\nexport const ChangeSource = {\n  USER_INTERACTION: 'user-interaction',\n  NONE: 'none',\n  AUTOMATIC: 'automatic'\n};\n/**\n * SmoothControls is a Three.js helper for adding delightful pointer and\n * keyboard-based input to a staged Three.js scene. Its API is very similar to\n * OrbitControls, but it offers more opinionated (subjectively more delightful)\n * defaults, easy extensibility and subjectively better out-of-the-box keyboard\n * support.\n *\n * One important change compared to OrbitControls is that the `update` method\n * of SmoothControls must be invoked on every frame, otherwise the controls\n * will not have an effect.\n *\n * Another notable difference compared to OrbitControls is that SmoothControls\n * does not currently support panning (but probably will in a future revision).\n *\n * Like OrbitControls, SmoothControls assumes that the orientation of the camera\n * has been set in terms of position, rotation and scale, so it is important to\n * ensure that the camera's matrixWorld is in sync before using SmoothControls.\n */\nexport class SmoothControls extends EventDispatcher {\n  constructor(camera, element, scene) {\n    super();\n    this.camera = camera;\n    this.element = element;\n    this.scene = scene;\n    this.orbitSensitivity = 1;\n    this.zoomSensitivity = 1;\n    this.panSensitivity = 1;\n    this.inputSensitivity = 1;\n    this.changeSource = ChangeSource.NONE;\n    this._interactionEnabled = false;\n    this._disableZoom = false;\n    this.isUserPointing = false;\n    // Pan state\n    this.enablePan = true;\n    this.enableTap = true;\n    this.panProjection = new Matrix3();\n    this.panPerPixel = 0;\n    // Internal orbital position state\n    this.spherical = new Spherical();\n    this.goalSpherical = new Spherical();\n    this.thetaDamper = new Damper();\n    this.phiDamper = new Damper();\n    this.radiusDamper = new Damper();\n    this.logFov = Math.log(DEFAULT_OPTIONS.maximumFieldOfView);\n    this.goalLogFov = this.logFov;\n    this.fovDamper = new Damper();\n    // Pointer state\n    this.touchMode = null;\n    this.pointers = [];\n    this.startTime = 0;\n    this.startPointerPosition = {\n      clientX: 0,\n      clientY: 0\n    };\n    this.lastSeparation = 0;\n    this.touchDecided = false;\n    this.onContext = event => {\n      if (this.enablePan) {\n        event.preventDefault();\n      } else {\n        for (const pointer of this.pointers) {\n          // Required because of a common browser bug where the context menu never\n          // fires a pointercancel event.\n          this.onPointerUp(new PointerEvent('pointercancel', Object.assign(Object.assign({}, this.startPointerPosition), {\n            pointerId: pointer.id\n          })));\n        }\n      }\n    };\n    this.touchModeZoom = (dx, dy) => {\n      if (!this._disableZoom) {\n        const touchDistance = this.twoTouchDistance(this.pointers[0], this.pointers[1]);\n        const deltaZoom = ZOOM_SENSITIVITY * this.zoomSensitivity * (this.lastSeparation - touchDistance) * 50 / this.scene.height;\n        this.lastSeparation = touchDistance;\n        this.userAdjustOrbit(0, 0, deltaZoom);\n      }\n      if (this.panPerPixel > 0) {\n        this.movePan(dx, dy);\n      }\n    };\n    // We implement our own version of the browser's CSS touch-action, enforced by\n    // this function, because the iOS implementation of pan-y is bad and doesn't\n    // match Android. Specifically, even if a touch gesture begins by panning X,\n    // iOS will switch to scrolling as soon as the gesture moves in the Y, rather\n    // than staying in the same mode until the end of the gesture.\n    this.disableScroll = event => {\n      event.preventDefault();\n    };\n    this.touchModeRotate = (dx, dy) => {\n      const {\n        touchAction\n      } = this._options;\n      if (!this.touchDecided && touchAction !== 'none') {\n        this.touchDecided = true;\n        const dxMag = Math.abs(dx);\n        const dyMag = Math.abs(dy);\n        // If motion is mostly vertical, assume scrolling is the intent.\n        if (this.changeSource === ChangeSource.USER_INTERACTION && (touchAction === 'pan-y' && dyMag > dxMag || touchAction === 'pan-x' && dxMag > dyMag)) {\n          this.touchMode = null;\n          return;\n        } else {\n          this.element.addEventListener('touchmove', this.disableScroll, {\n            passive: false\n          });\n        }\n      }\n      this.handleSinglePointerMove(dx, dy);\n    };\n    this.onPointerDown = event => {\n      if (this.pointers.length > 2) {\n        return;\n      }\n      const {\n        element\n      } = this;\n      if (this.pointers.length === 0) {\n        element.addEventListener('pointermove', this.onPointerMove);\n        element.addEventListener('pointerup', this.onPointerUp);\n        this.touchMode = null;\n        this.touchDecided = false;\n        this.startPointerPosition.clientX = event.clientX;\n        this.startPointerPosition.clientY = event.clientY;\n        this.startTime = performance.now();\n      }\n      try {\n        element.setPointerCapture(event.pointerId);\n      } catch (_a) {}\n      this.pointers.push({\n        clientX: event.clientX,\n        clientY: event.clientY,\n        id: event.pointerId\n      });\n      this.isUserPointing = false;\n      if (event.pointerType === 'touch') {\n        this.changeSource = event.altKey ?\n        // set by interact() in controls.ts\n        ChangeSource.AUTOMATIC : ChangeSource.USER_INTERACTION;\n        this.onTouchChange(event);\n      } else {\n        this.changeSource = ChangeSource.USER_INTERACTION;\n        this.onMouseDown(event);\n      }\n      if (this.changeSource === ChangeSource.USER_INTERACTION) {\n        this.dispatchEvent({\n          type: 'user-interaction'\n        });\n      }\n    };\n    this.onPointerMove = event => {\n      const pointer = this.pointers.find(pointer => pointer.id === event.pointerId);\n      if (pointer == null) {\n        return;\n      }\n      // In case no one gave us a pointerup or pointercancel event.\n      if (event.pointerType === 'mouse' && event.buttons === 0) {\n        this.onPointerUp(event);\n        return;\n      }\n      const numTouches = this.pointers.length;\n      const dx = (event.clientX - pointer.clientX) / numTouches;\n      const dy = (event.clientY - pointer.clientY) / numTouches;\n      if (dx === 0 && dy === 0) {\n        return;\n      }\n      pointer.clientX = event.clientX;\n      pointer.clientY = event.clientY;\n      if (event.pointerType === 'touch') {\n        this.changeSource = event.altKey ?\n        // set by interact() in controls.ts\n        ChangeSource.AUTOMATIC : ChangeSource.USER_INTERACTION;\n        if (this.touchMode !== null) {\n          this.touchMode(dx, dy);\n        }\n      } else {\n        this.changeSource = ChangeSource.USER_INTERACTION;\n        if (this.panPerPixel > 0) {\n          this.movePan(dx, dy);\n        } else {\n          this.handleSinglePointerMove(dx, dy);\n        }\n      }\n    };\n    this.onPointerUp = event => {\n      const {\n        element\n      } = this;\n      const index = this.pointers.findIndex(pointer => pointer.id === event.pointerId);\n      if (index !== -1) {\n        this.pointers.splice(index, 1);\n      }\n      // altKey indicates an interaction prompt; don't reset radius in this case\n      // as it will cause the camera to drift.\n      if (this.panPerPixel > 0 && !event.altKey) {\n        this.resetRadius();\n      }\n      if (this.pointers.length === 0) {\n        element.removeEventListener('pointermove', this.onPointerMove);\n        element.removeEventListener('pointerup', this.onPointerUp);\n        element.removeEventListener('touchmove', this.disableScroll);\n        if (this.enablePan && this.enableTap) {\n          this.recenter(event);\n        }\n      } else if (this.touchMode !== null) {\n        this.onTouchChange(event);\n      }\n      this.scene.element[$panElement].style.opacity = 0;\n      element.style.cursor = 'grab';\n      this.panPerPixel = 0;\n      if (this.isUserPointing) {\n        this.dispatchEvent({\n          type: 'pointer-change-end'\n        });\n      }\n    };\n    this.onWheel = event => {\n      this.changeSource = ChangeSource.USER_INTERACTION;\n      const deltaZoom = event.deltaY * (event.deltaMode == 1 ? 18 : 1) * ZOOM_SENSITIVITY * this.zoomSensitivity / 30;\n      this.userAdjustOrbit(0, 0, deltaZoom);\n      event.preventDefault();\n      this.dispatchEvent({\n        type: 'user-interaction'\n      });\n    };\n    this.onKeyDown = event => {\n      // We track if the key is actually one we respond to, so as not to\n      // accidentally clobber unrelated key inputs when the <model-viewer> has\n      // focus.\n      const {\n        changeSource\n      } = this;\n      this.changeSource = ChangeSource.USER_INTERACTION;\n      const relevantKey = event.shiftKey && this.enablePan ? this.panKeyCodeHandler(event) : this.orbitZoomKeyCodeHandler(event);\n      if (relevantKey) {\n        event.preventDefault();\n        this.dispatchEvent({\n          type: 'user-interaction'\n        });\n      } else {\n        this.changeSource = changeSource;\n      }\n    };\n    this._options = Object.assign({}, DEFAULT_OPTIONS);\n    this.setOrbit(0, Math.PI / 2, 1);\n    this.setFieldOfView(100);\n    this.jumpToGoal();\n  }\n  get interactionEnabled() {\n    return this._interactionEnabled;\n  }\n  enableInteraction() {\n    if (this._interactionEnabled === false) {\n      const {\n        element\n      } = this;\n      element.addEventListener('pointerdown', this.onPointerDown);\n      element.addEventListener('pointercancel', this.onPointerUp);\n      if (!this._disableZoom) {\n        element.addEventListener('wheel', this.onWheel);\n      }\n      element.addEventListener('keydown', this.onKeyDown);\n      // This little beauty is to work around a WebKit bug that otherwise makes\n      // touch events randomly not cancelable.\n      element.addEventListener('touchmove', () => {}, {\n        passive: false\n      });\n      element.addEventListener('contextmenu', this.onContext);\n      this.element.style.cursor = 'grab';\n      this._interactionEnabled = true;\n      this.updateTouchActionStyle();\n    }\n  }\n  disableInteraction() {\n    if (this._interactionEnabled === true) {\n      const {\n        element\n      } = this;\n      element.removeEventListener('pointerdown', this.onPointerDown);\n      element.removeEventListener('pointermove', this.onPointerMove);\n      element.removeEventListener('pointerup', this.onPointerUp);\n      element.removeEventListener('pointercancel', this.onPointerUp);\n      element.removeEventListener('wheel', this.onWheel);\n      element.removeEventListener('keydown', this.onKeyDown);\n      element.removeEventListener('contextmenu', this.onContext);\n      element.style.cursor = '';\n      this.touchMode = null;\n      this._interactionEnabled = false;\n      this.updateTouchActionStyle();\n    }\n  }\n  /**\n   * The options that are currently configured for the controls instance.\n   */\n  get options() {\n    return this._options;\n  }\n  set disableZoom(disable) {\n    if (this._disableZoom != disable) {\n      this._disableZoom = disable;\n      if (disable === true) {\n        this.element.removeEventListener('wheel', this.onWheel);\n      } else {\n        this.element.addEventListener('wheel', this.onWheel);\n      }\n      this.updateTouchActionStyle();\n    }\n  }\n  /**\n   * Copy the spherical values that represent the current camera orbital\n   * position relative to the configured target into a provided Spherical\n   * instance. If no Spherical is provided, a new Spherical will be allocated\n   * to copy the values into. The Spherical that values are copied into is\n   * returned.\n   */\n  getCameraSpherical(target = new Spherical()) {\n    return target.copy(this.spherical);\n  }\n  /**\n   * Returns the camera's current vertical field of view in degrees.\n   */\n  getFieldOfView() {\n    return this.camera.fov;\n  }\n  /**\n   * Configure the _options of the controls. Configured _options will be\n   * merged with whatever _options have already been configured for this\n   * controls instance.\n   */\n  applyOptions(_options) {\n    Object.assign(this._options, _options);\n    // Re-evaluates clamping based on potentially new values for min/max\n    // polar, azimuth and radius:\n    this.setOrbit();\n    this.setFieldOfView(Math.exp(this.goalLogFov));\n  }\n  /**\n   * Sets the near and far planes of the camera.\n   */\n  updateNearFar(nearPlane, farPlane) {\n    this.camera.far = farPlane === 0 ? 2 : farPlane;\n    this.camera.near = Math.max(nearPlane, this.camera.far / 1000);\n    this.camera.updateProjectionMatrix();\n  }\n  /**\n   * Sets the aspect ratio of the camera\n   */\n  updateAspect(aspect) {\n    this.camera.aspect = aspect;\n    this.camera.updateProjectionMatrix();\n  }\n  /**\n   * Set the absolute orbital goal of the camera. The change will be\n   * applied over a number of frames depending on configured acceleration and\n   * dampening _options.\n   *\n   * Returns true if invoking the method will result in the camera changing\n   * position and/or rotation, otherwise false.\n   */\n  setOrbit(goalTheta = this.goalSpherical.theta, goalPhi = this.goalSpherical.phi, goalRadius = this.goalSpherical.radius) {\n    const {\n      minimumAzimuthalAngle,\n      maximumAzimuthalAngle,\n      minimumPolarAngle,\n      maximumPolarAngle,\n      minimumRadius,\n      maximumRadius\n    } = this._options;\n    const {\n      theta,\n      phi,\n      radius\n    } = this.goalSpherical;\n    const nextTheta = clamp(goalTheta, minimumAzimuthalAngle, maximumAzimuthalAngle);\n    if (!isFinite(minimumAzimuthalAngle) && !isFinite(maximumAzimuthalAngle)) {\n      this.spherical.theta = this.wrapAngle(this.spherical.theta - nextTheta) + nextTheta;\n    }\n    const nextPhi = clamp(goalPhi, minimumPolarAngle, maximumPolarAngle);\n    const nextRadius = clamp(goalRadius, minimumRadius, maximumRadius);\n    if (nextTheta === theta && nextPhi === phi && nextRadius === radius) {\n      return false;\n    }\n    if (!isFinite(nextTheta) || !isFinite(nextPhi) || !isFinite(nextRadius)) {\n      return false;\n    }\n    this.goalSpherical.theta = nextTheta;\n    this.goalSpherical.phi = nextPhi;\n    this.goalSpherical.radius = nextRadius;\n    this.goalSpherical.makeSafe();\n    return true;\n  }\n  /**\n   * Subset of setOrbit() above, which only sets the camera's radius.\n   */\n  setRadius(radius) {\n    this.goalSpherical.radius = radius;\n    this.setOrbit();\n  }\n  /**\n   * Sets the goal field of view for the camera\n   */\n  setFieldOfView(fov) {\n    const {\n      minimumFieldOfView,\n      maximumFieldOfView\n    } = this._options;\n    fov = clamp(fov, minimumFieldOfView, maximumFieldOfView);\n    this.goalLogFov = Math.log(fov);\n  }\n  /**\n   * Sets the smoothing decay time.\n   */\n  setDamperDecayTime(decayMilliseconds) {\n    this.thetaDamper.setDecayTime(decayMilliseconds);\n    this.phiDamper.setDecayTime(decayMilliseconds);\n    this.radiusDamper.setDecayTime(decayMilliseconds);\n    this.fovDamper.setDecayTime(decayMilliseconds);\n  }\n  /**\n   * Adjust the orbital position of the camera relative to its current orbital\n   * position. Does not let the theta goal get more than pi ahead of the current\n   * theta, which ensures interpolation continues in the direction of the delta.\n   * The deltaZoom parameter adjusts both the field of view and the orbit radius\n   * such that they progress across their allowed ranges in sync.\n   */\n  adjustOrbit(deltaTheta, deltaPhi, deltaZoom) {\n    const {\n      theta,\n      phi,\n      radius\n    } = this.goalSpherical;\n    const {\n      minimumRadius,\n      maximumRadius,\n      minimumFieldOfView,\n      maximumFieldOfView\n    } = this._options;\n    const dTheta = this.spherical.theta - theta;\n    const dThetaLimit = Math.PI - 0.001;\n    const goalTheta = theta - clamp(deltaTheta, -dThetaLimit - dTheta, dThetaLimit - dTheta);\n    const goalPhi = phi - deltaPhi;\n    const deltaRatio = deltaZoom === 0 ? 0 : ((deltaZoom > 0 ? maximumRadius : minimumRadius) - radius) / (Math.log(deltaZoom > 0 ? maximumFieldOfView : minimumFieldOfView) - this.goalLogFov);\n    const goalRadius = radius + deltaZoom * (isFinite(deltaRatio) ? deltaRatio : (maximumRadius - minimumRadius) * 2);\n    this.setOrbit(goalTheta, goalPhi, goalRadius);\n    if (deltaZoom !== 0) {\n      const goalLogFov = this.goalLogFov + deltaZoom;\n      this.setFieldOfView(Math.exp(goalLogFov));\n    }\n  }\n  /**\n   * Move the camera instantly instead of accelerating toward the goal\n   * parameters.\n   */\n  jumpToGoal() {\n    this.update(0, SETTLING_TIME);\n  }\n  /**\n   * Update controls. In most cases, this will result in the camera\n   * interpolating its position and rotation until it lines up with the\n   * designated goal orbital position. Returns false if the camera did not move.\n   *\n   * Time and delta are measured in milliseconds.\n   */\n  update(_time, delta) {\n    if (this.isStationary()) {\n      return false;\n    }\n    const {\n      maximumPolarAngle,\n      maximumRadius\n    } = this._options;\n    const dTheta = this.spherical.theta - this.goalSpherical.theta;\n    if (Math.abs(dTheta) > Math.PI && !isFinite(this._options.minimumAzimuthalAngle) && !isFinite(this._options.maximumAzimuthalAngle)) {\n      this.spherical.theta -= Math.sign(dTheta) * 2 * Math.PI;\n    }\n    this.spherical.theta = this.thetaDamper.update(this.spherical.theta, this.goalSpherical.theta, delta, Math.PI);\n    this.spherical.phi = this.phiDamper.update(this.spherical.phi, this.goalSpherical.phi, delta, maximumPolarAngle);\n    this.spherical.radius = this.radiusDamper.update(this.spherical.radius, this.goalSpherical.radius, delta, maximumRadius);\n    this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, delta, 1);\n    this.moveCamera();\n    return true;\n  }\n  updateTouchActionStyle() {\n    const {\n      style\n    } = this.element;\n    if (this._interactionEnabled) {\n      const {\n        touchAction\n      } = this._options;\n      if (this._disableZoom && touchAction !== 'none') {\n        style.touchAction = 'manipulation';\n      } else {\n        style.touchAction = touchAction;\n      }\n    } else {\n      style.touchAction = '';\n    }\n  }\n  isStationary() {\n    return this.goalSpherical.theta === this.spherical.theta && this.goalSpherical.phi === this.spherical.phi && this.goalSpherical.radius === this.spherical.radius && this.goalLogFov === this.logFov;\n  }\n  moveCamera() {\n    // Derive the new camera position from the updated spherical:\n    this.spherical.makeSafe();\n    this.camera.position.setFromSpherical(this.spherical);\n    this.camera.setRotationFromEuler(new Euler(this.spherical.phi - Math.PI / 2, this.spherical.theta, 0, 'YXZ'));\n    if (this.camera.fov !== Math.exp(this.logFov)) {\n      this.camera.fov = Math.exp(this.logFov);\n      this.camera.updateProjectionMatrix();\n    }\n  }\n  userAdjustOrbit(deltaTheta, deltaPhi, deltaZoom) {\n    this.adjustOrbit(deltaTheta * this.orbitSensitivity * this.inputSensitivity, deltaPhi * this.orbitSensitivity * this.inputSensitivity, deltaZoom * this.inputSensitivity);\n  }\n  // Wraps to between -pi and pi\n  wrapAngle(radians) {\n    const normalized = (radians + Math.PI) / (2 * Math.PI);\n    const wrapped = normalized - Math.floor(normalized);\n    return wrapped * 2 * Math.PI - Math.PI;\n  }\n  pixelLengthToSphericalAngle(pixelLength) {\n    return 2 * Math.PI * pixelLength / this.scene.height;\n  }\n  twoTouchDistance(touchOne, touchTwo) {\n    const {\n      clientX: xOne,\n      clientY: yOne\n    } = touchOne;\n    const {\n      clientX: xTwo,\n      clientY: yTwo\n    } = touchTwo;\n    const xDelta = xTwo - xOne;\n    const yDelta = yTwo - yOne;\n    return Math.sqrt(xDelta * xDelta + yDelta * yDelta);\n  }\n  handleSinglePointerMove(dx, dy) {\n    const deltaTheta = this.pixelLengthToSphericalAngle(dx);\n    const deltaPhi = this.pixelLengthToSphericalAngle(dy);\n    if (this.isUserPointing === false) {\n      this.isUserPointing = true;\n      this.dispatchEvent({\n        type: 'pointer-change-start'\n      });\n    }\n    this.userAdjustOrbit(deltaTheta, deltaPhi, 0);\n  }\n  initializePan() {\n    const {\n      theta,\n      phi\n    } = this.spherical;\n    const psi = theta - this.scene.yaw;\n    this.panPerPixel = PAN_SENSITIVITY * this.panSensitivity / this.scene.height;\n    this.panProjection.set(-Math.cos(psi), -Math.cos(phi) * Math.sin(psi), 0, 0, Math.sin(phi), 0, Math.sin(psi), -Math.cos(phi) * Math.cos(psi), 0);\n  }\n  movePan(dx, dy) {\n    const {\n      scene\n    } = this;\n    const dxy = vector3.set(dx, dy, 0).multiplyScalar(this.inputSensitivity);\n    const metersPerPixel = this.spherical.radius * Math.exp(this.logFov) * this.panPerPixel;\n    dxy.multiplyScalar(metersPerPixel);\n    const target = scene.getTarget();\n    target.add(dxy.applyMatrix3(this.panProjection));\n    scene.boundingSphere.clampPoint(target, target);\n    scene.setTarget(target.x, target.y, target.z);\n  }\n  recenter(pointer) {\n    if (performance.now() > this.startTime + TAP_MS || Math.abs(pointer.clientX - this.startPointerPosition.clientX) > TAP_DISTANCE || Math.abs(pointer.clientY - this.startPointerPosition.clientY) > TAP_DISTANCE) {\n      return;\n    }\n    const {\n      scene\n    } = this;\n    const hit = scene.positionAndNormalFromPoint(scene.getNDC(pointer.clientX, pointer.clientY));\n    if (hit == null) {\n      const {\n        cameraTarget\n      } = scene.element;\n      scene.element.cameraTarget = '';\n      scene.element.cameraTarget = cameraTarget;\n      // Zoom all the way out.\n      this.userAdjustOrbit(0, 0, 1);\n    } else {\n      scene.target.worldToLocal(hit.position);\n      scene.setTarget(hit.position.x, hit.position.y, hit.position.z);\n    }\n  }\n  resetRadius() {\n    const {\n      scene\n    } = this;\n    const hit = scene.positionAndNormalFromPoint(vector2.set(0, 0));\n    if (hit == null) {\n      return;\n    }\n    scene.target.worldToLocal(hit.position);\n    const goalTarget = scene.getTarget();\n    const {\n      theta,\n      phi\n    } = this.spherical;\n    // Set target to surface hit point, except the target is still settling,\n    // so offset the goal accordingly so the transition is smooth even though\n    // this will drift the target slightly away from the hit point.\n    const psi = theta - scene.yaw;\n    const n = vector3.set(Math.sin(phi) * Math.sin(psi), Math.cos(phi), Math.sin(phi) * Math.cos(psi));\n    const dr = n.dot(hit.position.sub(goalTarget));\n    goalTarget.add(n.multiplyScalar(dr));\n    scene.setTarget(goalTarget.x, goalTarget.y, goalTarget.z);\n    // Change the camera radius to match the change in target so that the\n    // camera itself does not move, unless it hits a radius bound.\n    this.setOrbit(undefined, undefined, this.goalSpherical.radius - dr);\n  }\n  onTouchChange(event) {\n    if (this.pointers.length === 1) {\n      this.touchMode = this.touchModeRotate;\n    } else {\n      if (this._disableZoom) {\n        this.touchMode = null;\n        this.element.removeEventListener('touchmove', this.disableScroll);\n        return;\n      }\n      this.touchMode = this.touchDecided && this.touchMode === null ? null : this.touchModeZoom;\n      this.touchDecided = true;\n      this.element.addEventListener('touchmove', this.disableScroll, {\n        passive: false\n      });\n      this.lastSeparation = this.twoTouchDistance(this.pointers[0], this.pointers[1]);\n      if (this.enablePan && this.touchMode != null) {\n        this.initializePan();\n        if (!event.altKey) {\n          // user interaction, not prompt\n          this.scene.element[$panElement].style.opacity = 1;\n        }\n      }\n    }\n  }\n  onMouseDown(event) {\n    this.panPerPixel = 0;\n    if (this.enablePan && (event.button === 2 || event.ctrlKey || event.metaKey || event.shiftKey)) {\n      this.initializePan();\n      this.scene.element[$panElement].style.opacity = 1;\n    }\n    this.element.style.cursor = 'grabbing';\n  }\n  /**\n   * Handles the orbit and Zoom key presses\n   * Uses constants for the increment.\n   * @param event The keyboard event for the .key value\n   * @returns boolean to indicate if the key event has been handled\n   */\n  orbitZoomKeyCodeHandler(event) {\n    let relevantKey = true;\n    switch (event.key) {\n      case 'PageUp':\n        this.userAdjustOrbit(0, 0, ZOOM_SENSITIVITY * this.zoomSensitivity);\n        break;\n      case 'PageDown':\n        this.userAdjustOrbit(0, 0, -1 * ZOOM_SENSITIVITY * this.zoomSensitivity);\n        break;\n      case 'ArrowUp':\n        this.userAdjustOrbit(0, -KEYBOARD_ORBIT_INCREMENT, 0);\n        break;\n      case 'ArrowDown':\n        this.userAdjustOrbit(0, KEYBOARD_ORBIT_INCREMENT, 0);\n        break;\n      case 'ArrowLeft':\n        this.userAdjustOrbit(-KEYBOARD_ORBIT_INCREMENT, 0, 0);\n        break;\n      case 'ArrowRight':\n        this.userAdjustOrbit(KEYBOARD_ORBIT_INCREMENT, 0, 0);\n        break;\n      default:\n        relevantKey = false;\n        break;\n    }\n    return relevantKey;\n  }\n  /**\n   * Handles the Pan key presses\n   * Uses constants for the increment.\n   * @param event The keyboard event for the .key value\n   * @returns boolean to indicate if the key event has been handled\n   */\n  panKeyCodeHandler(event) {\n    this.initializePan();\n    let relevantKey = true;\n    switch (event.key) {\n      case 'ArrowUp':\n        this.movePan(0, -1 * PAN_KEY_INCREMENT); // This is the negative one so that the\n        // model appears to move as the arrow\n        // direction rather than the view moving\n        break;\n      case 'ArrowDown':\n        this.movePan(0, PAN_KEY_INCREMENT);\n        break;\n      case 'ArrowLeft':\n        this.movePan(-1 * PAN_KEY_INCREMENT, 0);\n        break;\n      case 'ArrowRight':\n        this.movePan(PAN_KEY_INCREMENT, 0);\n        break;\n      default:\n        relevantKey = false;\n        break;\n    }\n    return relevantKey;\n  }\n}\n//# sourceMappingURL=SmoothControls.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}