{"ast":null,"code":"import { Vector3, Color, Vector2, Vector4, Box3, Matrix4, Frustum, Matrix3, DoubleSide } from \"three\";\nclass RenderableObject {\n  constructor() {\n    this.id = 0;\n    this.object = null;\n    this.z = 0;\n    this.renderOrder = 0;\n  }\n}\nclass RenderableFace {\n  constructor() {\n    this.id = 0;\n    this.v1 = new RenderableVertex();\n    this.v2 = new RenderableVertex();\n    this.v3 = new RenderableVertex();\n    this.normalModel = new Vector3();\n    this.vertexNormalsModel = [new Vector3(), new Vector3(), new Vector3()];\n    this.vertexNormalsLength = 0;\n    this.color = new Color();\n    this.material = null;\n    this.uvs = [new Vector2(), new Vector2(), new Vector2()];\n    this.z = 0;\n    this.renderOrder = 0;\n  }\n}\nclass RenderableVertex {\n  constructor() {\n    this.position = new Vector3();\n    this.positionWorld = new Vector3();\n    this.positionScreen = new Vector4();\n    this.visible = true;\n  }\n  copy(vertex) {\n    this.positionWorld.copy(vertex.positionWorld);\n    this.positionScreen.copy(vertex.positionScreen);\n  }\n}\nclass RenderableLine {\n  constructor() {\n    this.id = 0;\n    this.v1 = new RenderableVertex();\n    this.v2 = new RenderableVertex();\n    this.vertexColors = [new Color(), new Color()];\n    this.material = null;\n    this.z = 0;\n    this.renderOrder = 0;\n  }\n}\nclass RenderableSprite {\n  constructor() {\n    this.id = 0;\n    this.object = null;\n    this.x = 0;\n    this.y = 0;\n    this.z = 0;\n    this.rotation = 0;\n    this.scale = new Vector2();\n    this.material = null;\n    this.renderOrder = 0;\n  }\n}\nclass Projector {\n  constructor() {\n    let _object,\n      _objectCount,\n      _objectPoolLength = 0,\n      _vertex,\n      _vertexCount,\n      _vertexPoolLength = 0,\n      _face,\n      _faceCount,\n      _facePoolLength = 0,\n      _line,\n      _lineCount,\n      _linePoolLength = 0,\n      _sprite,\n      _spriteCount,\n      _spritePoolLength = 0,\n      _modelMatrix;\n    const _renderData = {\n        objects: [],\n        lights: [],\n        elements: []\n      },\n      _vector3 = new Vector3(),\n      _vector4 = new Vector4(),\n      _clipBox = new Box3(new Vector3(-1, -1, -1), new Vector3(1, 1, 1)),\n      _boundingBox = new Box3(),\n      _points3 = new Array(3),\n      _viewMatrix = new Matrix4(),\n      _viewProjectionMatrix = new Matrix4(),\n      _modelViewProjectionMatrix = new Matrix4(),\n      _frustum = new Frustum(),\n      _objectPool = [],\n      _vertexPool = [],\n      _facePool = [],\n      _linePool = [],\n      _spritePool = [];\n    function RenderList() {\n      const normals = [];\n      const colors = [];\n      const uvs = [];\n      let object = null;\n      const normalMatrix = new Matrix3();\n      function setObject(value) {\n        object = value;\n        normalMatrix.getNormalMatrix(object.matrixWorld);\n        normals.length = 0;\n        colors.length = 0;\n        uvs.length = 0;\n      }\n      function projectVertex(vertex) {\n        const position = vertex.position;\n        const positionWorld = vertex.positionWorld;\n        const positionScreen = vertex.positionScreen;\n        positionWorld.copy(position).applyMatrix4(_modelMatrix);\n        positionScreen.copy(positionWorld).applyMatrix4(_viewProjectionMatrix);\n        const invW = 1 / positionScreen.w;\n        positionScreen.x *= invW;\n        positionScreen.y *= invW;\n        positionScreen.z *= invW;\n        vertex.visible = positionScreen.x >= -1 && positionScreen.x <= 1 && positionScreen.y >= -1 && positionScreen.y <= 1 && positionScreen.z >= -1 && positionScreen.z <= 1;\n      }\n      function pushVertex(x, y, z) {\n        _vertex = getNextVertexInPool();\n        _vertex.position.set(x, y, z);\n        projectVertex(_vertex);\n      }\n      function pushNormal(x, y, z) {\n        normals.push(x, y, z);\n      }\n      function pushColor(r, g, b) {\n        colors.push(r, g, b);\n      }\n      function pushUv(x, y) {\n        uvs.push(x, y);\n      }\n      function checkTriangleVisibility(v1, v2, v3) {\n        if (v1.visible === true || v2.visible === true || v3.visible === true) return true;\n        _points3[0] = v1.positionScreen;\n        _points3[1] = v2.positionScreen;\n        _points3[2] = v3.positionScreen;\n        return _clipBox.intersectsBox(_boundingBox.setFromPoints(_points3));\n      }\n      function checkBackfaceCulling(v1, v2, v3) {\n        return (v3.positionScreen.x - v1.positionScreen.x) * (v2.positionScreen.y - v1.positionScreen.y) - (v3.positionScreen.y - v1.positionScreen.y) * (v2.positionScreen.x - v1.positionScreen.x) < 0;\n      }\n      function pushLine(a, b) {\n        const v1 = _vertexPool[a];\n        const v2 = _vertexPool[b];\n        v1.positionScreen.copy(v1.position).applyMatrix4(_modelViewProjectionMatrix);\n        v2.positionScreen.copy(v2.position).applyMatrix4(_modelViewProjectionMatrix);\n        if (clipLine(v1.positionScreen, v2.positionScreen) === true) {\n          v1.positionScreen.multiplyScalar(1 / v1.positionScreen.w);\n          v2.positionScreen.multiplyScalar(1 / v2.positionScreen.w);\n          _line = getNextLineInPool();\n          _line.id = object.id;\n          _line.v1.copy(v1);\n          _line.v2.copy(v2);\n          _line.z = Math.max(v1.positionScreen.z, v2.positionScreen.z);\n          _line.renderOrder = object.renderOrder;\n          _line.material = object.material;\n          if (object.material.vertexColors) {\n            _line.vertexColors[0].fromArray(colors, a * 3);\n            _line.vertexColors[1].fromArray(colors, b * 3);\n          }\n          _renderData.elements.push(_line);\n        }\n      }\n      function pushTriangle(a, b, c, material) {\n        const v1 = _vertexPool[a];\n        const v2 = _vertexPool[b];\n        const v3 = _vertexPool[c];\n        if (checkTriangleVisibility(v1, v2, v3) === false) return;\n        if (material.side === DoubleSide || checkBackfaceCulling(v1, v2, v3) === true) {\n          _face = getNextFaceInPool();\n          _face.id = object.id;\n          _face.v1.copy(v1);\n          _face.v2.copy(v2);\n          _face.v3.copy(v3);\n          _face.z = (v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z) / 3;\n          _face.renderOrder = object.renderOrder;\n          _vector3.subVectors(v3.position, v2.position);\n          _vector4.subVectors(v1.position, v2.position);\n          _vector3.cross(_vector4);\n          _face.normalModel.copy(_vector3);\n          _face.normalModel.applyMatrix3(normalMatrix).normalize();\n          for (let i = 0; i < 3; i++) {\n            const normal = _face.vertexNormalsModel[i];\n            normal.fromArray(normals, arguments[i] * 3);\n            normal.applyMatrix3(normalMatrix).normalize();\n            const uv = _face.uvs[i];\n            uv.fromArray(uvs, arguments[i] * 2);\n          }\n          _face.vertexNormalsLength = 3;\n          _face.material = material;\n          if (material.vertexColors) {\n            _face.color.fromArray(colors, a * 3);\n          }\n          _renderData.elements.push(_face);\n        }\n      }\n      return {\n        setObject,\n        projectVertex,\n        checkTriangleVisibility,\n        checkBackfaceCulling,\n        pushVertex,\n        pushNormal,\n        pushColor,\n        pushUv,\n        pushLine,\n        pushTriangle\n      };\n    }\n    const renderList = new RenderList();\n    function projectObject(object) {\n      if (object.visible === false) return;\n      if (object.isLight) {\n        _renderData.lights.push(object);\n      } else if (object.isMesh || object.isLine || object.isPoints) {\n        if (object.material.visible === false) return;\n        if (object.frustumCulled === true && _frustum.intersectsObject(object) === false) return;\n        addObject(object);\n      } else if (object.isSprite) {\n        if (object.material.visible === false) return;\n        if (object.frustumCulled === true && _frustum.intersectsSprite(object) === false) return;\n        addObject(object);\n      }\n      const children = object.children;\n      for (let i = 0, l = children.length; i < l; i++) {\n        projectObject(children[i]);\n      }\n    }\n    function addObject(object) {\n      _object = getNextObjectInPool();\n      _object.id = object.id;\n      _object.object = object;\n      _vector3.setFromMatrixPosition(object.matrixWorld);\n      _vector3.applyMatrix4(_viewProjectionMatrix);\n      _object.z = _vector3.z;\n      _object.renderOrder = object.renderOrder;\n      _renderData.objects.push(_object);\n    }\n    this.projectScene = function (scene, camera, sortObjects, sortElements) {\n      _faceCount = 0;\n      _lineCount = 0;\n      _spriteCount = 0;\n      _renderData.elements.length = 0;\n      if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();\n      if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();\n      _viewMatrix.copy(camera.matrixWorldInverse);\n      _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);\n      _frustum.setFromProjectionMatrix(_viewProjectionMatrix);\n      _objectCount = 0;\n      _renderData.objects.length = 0;\n      _renderData.lights.length = 0;\n      projectObject(scene);\n      if (sortObjects === true) {\n        _renderData.objects.sort(painterSort);\n      }\n      const objects = _renderData.objects;\n      for (let o = 0, ol = objects.length; o < ol; o++) {\n        const object = objects[o].object;\n        const geometry = object.geometry;\n        renderList.setObject(object);\n        _modelMatrix = object.matrixWorld;\n        _vertexCount = 0;\n        if (object.isMesh) {\n          let material = object.material;\n          const isMultiMaterial = Array.isArray(material);\n          const attributes = geometry.attributes;\n          const groups = geometry.groups;\n          if (attributes.position === void 0) continue;\n          const positions = attributes.position.array;\n          for (let i = 0, l = positions.length; i < l; i += 3) {\n            let x = positions[i];\n            let y = positions[i + 1];\n            let z = positions[i + 2];\n            const morphTargets = geometry.morphAttributes.position;\n            if (morphTargets !== void 0) {\n              const morphTargetsRelative = geometry.morphTargetsRelative;\n              const morphInfluences = object.morphTargetInfluences;\n              for (let t = 0, tl = morphTargets.length; t < tl; t++) {\n                const influence = morphInfluences[t];\n                if (influence === 0) continue;\n                const target = morphTargets[t];\n                if (morphTargetsRelative) {\n                  x += target.getX(i / 3) * influence;\n                  y += target.getY(i / 3) * influence;\n                  z += target.getZ(i / 3) * influence;\n                } else {\n                  x += (target.getX(i / 3) - positions[i]) * influence;\n                  y += (target.getY(i / 3) - positions[i + 1]) * influence;\n                  z += (target.getZ(i / 3) - positions[i + 2]) * influence;\n                }\n              }\n            }\n            renderList.pushVertex(x, y, z);\n          }\n          if (attributes.normal !== void 0) {\n            const normals = attributes.normal.array;\n            for (let i = 0, l = normals.length; i < l; i += 3) {\n              renderList.pushNormal(normals[i], normals[i + 1], normals[i + 2]);\n            }\n          }\n          if (attributes.color !== void 0) {\n            const colors = attributes.color.array;\n            for (let i = 0, l = colors.length; i < l; i += 3) {\n              renderList.pushColor(colors[i], colors[i + 1], colors[i + 2]);\n            }\n          }\n          if (attributes.uv !== void 0) {\n            const uvs = attributes.uv.array;\n            for (let i = 0, l = uvs.length; i < l; i += 2) {\n              renderList.pushUv(uvs[i], uvs[i + 1]);\n            }\n          }\n          if (geometry.index !== null) {\n            const indices = geometry.index.array;\n            if (groups.length > 0) {\n              for (let g = 0; g < groups.length; g++) {\n                const group = groups[g];\n                material = isMultiMaterial === true ? object.material[group.materialIndex] : object.material;\n                if (material === void 0) continue;\n                for (let i = group.start, l = group.start + group.count; i < l; i += 3) {\n                  renderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2], material);\n                }\n              }\n            } else {\n              for (let i = 0, l = indices.length; i < l; i += 3) {\n                renderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2], material);\n              }\n            }\n          } else {\n            if (groups.length > 0) {\n              for (let g = 0; g < groups.length; g++) {\n                const group = groups[g];\n                material = isMultiMaterial === true ? object.material[group.materialIndex] : object.material;\n                if (material === void 0) continue;\n                for (let i = group.start, l = group.start + group.count; i < l; i += 3) {\n                  renderList.pushTriangle(i, i + 1, i + 2, material);\n                }\n              }\n            } else {\n              for (let i = 0, l = positions.length / 3; i < l; i += 3) {\n                renderList.pushTriangle(i, i + 1, i + 2, material);\n              }\n            }\n          }\n        } else if (object.isLine) {\n          _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);\n          const attributes = geometry.attributes;\n          if (attributes.position !== void 0) {\n            const positions = attributes.position.array;\n            for (let i = 0, l = positions.length; i < l; i += 3) {\n              renderList.pushVertex(positions[i], positions[i + 1], positions[i + 2]);\n            }\n            if (attributes.color !== void 0) {\n              const colors = attributes.color.array;\n              for (let i = 0, l = colors.length; i < l; i += 3) {\n                renderList.pushColor(colors[i], colors[i + 1], colors[i + 2]);\n              }\n            }\n            if (geometry.index !== null) {\n              const indices = geometry.index.array;\n              for (let i = 0, l = indices.length; i < l; i += 2) {\n                renderList.pushLine(indices[i], indices[i + 1]);\n              }\n            } else {\n              const step = object.isLineSegments ? 2 : 1;\n              for (let i = 0, l = positions.length / 3 - 1; i < l; i += step) {\n                renderList.pushLine(i, i + 1);\n              }\n            }\n          }\n        } else if (object.isPoints) {\n          _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);\n          const attributes = geometry.attributes;\n          if (attributes.position !== void 0) {\n            const positions = attributes.position.array;\n            for (let i = 0, l = positions.length; i < l; i += 3) {\n              _vector4.set(positions[i], positions[i + 1], positions[i + 2], 1);\n              _vector4.applyMatrix4(_modelViewProjectionMatrix);\n              pushPoint(_vector4, object, camera);\n            }\n          }\n        } else if (object.isSprite) {\n          object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n          _vector4.set(_modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1);\n          _vector4.applyMatrix4(_viewProjectionMatrix);\n          pushPoint(_vector4, object, camera);\n        }\n      }\n      if (sortElements === true) {\n        _renderData.elements.sort(painterSort);\n      }\n      return _renderData;\n    };\n    function pushPoint(_vector42, object, camera) {\n      const invW = 1 / _vector42.w;\n      _vector42.z *= invW;\n      if (_vector42.z >= -1 && _vector42.z <= 1) {\n        _sprite = getNextSpriteInPool();\n        _sprite.id = object.id;\n        _sprite.x = _vector42.x * invW;\n        _sprite.y = _vector42.y * invW;\n        _sprite.z = _vector42.z;\n        _sprite.renderOrder = object.renderOrder;\n        _sprite.object = object;\n        _sprite.rotation = object.rotation;\n        _sprite.scale.x = object.scale.x * Math.abs(_sprite.x - (_vector42.x + camera.projectionMatrix.elements[0]) / (_vector42.w + camera.projectionMatrix.elements[12]));\n        _sprite.scale.y = object.scale.y * Math.abs(_sprite.y - (_vector42.y + camera.projectionMatrix.elements[5]) / (_vector42.w + camera.projectionMatrix.elements[13]));\n        _sprite.material = object.material;\n        _renderData.elements.push(_sprite);\n      }\n    }\n    function getNextObjectInPool() {\n      if (_objectCount === _objectPoolLength) {\n        const object = new RenderableObject();\n        _objectPool.push(object);\n        _objectPoolLength++;\n        _objectCount++;\n        return object;\n      }\n      return _objectPool[_objectCount++];\n    }\n    function getNextVertexInPool() {\n      if (_vertexCount === _vertexPoolLength) {\n        const vertex = new RenderableVertex();\n        _vertexPool.push(vertex);\n        _vertexPoolLength++;\n        _vertexCount++;\n        return vertex;\n      }\n      return _vertexPool[_vertexCount++];\n    }\n    function getNextFaceInPool() {\n      if (_faceCount === _facePoolLength) {\n        const face = new RenderableFace();\n        _facePool.push(face);\n        _facePoolLength++;\n        _faceCount++;\n        return face;\n      }\n      return _facePool[_faceCount++];\n    }\n    function getNextLineInPool() {\n      if (_lineCount === _linePoolLength) {\n        const line = new RenderableLine();\n        _linePool.push(line);\n        _linePoolLength++;\n        _lineCount++;\n        return line;\n      }\n      return _linePool[_lineCount++];\n    }\n    function getNextSpriteInPool() {\n      if (_spriteCount === _spritePoolLength) {\n        const sprite = new RenderableSprite();\n        _spritePool.push(sprite);\n        _spritePoolLength++;\n        _spriteCount++;\n        return sprite;\n      }\n      return _spritePool[_spriteCount++];\n    }\n    function painterSort(a, b) {\n      if (a.renderOrder !== b.renderOrder) {\n        return a.renderOrder - b.renderOrder;\n      } else if (a.z !== b.z) {\n        return b.z - a.z;\n      } else if (a.id !== b.id) {\n        return a.id - b.id;\n      } else {\n        return 0;\n      }\n    }\n    function clipLine(s1, s2) {\n      let alpha1 = 0,\n        alpha2 = 1;\n      const bc1near = s1.z + s1.w,\n        bc2near = s2.z + s2.w,\n        bc1far = -s1.z + s1.w,\n        bc2far = -s2.z + s2.w;\n      if (bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0) {\n        return true;\n      } else if (bc1near < 0 && bc2near < 0 || bc1far < 0 && bc2far < 0) {\n        return false;\n      } else {\n        if (bc1near < 0) {\n          alpha1 = Math.max(alpha1, bc1near / (bc1near - bc2near));\n        } else if (bc2near < 0) {\n          alpha2 = Math.min(alpha2, bc1near / (bc1near - bc2near));\n        }\n        if (bc1far < 0) {\n          alpha1 = Math.max(alpha1, bc1far / (bc1far - bc2far));\n        } else if (bc2far < 0) {\n          alpha2 = Math.min(alpha2, bc1far / (bc1far - bc2far));\n        }\n        if (alpha2 < alpha1) {\n          return false;\n        } else {\n          s1.lerp(s2, alpha1);\n          s2.lerp(s1, 1 - alpha2);\n          return true;\n        }\n      }\n    }\n  }\n}\nexport { Projector, RenderableFace, RenderableLine, RenderableObject, RenderableSprite, RenderableVertex };\n//# sourceMappingURL=Projector.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}