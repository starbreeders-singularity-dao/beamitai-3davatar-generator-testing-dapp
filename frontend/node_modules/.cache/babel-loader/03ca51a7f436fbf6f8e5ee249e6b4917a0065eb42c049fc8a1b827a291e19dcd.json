{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport { misc, easing } from 'maath';\nconst isObject3DRef = ref => (ref == null ? void 0 : ref.current) instanceof THREE.Object3D;\nconst context = /* @__PURE__ */React.createContext(null);\nfunction useMotion() {\n  return React.useContext(context);\n}\nfunction Debug({\n  points = 50\n}) {\n  const {\n    path\n  } = useMotion();\n  const [dots, setDots] = React.useState([]);\n  const [material] = React.useState(() => new THREE.MeshBasicMaterial({\n    color: 'black'\n  }));\n  const [geometry] = React.useState(() => new THREE.SphereGeometry(0.025, 16, 16));\n  const last = React.useRef([]);\n  React.useEffect(() => {\n    if (path.curves !== last.current) {\n      setDots(path.getPoints(points));\n      last.current = path.curves;\n    }\n  });\n  return /*#__PURE__*/React.createElement(React.Fragment, null, dots.map((item, index) => /*#__PURE__*/React.createElement(\"mesh\", {\n    key: index,\n    material: material,\n    geometry: geometry,\n    position: [item.x, item.y, item.z]\n  })));\n}\nconst MotionPathControls = /* @__PURE__ */React.forwardRef(({\n  children,\n  curves = [],\n  object,\n  debug = false,\n  smooth = false,\n  focus,\n  offset = undefined,\n  eps = 0.00001,\n  damping = 0.1,\n  focusDamping = 0.1,\n  maxSpeed = Infinity,\n  ...props\n}, fref) => {\n  const {\n    camera\n  } = useThree();\n  const ref = React.useRef();\n  const [path] = React.useState(() => new THREE.CurvePath());\n  const pos = React.useRef(offset !== null && offset !== void 0 ? offset : 0);\n  const state = React.useMemo(() => ({\n    focus,\n    object: (object == null ? void 0 : object.current) instanceof THREE.Object3D ? object : {\n      current: camera\n    },\n    path,\n    current: pos.current,\n    offset: pos.current,\n    point: new THREE.Vector3(),\n    tangent: new THREE.Vector3(),\n    next: new THREE.Vector3()\n  }), [focus, object]);\n  React.useLayoutEffect(() => {\n    var _ref$current;\n    path.curves = [];\n    const _curves = curves.length > 0 ? curves : (_ref$current = ref.current) == null ? void 0 : _ref$current.__r3f.objects;\n    for (var i = 0; i < _curves.length; i++) path.add(_curves[i]);\n\n    //Smoothen curve\n    if (smooth) {\n      const points = path.getPoints(typeof smooth === 'number' ? smooth : 1);\n      const catmull = new THREE.CatmullRomCurve3(points);\n      path.curves = [catmull];\n    }\n    path.updateArcLengths();\n  });\n  React.useImperativeHandle(fref, () => ref.current, []);\n  React.useLayoutEffect(() => {\n    // When offset changes, normalise pos to avoid overshoot spinning\n    pos.current = misc.repeat(pos.current, 1);\n  }, [offset]);\n  let last = 0;\n  const [vec] = React.useState(() => new THREE.Vector3());\n  useFrame((_state, delta) => {\n    last = state.offset;\n    easing.damp(pos, 'current', offset !== undefined ? offset : state.current, damping, delta, maxSpeed, undefined, eps);\n    state.offset = misc.repeat(pos.current, 1);\n    if (path.getCurveLengths().length > 0) {\n      path.getPointAt(state.offset, state.point);\n      path.getTangentAt(state.offset, state.tangent).normalize();\n      path.getPointAt(misc.repeat(pos.current - (last - state.offset), 1), state.next);\n      const target = (object == null ? void 0 : object.current) instanceof THREE.Object3D ? object.current : camera;\n      target.position.copy(state.point);\n      //@ts-ignore\n      if (focus) {\n        easing.dampLookAt(target, isObject3DRef(focus) ? focus.current.getWorldPosition(vec) : focus, focusDamping, delta, maxSpeed, undefined, eps);\n      }\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, props), /*#__PURE__*/React.createElement(context.Provider, {\n    value: state\n  }, children, debug && /*#__PURE__*/React.createElement(Debug, null)));\n});\nexport { MotionPathControls, useMotion };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}