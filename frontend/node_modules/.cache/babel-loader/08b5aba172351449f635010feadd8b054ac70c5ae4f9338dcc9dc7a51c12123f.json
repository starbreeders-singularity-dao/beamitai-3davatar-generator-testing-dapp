{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Texture } from 'three';\nimport * as SkeletonUtils from 'three/examples/jsm/utils/SkeletonUtils.js';\nexport const $prepared = Symbol('prepared');\nexport const $prepare = Symbol('prepare');\nexport const $preparedGLTF = Symbol('preparedGLTF');\nexport const $clone = Symbol('clone');\n/**\n * Represents the preparation and enhancement of the output of a Three.js\n * GLTFLoader (a Three.js-flavor \"GLTF\"), to make it suitable for optimal,\n * correct viewing in a given presentation context and also make the cloning\n * process more explicit and legible.\n *\n * A GLTFInstance is API-compatible with a Three.js-flavor \"GLTF\", so it should\n * be considered to be interchangeable with the loaded result of a GLTFLoader.\n *\n * This basic implementation only implements trivial preparation and enhancement\n * of a GLTF. These operations are intended to be enhanced by inheriting\n * classes.\n */\nexport class GLTFInstance {\n  constructor(preparedGLTF) {\n    this[$preparedGLTF] = preparedGLTF;\n  }\n  /**\n   * Prepares a given GLTF for presentation and future cloning. A GLTF that is\n   * prepared can safely have this method invoked on it multiple times; it will\n   * only be prepared once, including after being cloned.\n   */\n  static prepare(source) {\n    if (source.scene == null) {\n      throw new Error('Model does not have a scene');\n    }\n    if (source[$prepared]) {\n      return source;\n    }\n    const prepared = this[$prepare](source);\n    // NOTE: ES5 Symbol polyfill is not compatible with spread operator\n    // so {...prepared, [$prepared]: true} does not work\n    prepared[$prepared] = true;\n    return prepared;\n  }\n  /**\n   * Override in an inheriting class to apply specialty one-time preparations\n   * for a given input GLTF.\n   */\n  static [$prepare](source) {\n    // TODO(#195,#1003): We don't currently support multiple scenes, so we don't\n    // bother preparing extra scenes for now:\n    const {\n      scene\n    } = source;\n    const scenes = [scene];\n    return Object.assign(Object.assign({}, source), {\n      scene,\n      scenes\n    });\n  }\n  get parser() {\n    return this[$preparedGLTF].parser;\n  }\n  get animations() {\n    return this[$preparedGLTF].animations;\n  }\n  get scene() {\n    return this[$preparedGLTF].scene;\n  }\n  get scenes() {\n    return this[$preparedGLTF].scenes;\n  }\n  get cameras() {\n    return this[$preparedGLTF].cameras;\n  }\n  get asset() {\n    return this[$preparedGLTF].asset;\n  }\n  get userData() {\n    return this[$preparedGLTF].userData;\n  }\n  /**\n   * Creates and returns a copy of this instance.\n   */\n  clone() {\n    const GLTFInstanceConstructor = this.constructor;\n    const clonedGLTF = this[$clone]();\n    return new GLTFInstanceConstructor(clonedGLTF);\n  }\n  /**\n   * Cleans up any retained memory that might not otherwise be released when\n   * this instance is done being used.\n   */\n  dispose() {\n    this.scenes.forEach(scene => {\n      scene.traverse(object => {\n        const mesh = object;\n        if (!mesh.material) {\n          return;\n        }\n        const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n        materials.forEach(material => {\n          // Explicitly dispose any textures assigned to this material\n          for (const propertyName in material) {\n            const texture = material[propertyName];\n            if (texture instanceof Texture) {\n              const image = texture.source.data;\n              if (image.close != null) {\n                image.close();\n              }\n              texture.dispose();\n            }\n          }\n          material.dispose();\n        });\n        mesh.geometry.dispose();\n      });\n    });\n  }\n  /**\n   * Override in an inheriting class to implement specialized cloning strategies\n   */\n  [$clone]() {\n    const source = this[$preparedGLTF];\n    // TODO(#195,#1003): We don't currently support multiple scenes, so we don't\n    // bother cloning extra scenes for now:\n    const scene = SkeletonUtils.clone(this.scene);\n    cloneVariantMaterials(scene, this.scene);\n    const scenes = [scene];\n    const userData = source.userData ? Object.assign({}, source.userData) : {};\n    return Object.assign(Object.assign({}, source), {\n      scene,\n      scenes,\n      userData\n    });\n  }\n}\n// Variant materials and original material instances are stored under\n// object.userData.variantMaterials/originalMaterial.\n// Three.js Object3D.clone() doesn't clone Three.js objects under\n// .userData so this function is a workaround.\nconst cloneVariantMaterials = (dst, src) => {\n  traversePair(dst, src, (dst, src) => {\n    if (src.userData.variantMaterials !== undefined) {\n      dst.userData.variantMaterials = new Map(src.userData.variantMaterials);\n    }\n    if (src.userData.variantData !== undefined) {\n      dst.userData.variantData = src.userData.variantData;\n    }\n    if (src.userData.originalMaterial !== undefined) {\n      dst.userData.originalMaterial = src.userData.originalMaterial;\n    }\n  });\n};\nconst traversePair = (obj1, obj2, callback) => {\n  callback(obj1, obj2);\n  // Assume obj1 and obj2 have the same tree structure\n  for (let i = 0; i < obj1.children.length; i++) {\n    traversePair(obj1.children[i], obj2.children[i], callback);\n  }\n};\n//# sourceMappingURL=GLTFInstance.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}