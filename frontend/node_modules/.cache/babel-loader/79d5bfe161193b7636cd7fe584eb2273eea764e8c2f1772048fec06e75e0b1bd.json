{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { parseBaseType, hexToNumber } from '../utils.js';\nimport { isHexStrict } from './string.js';\n/**\n * Checks if a given value is a valid big int\n */\nexport const isBigInt = value => typeof value === 'bigint';\n// Note: this could be simplified using ** operator, but babel does not handle it well\n// \tyou can find more at: https://github.com/babel/babel/issues/13109 and https://github.com/web3/web3.js/issues/6187\n/** @internal */\nexport const bigintPower = (base, expo) => {\n  // edge case\n  if (expo === BigInt(0)) {\n    return BigInt(1);\n  }\n  let res = base;\n  for (let index = 1; index < expo; index += 1) {\n    res *= base;\n  }\n  return res;\n};\nexport const isUInt = (value, options = {\n  abiType: 'uint'\n}) => {\n  if (!['number', 'string', 'bigint'].includes(typeof value) || typeof value === 'string' && value.length === 0) {\n    return false;\n  }\n  let size;\n  if (options === null || options === void 0 ? void 0 : options.abiType) {\n    const {\n      baseTypeSize\n    } = parseBaseType(options.abiType);\n    if (baseTypeSize) {\n      size = baseTypeSize;\n    }\n  } else if (options.bitSize) {\n    size = options.bitSize;\n  }\n  const maxSize = bigintPower(BigInt(2), BigInt(size !== null && size !== void 0 ? size : 256)) - BigInt(1);\n  try {\n    const valueToCheck = typeof value === 'string' && isHexStrict(value) ? BigInt(hexToNumber(value)) : BigInt(value);\n    return valueToCheck >= 0 && valueToCheck <= maxSize;\n  } catch (error) {\n    // Some invalid number value given which can not be converted via BigInt\n    return false;\n  }\n};\nexport const isInt = (value, options = {\n  abiType: 'int'\n}) => {\n  if (!['number', 'string', 'bigint'].includes(typeof value)) {\n    return false;\n  }\n  if (typeof value === 'number' && value > Number.MAX_SAFE_INTEGER) {\n    return false;\n  }\n  let size;\n  if (options === null || options === void 0 ? void 0 : options.abiType) {\n    const {\n      baseTypeSize,\n      baseType\n    } = parseBaseType(options.abiType);\n    if (baseType !== 'int') {\n      return false;\n    }\n    if (baseTypeSize) {\n      size = baseTypeSize;\n    }\n  } else if (options.bitSize) {\n    size = options.bitSize;\n  }\n  const maxSize = bigintPower(BigInt(2), BigInt((size !== null && size !== void 0 ? size : 256) - 1));\n  const minSize = BigInt(-1) * bigintPower(BigInt(2), BigInt((size !== null && size !== void 0 ? size : 256) - 1));\n  try {\n    const valueToCheck = typeof value === 'string' && isHexStrict(value) ? BigInt(hexToNumber(value)) : BigInt(value);\n    return valueToCheck >= minSize && valueToCheck <= maxSize;\n  } catch (error) {\n    // Some invalid number value given which can not be converted via BigInt\n    return false;\n  }\n};\nexport const isNumber = value => {\n  if (isInt(value)) {\n    return true;\n  }\n  // It would be a decimal number\n  if (typeof value === 'string' && /[0-9.]/.test(value) && value.indexOf('.') === value.lastIndexOf('.')) {\n    return true;\n  }\n  if (typeof value === 'number') {\n    return true;\n  }\n  return false;\n};\n//# sourceMappingURL=numbers.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}