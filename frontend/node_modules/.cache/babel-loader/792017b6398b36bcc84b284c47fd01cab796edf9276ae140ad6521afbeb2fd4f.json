{"ast":null,"code":"import { Material } from 'three';\nconst $threeGLTF = Symbol('threeGLTF');\nconst $gltf = Symbol('gltf');\nconst $gltfElementMap = Symbol('gltfElementMap');\nconst $threeObjectMap = Symbol('threeObjectMap');\nconst $parallelTraverseThreeScene = Symbol('parallelTraverseThreeScene');\nconst $correlateOriginalThreeGLTF = Symbol('correlateOriginalThreeGLTF');\nconst $correlateCloneThreeGLTF = Symbol('correlateCloneThreeGLTF');\n/**\n * The Three.js GLTFLoader provides us with an in-memory representation\n * of a glTF in terms of Three.js constructs. It also provides us with a copy\n * of the deserialized glTF without any Three.js decoration, and a mapping of\n * glTF elements to their corresponding Three.js constructs.\n *\n * A CorrelatedSceneGraph exposes a synchronously available mapping of glTF\n * element references to their corresponding Three.js constructs.\n */\nexport class CorrelatedSceneGraph {\n  constructor(threeGLTF, gltf, threeObjectMap, gltfElementMap) {\n    this[$threeGLTF] = threeGLTF;\n    this[$gltf] = gltf;\n    this[$gltfElementMap] = gltfElementMap;\n    this[$threeObjectMap] = threeObjectMap;\n  }\n  /**\n   * Produce a CorrelatedSceneGraph from a naturally generated Three.js GLTF.\n   * Such GLTFs are produced by Three.js' GLTFLoader, and contain cached\n   * details that expedite the correlation step.\n   *\n   * If a CorrelatedSceneGraph is provided as the second argument, re-correlates\n   * a cloned Three.js GLTF with a clone of the glTF hierarchy used to produce\n   * the upstream Three.js GLTF that the clone was created from. The result\n   * CorrelatedSceneGraph is representative of the cloned hierarchy.\n   */\n  static from(threeGLTF, upstreamCorrelatedSceneGraph) {\n    if (upstreamCorrelatedSceneGraph != null) {\n      return this[$correlateCloneThreeGLTF](threeGLTF, upstreamCorrelatedSceneGraph);\n    } else {\n      return this[$correlateOriginalThreeGLTF](threeGLTF);\n    }\n  }\n  static [$correlateOriginalThreeGLTF](threeGLTF) {\n    const gltf = threeGLTF.parser.json;\n    const associations = threeGLTF.parser.associations;\n    const gltfElementMap = new Map();\n    const defaultMaterial = {\n      name: 'Default'\n    };\n    const defaultReference = {\n      type: 'materials',\n      index: -1\n    };\n    for (const threeMaterial of associations.keys()) {\n      // Note: GLTFLoader creates a \"default\" material that has no\n      // corresponding glTF element in the case that no materials are\n      // specified in the source glTF. In this case we append a default\n      // material to allow this to be operated upon.\n      if (threeMaterial instanceof Material && associations.get(threeMaterial) == null) {\n        if (defaultReference.index < 0) {\n          if (gltf.materials == null) {\n            gltf.materials = [];\n          }\n          defaultReference.index = gltf.materials.length;\n          gltf.materials.push(defaultMaterial);\n        }\n        threeMaterial.name = defaultMaterial.name;\n        associations.set(threeMaterial, {\n          materials: defaultReference.index\n        });\n      }\n    }\n    // Creates a reverse look up map (gltf-object to Three-object)\n    for (const [threeObject, gltfMappings] of associations) {\n      if (gltfMappings) {\n        threeObject.userData = threeObject.userData || {};\n        threeObject.userData.associations = gltfMappings;\n      }\n      for (const mapping in gltfMappings) {\n        if (mapping != null && mapping !== 'primitives') {\n          const type = mapping;\n          const elementArray = gltf[type] || [];\n          const gltfElement = elementArray[gltfMappings[type]];\n          if (gltfElement == null) {\n            // TODO: Maybe throw here...\n            continue;\n          }\n          let threeObjects = gltfElementMap.get(gltfElement);\n          if (threeObjects == null) {\n            threeObjects = new Set();\n            gltfElementMap.set(gltfElement, threeObjects);\n          }\n          threeObjects.add(threeObject);\n        }\n      }\n    }\n    return new CorrelatedSceneGraph(threeGLTF, gltf, associations, gltfElementMap);\n  }\n  /**\n   * Transfers the association between a raw glTF and a Three.js scene graph\n   * to a clone of the Three.js scene graph, resolved as a new\n   * CorrelatedSceneGraph instance.\n   */\n  static [$correlateCloneThreeGLTF](cloneThreeGLTF, upstreamCorrelatedSceneGraph) {\n    const originalThreeGLTF = upstreamCorrelatedSceneGraph.threeGLTF;\n    const originalGLTF = upstreamCorrelatedSceneGraph.gltf;\n    const cloneGLTF = JSON.parse(JSON.stringify(originalGLTF));\n    const cloneThreeObjectMap = new Map();\n    const cloneGLTFElementMap = new Map();\n    for (let i = 0; i < originalThreeGLTF.scenes.length; i++) {\n      this[$parallelTraverseThreeScene](originalThreeGLTF.scenes[i], cloneThreeGLTF.scenes[i], (object, cloneObject) => {\n        const elementReference = upstreamCorrelatedSceneGraph.threeObjectMap.get(object);\n        if (elementReference == null) {\n          return;\n        }\n        for (const mapping in elementReference) {\n          if (mapping != null && mapping !== 'primitives') {\n            const type = mapping;\n            const index = elementReference[type];\n            const cloneElement = cloneGLTF[type][index];\n            const mappings = cloneThreeObjectMap.get(cloneObject) || {};\n            mappings[type] = index;\n            cloneThreeObjectMap.set(cloneObject, mappings);\n            const cloneObjects = cloneGLTFElementMap.get(cloneElement) || new Set();\n            cloneObjects.add(cloneObject);\n            cloneGLTFElementMap.set(cloneElement, cloneObjects);\n          }\n        }\n      });\n    }\n    return new CorrelatedSceneGraph(cloneThreeGLTF, cloneGLTF, cloneThreeObjectMap, cloneGLTFElementMap);\n  }\n  /**\n   * Traverses two presumably identical Three.js scenes, and invokes a\n   * callback for each Object3D or Material encountered, including the initial\n   * scene. Adapted from\n   * https://github.com/mrdoob/three.js/blob/7c1424c5819ab622a346dd630ee4e6431388021e/examples/jsm/utils/SkeletonUtils.js#L586-L596\n   */\n  static [$parallelTraverseThreeScene](sceneOne, sceneTwo, callback) {\n    const traverse = (a, b) => {\n      callback(a, b);\n      if (a.isObject3D) {\n        const meshA = a;\n        const meshB = b;\n        if (meshA.material) {\n          if (Array.isArray(meshA.material)) {\n            for (let i = 0; i < meshA.material.length; ++i) {\n              callback(meshA.material[i], meshB.material[i]);\n            }\n          } else {\n            callback(meshA.material, meshB.material);\n          }\n        }\n        for (let i = 0; i < a.children.length; ++i) {\n          traverse(a.children[i], b.children[i]);\n        }\n      }\n    };\n    traverse(sceneOne, sceneTwo);\n  }\n  /**\n   * The source Three.js GLTF result given to us by a Three.js GLTFLoader.\n   */\n  get threeGLTF() {\n    return this[$threeGLTF];\n  }\n  /**\n   * The in-memory deserialized source glTF.\n   */\n  get gltf() {\n    return this[$gltf];\n  }\n  /**\n   * A Map of glTF element references to arrays of corresponding Three.js\n   * object references. Three.js objects are kept in arrays to account for\n   * cases where more than one Three.js object corresponds to a single glTF\n   * element.\n   */\n  get gltfElementMap() {\n    return this[$gltfElementMap];\n  }\n  /**\n   * A map of individual Three.js objects to corresponding elements in the\n   * source glTF.\n   */\n  get threeObjectMap() {\n    return this[$threeObjectMap];\n  }\n}\n//# sourceMappingURL=correlated-scene-graph.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}