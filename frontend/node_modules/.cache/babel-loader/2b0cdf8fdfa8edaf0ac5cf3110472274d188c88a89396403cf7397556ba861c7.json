{"ast":null,"code":"import { BufferAttribute } from 'three';\nexport function getVertexCount(geo) {\n  return geo.index ? geo.index.count : geo.attributes.position.count;\n}\nexport function getTriCount(geo) {\n  return getVertexCount(geo) / 3;\n}\nexport function getIndexArray(vertexCount, BufferConstructor = ArrayBuffer) {\n  if (vertexCount > 65535) {\n    return new Uint32Array(new BufferConstructor(4 * vertexCount));\n  } else {\n    return new Uint16Array(new BufferConstructor(2 * vertexCount));\n  }\n}\n\n// ensures that an index is present on the geometry\nexport function ensureIndex(geo, options) {\n  if (!geo.index) {\n    const vertexCount = geo.attributes.position.count;\n    const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n    const index = getIndexArray(vertexCount, BufferConstructor);\n    geo.setIndex(new BufferAttribute(index, 1));\n    for (let i = 0; i < vertexCount; i++) {\n      index[i] = i;\n    }\n  }\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nexport function getFullGeometryRange(geo, range) {\n  const triCount = getTriCount(geo);\n  const drawRange = range ? range : geo.drawRange;\n  const start = drawRange.start / 3;\n  const end = (drawRange.start + drawRange.count) / 3;\n  const offset = Math.max(0, start);\n  const count = Math.min(triCount, end) - offset;\n  return [{\n    offset: Math.floor(offset),\n    count: Math.floor(count)\n  }];\n}\nexport function getRootIndexRanges(geo, range) {\n  if (!geo.groups || !geo.groups.length) {\n    return getFullGeometryRange(geo, range);\n  }\n  const ranges = [];\n  const rangeBoundaries = new Set();\n  const drawRange = range ? range : geo.drawRange;\n  const drawRangeStart = drawRange.start / 3;\n  const drawRangeEnd = (drawRange.start + drawRange.count) / 3;\n  for (const group of geo.groups) {\n    const groupStart = group.start / 3;\n    const groupEnd = (group.start + group.count) / 3;\n    rangeBoundaries.add(Math.max(drawRangeStart, groupStart));\n    rangeBoundaries.add(Math.min(drawRangeEnd, groupEnd));\n  }\n\n  // note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n  const sortedBoundaries = Array.from(rangeBoundaries.values()).sort((a, b) => a - b);\n  for (let i = 0; i < sortedBoundaries.length - 1; i++) {\n    const start = sortedBoundaries[i];\n    const end = sortedBoundaries[i + 1];\n    ranges.push({\n      offset: Math.floor(start),\n      count: Math.floor(end - start)\n    });\n  }\n  return ranges;\n}\nexport function hasGroupGaps(geometry, range) {\n  const vertexCount = getTriCount(geometry);\n  const groups = getRootIndexRanges(geometry, range).sort((a, b) => a.offset - b.offset);\n  const finalGroup = groups[groups.length - 1];\n  finalGroup.count = Math.min(vertexCount - finalGroup.offset, finalGroup.count);\n  let total = 0;\n  groups.forEach(({\n    count\n  }) => total += count);\n  return vertexCount !== total;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}