{"ast":null,"code":"import { ensureIndex, getFullGeometryRange, getRootIndexRanges, getTriCount, hasGroupGaps } from './geometryUtils.js';\nimport { getBounds, computeTriangleBounds } from './computeBoundsUtils.js';\nimport { getOptimalSplit } from './splitUtils.js';\nimport { MeshBVHNode } from '../MeshBVHNode.js';\nimport { BYTES_PER_NODE } from '../Constants.js';\nimport { partition } from './sortUtils.generated.js';\nimport { partition_indirect } from './sortUtils_indirect.generated.js';\nimport { countNodes, populateBuffer } from './buildUtils.js';\nexport function generateIndirectBuffer(geometry, useSharedArrayBuffer) {\n  const triCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n  const useUint32 = triCount > 2 ** 16;\n  const byteCount = useUint32 ? 4 : 2;\n  const buffer = useSharedArrayBuffer ? new SharedArrayBuffer(triCount * byteCount) : new ArrayBuffer(triCount * byteCount);\n  const indirectBuffer = useUint32 ? new Uint32Array(buffer) : new Uint16Array(buffer);\n  for (let i = 0, l = indirectBuffer.length; i < l; i++) {\n    indirectBuffer[i] = i;\n  }\n  return indirectBuffer;\n}\nexport function buildTree(bvh, triangleBounds, offset, count, options) {\n  // epxand variables\n  const {\n    maxDepth,\n    verbose,\n    maxLeafTris,\n    strategy,\n    onProgress,\n    indirect\n  } = options;\n  const indirectBuffer = bvh._indirectBuffer;\n  const geometry = bvh.geometry;\n  const indexArray = geometry.index ? geometry.index.array : null;\n  const partionFunc = indirect ? partition_indirect : partition;\n\n  // generate intermediate variables\n  const totalTriangles = getTriCount(geometry);\n  const cacheCentroidBoundingData = new Float32Array(6);\n  let reachedMaxDepth = false;\n  const root = new MeshBVHNode();\n  getBounds(triangleBounds, offset, count, root.boundingData, cacheCentroidBoundingData);\n  splitNode(root, offset, count, cacheCentroidBoundingData);\n  return root;\n  function triggerProgress(trianglesProcessed) {\n    if (onProgress) {\n      onProgress(trianglesProcessed / totalTriangles);\n    }\n  }\n\n  // either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n  // recording the offset and count of its triangles and writing them into the reordered geometry index.\n  function splitNode(node, offset, count, centroidBoundingData = null, depth = 0) {\n    if (!reachedMaxDepth && depth >= maxDepth) {\n      reachedMaxDepth = true;\n      if (verbose) {\n        console.warn(`MeshBVH: Max depth of ${maxDepth} reached when generating BVH. Consider increasing maxDepth.`);\n        console.warn(geometry);\n      }\n    }\n\n    // early out if we've met our capacity\n    if (count <= maxLeafTris || depth >= maxDepth) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n\n    // Find where to split the volume\n    const split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);\n    if (split.axis === -1) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n    const splitOffset = partionFunc(indirectBuffer, indexArray, triangleBounds, offset, count, split);\n\n    // create the two new child nodes\n    if (splitOffset === offset || splitOffset === offset + count) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n    } else {\n      node.splitAxis = split.axis;\n\n      // create the left child and compute its bounding box\n      const left = new MeshBVHNode();\n      const lstart = offset;\n      const lcount = splitOffset - offset;\n      node.left = left;\n      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);\n      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);\n\n      // repeat for right\n      const right = new MeshBVHNode();\n      const rstart = splitOffset;\n      const rcount = count - lcount;\n      node.right = right;\n      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);\n      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);\n    }\n    return node;\n  }\n}\nexport function buildPackedTree(bvh, options) {\n  const geometry = bvh.geometry;\n  if (options.indirect) {\n    bvh._indirectBuffer = generateIndirectBuffer(geometry, options.useSharedArrayBuffer);\n    if (hasGroupGaps(geometry, options.range) && !options.verbose) {\n      console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the \"indirect\" option. ' + 'BVH may incorrectly report intersections on unrendered portions of the geometry.');\n    }\n  }\n  if (!bvh._indirectBuffer) {\n    ensureIndex(geometry, options);\n  }\n  const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n  const triangleBounds = computeTriangleBounds(geometry);\n  const geometryRanges = options.indirect ? getFullGeometryRange(geometry, options.range) : getRootIndexRanges(geometry, options.range);\n  bvh._roots = geometryRanges.map(range => {\n    const root = buildTree(bvh, triangleBounds, range.offset, range.count, options);\n    const nodeCount = countNodes(root);\n    const buffer = new BufferConstructor(BYTES_PER_NODE * nodeCount);\n    populateBuffer(0, root, buffer);\n    return buffer;\n  });\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}