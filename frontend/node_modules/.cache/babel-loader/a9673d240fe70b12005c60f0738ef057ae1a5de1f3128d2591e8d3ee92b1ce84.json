{"ast":null,"code":"import { Vector2 } from \"three\";\nconst DepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    size: {\n      value: new Vector2(512, 512)\n    },\n    sampleUvOffsets: {\n      value: [new Vector2(0, 0)]\n    },\n    sampleWeights: {\n      value: [1]\n    },\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: 10\n    },\n    cameraFar: {\n      value: 1e3\n    },\n    depthCutoff: {\n      value: 10\n    }\n  },\n  vertexShader: [\"#include <common>\", \"uniform vec2 size;\", \"varying vec2 vUv;\", \"varying vec2 vInvSize;\", \"void main() {\", \"\tvUv = uv;\", \"\tvInvSize = 1.0 / size;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"#include <common>\", \"#include <packing>\", \"uniform sampler2D tDiffuse;\", \"uniform sampler2D tDepth;\", \"uniform float cameraNear;\", \"uniform float cameraFar;\", \"uniform float depthCutoff;\", \"uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\", \"uniform float sampleWeights[ KERNEL_RADIUS + 1 ];\", \"varying vec2 vUv;\", \"varying vec2 vInvSize;\", \"float getDepth( const in vec2 screenPosition ) {\", \"\t#if DEPTH_PACKING == 1\", \"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\", \"\t#else\", \"\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"float getViewZ( const in float depth ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#else\", \"\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#endif\", \"}\", \"void main() {\", \"\tfloat depth = getDepth( vUv );\", \"\tif( depth >= ( 1.0 - EPSILON ) ) {\", \"\t\tdiscard;\", \"\t}\", \"\tfloat centerViewZ = -getViewZ( depth );\", \"\tbool rBreak = false, lBreak = false;\", \"\tfloat weightSum = sampleWeights[0];\", \"\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\", \"\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\", \"\t\tfloat sampleWeight = sampleWeights[i];\", \"\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\", \"\t\tvec2 sampleUv = vUv + sampleUvOffset;\", \"\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\", \"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\", \"\t\tif( ! rBreak ) {\", \"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\", \"\t\t\tweightSum += sampleWeight;\", \"\t\t}\", \"\t\tsampleUv = vUv - sampleUvOffset;\", \"\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\", \"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\", \"\t\tif( ! lBreak ) {\", \"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\", \"\t\t\tweightSum += sampleWeight;\", \"\t\t}\", \"\t}\", \"\tgl_FragColor = diffuseSum / weightSum;\", \"}\"].join(\"\\n\")\n};\nconst BlurShaderUtils = {\n  createSampleWeights: (kernelRadius, stdDev) => {\n    const gaussian = (x, stdDev2) => {\n      return Math.exp(-(x * x) / (2 * (stdDev2 * stdDev2))) / (Math.sqrt(2 * Math.PI) * stdDev2);\n    };\n    const weights = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev));\n    }\n    return weights;\n  },\n  createSampleOffsets: (kernelRadius, uvIncrement) => {\n    const offsets = [];\n    for (let i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\n    }\n    return offsets;\n  },\n  configure: (shader, kernelRadius, stdDev, uvIncrement) => {\n    shader.defines[\"KERNEL_RADIUS\"] = kernelRadius;\n    shader.uniforms[\"sampleUvOffsets\"].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n    shader.uniforms[\"sampleWeights\"].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n    shader.needsUpdate = true;\n  }\n};\nexport { BlurShaderUtils, DepthLimitedBlurShader };\n//# sourceMappingURL=DepthLimitedBlurShader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}