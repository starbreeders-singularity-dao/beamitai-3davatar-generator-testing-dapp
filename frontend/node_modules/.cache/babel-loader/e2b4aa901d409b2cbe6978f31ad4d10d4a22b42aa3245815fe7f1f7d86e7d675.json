{"ast":null,"code":"import { Vector2, Matrix4 } from \"three\";\nconst SSAOShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n    KERNEL_SIZE: 32\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    tNormal: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    tNoise: {\n      value: null\n    },\n    kernel: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    },\n    cameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    cameraInverseProjectionMatrix: {\n      value: new Matrix4()\n    },\n    kernelRadius: {\n      value: 8\n    },\n    minDistance: {\n      value: 5e-3\n    },\n    maxDistance: {\n      value: 0.05\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform sampler2D tNormal;\", \"uniform sampler2D tDepth;\", \"uniform sampler2D tNoise;\", \"uniform vec3 kernel[ KERNEL_SIZE ];\", \"uniform vec2 resolution;\", \"uniform float cameraNear;\", \"uniform float cameraFar;\", \"uniform mat4 cameraProjectionMatrix;\", \"uniform mat4 cameraInverseProjectionMatrix;\", \"uniform float kernelRadius;\", \"uniform float minDistance;\",\n  // avoid artifacts caused by neighbour fragments with minimal depth difference\n  \"uniform float maxDistance;\",\n  // avoid the influence of fragments which are too far away\n  \"varying vec2 vUv;\", \"#include <packing>\", \"float getDepth( const in vec2 screenPosition ) {\", \"\treturn texture2D( tDepth, screenPosition ).x;\", \"}\", \"float getLinearDepth( const in vec2 screenPosition ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\", \"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\", \"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\", \"\t#else\", \"\t\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"float getViewZ( const in float depth ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#else\", \"\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#endif\", \"}\", \"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\", \"\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\", \"\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\", \"\tclipPosition *= clipW; // unprojection.\", \"\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\", \"}\", \"vec3 getViewNormal( const in vec2 screenPosition ) {\", \"\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\", \"}\", \"void main() {\", \"\tfloat depth = getDepth( vUv );\", \"\tfloat viewZ = getViewZ( depth );\", \"\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\", \"\tvec3 viewNormal = getViewNormal( vUv );\", \" vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\", \"\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;\",\n  // compute matrix used to reorient a kernel vector\n  \"\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\", \"\tvec3 bitangent = cross( viewNormal, tangent );\", \"\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\", \" float occlusion = 0.0;\", \" for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\", \"\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];\",\n  // reorient sample vector in view space\n  \"\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );\",\n  // calculate sample point\n  \"\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );\",\n  // project point and calculate NDC\n  \"\t\tsamplePointNDC /= samplePointNDC.w;\", \"\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;\",\n  // compute uv coordinates\n  \"\t\tfloat realDepth = getLinearDepth( samplePointUv );\",\n  // get linear depth from depth texture\n  \"\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );\",\n  // compute linear depth of the sample view Z value\n  \"\t\tfloat delta = sampleDepth - realDepth;\", \"\t\tif ( delta > minDistance && delta < maxDistance ) {\",\n  // if fragment is before sample point, increase occlusion\n  \"\t\t\tocclusion += 1.0;\", \"\t\t}\", \"\t}\", \"\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\", \"\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\", \"}\"].join(\"\\n\")\n};\nconst SSAODepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform sampler2D tDepth;\", \"uniform float cameraNear;\", \"uniform float cameraFar;\", \"varying vec2 vUv;\", \"#include <packing>\", \"float getLinearDepth( const in vec2 screenPosition ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\", \"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\", \"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\", \"\t#else\", \"\t\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"void main() {\", \"\tfloat depth = getLinearDepth( vUv );\", \"\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\", \"}\"].join(\"\\n\")\n};\nconst SSAOBlurShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform vec2 resolution;\", \"varying vec2 vUv;\", \"void main() {\", \"\tvec2 texelSize = ( 1.0 / resolution );\", \"\tfloat result = 0.0;\", \"\tfor ( int i = - 2; i <= 2; i ++ ) {\", \"\t\tfor ( int j = - 2; j <= 2; j ++ ) {\", \"\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\", \"\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\", \"\t\t}\", \"\t}\", \"\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\", \"}\"].join(\"\\n\")\n};\nexport { SSAOBlurShader, SSAODepthShader, SSAOShader };\n//# sourceMappingURL=SSAOShader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}