{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport pkg from 'crc-32';\nimport { EventEmitter, bytesToHex, hexToBytes, uint8ArrayConcat } from 'web3-utils';\nimport { TypeOutput } from './types.js';\nimport { intToUint8Array, toType, parseGethGenesis } from './utils.js';\nimport goerli from './chains/goerli.js';\nimport mainnet from './chains/mainnet.js';\nimport sepolia from './chains/sepolia.js';\nimport { EIPs } from './eips/index.js';\nimport { Chain, CustomChain, Hardfork } from './enums.js';\nimport { hardforks as HARDFORK_SPECS } from './hardforks/index.js';\nconst {\n  buf: crc32Uint8Array\n} = pkg;\n/**\n * Common class to access chain and hardfork parameters and to provide\n * a unified and shared view on the network and hardfork state.\n *\n * Use the {@link Common.custom} static constructor for creating simple\n * custom chain {@link Common} objects (more complete custom chain setups\n * can be created via the main constructor and the {@link CommonOpts.customChains} parameter).\n */\nexport class Common extends EventEmitter {\n  /**\n   * Creates a {@link Common} object for a custom chain, based on a standard one.\n   *\n   * It uses all the {@link Chain} parameters from the {@link baseChain} option except the ones overridden\n   * in a provided {@link chainParamsOrName} dictionary. Some usage example:\n   *\n   * ```javascript\n   * Common.custom({chainId: 123})\n   * ```\n   *\n   * There are also selected supported custom chains which can be initialized by using one of the\n   * {@link CustomChains} for {@link chainParamsOrName}, e.g.:\n   *\n   * ```javascript\n   * Common.custom(CustomChains.MaticMumbai)\n   * ```\n   *\n   * Note that these supported custom chains only provide some base parameters (usually the chain and\n   * network ID and a name) and can only be used for selected use cases (e.g. sending a tx with\n   * the `web3-utils/tx` library to a Layer-2 chain).\n   *\n   * @param chainParamsOrName Custom parameter dict (`name` will default to `custom-chain`) or string with name of a supported custom chain\n   * @param opts Custom chain options to set the {@link CustomCommonOpts.baseChain}, selected {@link CustomCommonOpts.hardfork} and others\n   */\n  static custom(chainParamsOrName, opts = {}) {\n    var _a;\n    const baseChain = (_a = opts.baseChain) !== null && _a !== void 0 ? _a : 'mainnet';\n    const standardChainParams = Object.assign({}, Common._getChainParams(baseChain));\n    standardChainParams.name = 'custom-chain';\n    if (typeof chainParamsOrName !== 'string') {\n      return new Common(Object.assign({\n        chain: Object.assign(Object.assign({}, standardChainParams), chainParamsOrName)\n      }, opts));\n    }\n    if (chainParamsOrName === CustomChain.PolygonMainnet) {\n      return Common.custom({\n        name: CustomChain.PolygonMainnet,\n        chainId: 137,\n        networkId: 137\n      }, opts);\n    }\n    if (chainParamsOrName === CustomChain.PolygonMumbai) {\n      return Common.custom({\n        name: CustomChain.PolygonMumbai,\n        chainId: 80001,\n        networkId: 80001\n      }, opts);\n    }\n    if (chainParamsOrName === CustomChain.ArbitrumRinkebyTestnet) {\n      return Common.custom({\n        name: CustomChain.ArbitrumRinkebyTestnet,\n        chainId: 421611,\n        networkId: 421611\n      }, opts);\n    }\n    if (chainParamsOrName === CustomChain.ArbitrumOne) {\n      return Common.custom({\n        name: CustomChain.ArbitrumOne,\n        chainId: 42161,\n        networkId: 42161\n      }, opts);\n    }\n    if (chainParamsOrName === CustomChain.xDaiChain) {\n      return Common.custom({\n        name: CustomChain.xDaiChain,\n        chainId: 100,\n        networkId: 100\n      }, opts);\n    }\n    if (chainParamsOrName === CustomChain.OptimisticKovan) {\n      return Common.custom({\n        name: CustomChain.OptimisticKovan,\n        chainId: 69,\n        networkId: 69\n      }, Object.assign({\n        hardfork: Hardfork.Berlin\n      }, opts));\n    }\n    if (chainParamsOrName === CustomChain.OptimisticEthereum) {\n      return Common.custom({\n        name: CustomChain.OptimisticEthereum,\n        chainId: 10,\n        networkId: 10\n      }, Object.assign({\n        hardfork: Hardfork.Berlin\n      }, opts));\n    }\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new Error(`Custom chain ${chainParamsOrName} not supported`);\n  }\n  /**\n   * Static method to load and set common from a geth genesis json\n   * @param genesisJson json of geth configuration\n   * @param { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge } to further configure the common instance\n   * @returns Common\n   */\n  static fromGethGenesis(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  genesisJson, {\n    chain,\n    eips,\n    genesisHash,\n    hardfork,\n    mergeForkIdPostMerge\n  }) {\n    var _a;\n    const genesisParams = parseGethGenesis(genesisJson, chain, mergeForkIdPostMerge);\n    const common = new Common({\n      chain: (_a = genesisParams.name) !== null && _a !== void 0 ? _a : 'custom',\n      customChains: [genesisParams],\n      eips,\n      hardfork: hardfork !== null && hardfork !== void 0 ? hardfork : genesisParams.hardfork\n    });\n    if (genesisHash !== undefined) {\n      common.setForkHashes(genesisHash);\n    }\n    return common;\n  }\n  /**\n   * Static method to determine if a {@link chainId} is supported as a standard chain\n   * @param chainId bigint id (`1`) of a standard chain\n   * @returns boolean\n   */\n  static isSupportedChainId(chainId) {\n    const initializedChains = this._getInitializedChains();\n    return Boolean(initializedChains.names[chainId.toString()]);\n  }\n  static _getChainParams(_chain, customChains) {\n    let chain = _chain;\n    const initializedChains = this._getInitializedChains(customChains);\n    if (typeof chain === 'number' || typeof chain === 'bigint') {\n      chain = chain.toString();\n      if (initializedChains.names[chain]) {\n        const name = initializedChains.names[chain];\n        return initializedChains[name];\n      }\n      throw new Error(`Chain with ID ${chain} not supported`);\n    }\n    if (initializedChains[chain] !== undefined) {\n      return initializedChains[chain];\n    }\n    throw new Error(`Chain with name ${chain} not supported`);\n  }\n  constructor(opts) {\n    var _a, _b;\n    super();\n    this._eips = [];\n    this._customChains = (_a = opts.customChains) !== null && _a !== void 0 ? _a : [];\n    this._chainParams = this.setChain(opts.chain);\n    this.DEFAULT_HARDFORK = (_b = this._chainParams.defaultHardfork) !== null && _b !== void 0 ? _b : Hardfork.Merge;\n    // Assign hardfork changes in the sequence of the applied hardforks\n    this.HARDFORK_CHANGES = this.hardforks().map(hf => [hf.name, HARDFORK_SPECS[hf.name]]);\n    this._hardfork = this.DEFAULT_HARDFORK;\n    if (opts.hardfork !== undefined) {\n      this.setHardfork(opts.hardfork);\n    }\n    if (opts.eips) {\n      this.setEIPs(opts.eips);\n    }\n  }\n  /**\n   * Sets the chain\n   * @param chain String ('mainnet') or Number (1) chain representation.\n   *              Or, a Dictionary of chain parameters for a private network.\n   * @returns The dictionary with parameters set as chain\n   */\n  setChain(chain) {\n    if (typeof chain === 'number' || typeof chain === 'bigint' || typeof chain === 'string') {\n      this._chainParams = Common._getChainParams(chain, this._customChains);\n    } else if (typeof chain === 'object') {\n      if (this._customChains.length > 0) {\n        throw new Error('Chain must be a string, number, or bigint when initialized with customChains passed in');\n      }\n      const required = ['networkId', 'genesis', 'hardforks', 'bootstrapNodes'];\n      for (const param of required) {\n        if (!(param in chain)) {\n          throw new Error(`Missing required chain parameter: ${param}`);\n        }\n      }\n      this._chainParams = chain;\n    } else {\n      throw new Error('Wrong input format');\n    }\n    for (const hf of this.hardforks()) {\n      if (hf.block === undefined) {\n        throw new Error(`Hardfork cannot have undefined block number`);\n      }\n    }\n    return this._chainParams;\n  }\n  /**\n   * Sets the hardfork to get params for\n   * @param hardfork String identifier (e.g. 'byzantium') or {@link Hardfork} enum\n   */\n  setHardfork(hardfork) {\n    let existing = false;\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if (hfChanges[0] === hardfork) {\n        if (this._hardfork !== hardfork) {\n          this._hardfork = hardfork;\n          this.emit('hardforkChanged', hardfork);\n        }\n        existing = true;\n      }\n    }\n    if (!existing) {\n      throw new Error(`Hardfork with name ${hardfork} not supported`);\n    }\n  }\n  /**\n   * Returns the hardfork based on the block number or an optional\n   * total difficulty (Merge HF) provided.\n   *\n   * An optional TD takes precedence in case the corresponding HF block\n   * is set to `null` or otherwise needs to match (if not an error\n   * will be thrown).\n   *\n   * @param blockNumber\n   * @param td : total difficulty of the parent block (for block hf) OR of the chain latest (for chain hf)\n   * @param timestamp: timestamp in seconds at which block was/is to be minted\n   * @returns The name of the HF\n   */\n  getHardforkByBlockNumber(_blockNumber, _td, _timestamp) {\n    const blockNumber = toType(_blockNumber, TypeOutput.BigInt);\n    const td = toType(_td, TypeOutput.BigInt);\n    const timestamp = toType(_timestamp, TypeOutput.Number);\n    // Filter out hardforks with no block number, no ttd or no timestamp (i.e. unapplied hardforks)\n    const hfs = this.hardforks().filter(hf =>\n    // eslint-disable-next-line no-null/no-null\n    hf.block !== null ||\n    // eslint-disable-next-line no-null/no-null\n    hf.ttd !== null && hf.ttd !== undefined || hf.timestamp !== undefined);\n    // eslint-disable-next-line no-null/no-null\n    const mergeIndex = hfs.findIndex(hf => hf.ttd !== null && hf.ttd !== undefined);\n    const doubleTTDHF = hfs.slice(mergeIndex + 1)\n    // eslint-disable-next-line no-null/no-null\n    .findIndex(hf => hf.ttd !== null && hf.ttd !== undefined);\n    if (doubleTTDHF >= 0) {\n      throw Error(`More than one merge hardforks found with ttd specified`);\n    }\n    // Find the first hardfork that has a block number greater than `blockNumber`\n    // (skips the merge hardfork since it cannot have a block number specified).\n    // If timestamp is not provided, it also skips timestamps hardforks to continue\n    // discovering/checking number hardforks.\n    let hfIndex = hfs.findIndex(hf =>\n    // eslint-disable-next-line no-null/no-null\n    hf.block !== null && hf.block > blockNumber || timestamp !== undefined && Number(hf.timestamp) > timestamp);\n    if (hfIndex === -1) {\n      // all hardforks apply, set hfIndex to the last one as that's the candidate\n      hfIndex = hfs.length;\n    } else if (hfIndex === 0) {\n      // cannot have a case where a block number is before all applied hardforks\n      // since the chain has to start with a hardfork\n      throw Error('Must have at least one hardfork at block 0');\n    }\n    // If timestamp is not provided, we need to rollback to the last hf with block or ttd\n    if (timestamp === undefined) {\n      const stepBack = hfs.slice(0, hfIndex).reverse()\n      // eslint-disable-next-line no-null/no-null\n      .findIndex(hf => hf.block !== null || hf.ttd !== undefined);\n      hfIndex -= stepBack;\n    }\n    // Move hfIndex one back to arrive at candidate hardfork\n    hfIndex -= 1;\n    // If the timestamp was not provided, we could have skipped timestamp hardforks to look for number\n    // hardforks. so it will now be needed to rollback\n    // eslint-disable-next-line no-null/no-null\n    if (hfs[hfIndex].block === null && hfs[hfIndex].timestamp === undefined) {\n      // We're on the merge hardfork.  Let's check the TTD\n      // eslint-disable-next-line no-null/no-null\n      if (td === undefined || td === null || BigInt(hfs[hfIndex].ttd) > td) {\n        // Merge ttd greater than current td so we're on hardfork before merge\n        hfIndex -= 1;\n      }\n      // eslint-disable-next-line no-null/no-null\n    } else if (mergeIndex >= 0 && td !== undefined && td !== null) {\n      if (hfIndex >= mergeIndex && BigInt(hfs[mergeIndex].ttd) > td) {\n        throw Error('Maximum HF determined by total difficulty is lower than the block number HF');\n      } else if (hfIndex < mergeIndex && BigInt(hfs[mergeIndex].ttd) <= td) {\n        throw Error('HF determined by block number is lower than the minimum total difficulty HF');\n      }\n    }\n    const hfStartIndex = hfIndex;\n    // Move the hfIndex to the end of the hardforks that might be scheduled on the same block/timestamp\n    // This won't anyway be the case with Merge hfs\n    for (; hfIndex < hfs.length - 1; hfIndex += 1) {\n      // break out if hfIndex + 1 is not scheduled at hfIndex\n      if (hfs[hfIndex].block !== hfs[hfIndex + 1].block || hfs[hfIndex].timestamp !== hfs[hfIndex + 1].timestamp) {\n        break;\n      }\n    }\n    if (timestamp) {\n      const minTimeStamp = hfs.slice(0, hfStartIndex).reduce((acc, hf) => {\n        var _a;\n        return Math.max(Number((_a = hf.timestamp) !== null && _a !== void 0 ? _a : '0'), acc);\n      }, 0);\n      if (minTimeStamp > timestamp) {\n        throw Error(`Maximum HF determined by timestamp is lower than the block number/ttd HF`);\n      }\n      const maxTimeStamp = hfs.slice(hfIndex + 1).reduce((acc, hf) => {\n        var _a;\n        return Math.min(Number((_a = hf.timestamp) !== null && _a !== void 0 ? _a : timestamp), acc);\n      }, timestamp);\n      if (maxTimeStamp < timestamp) {\n        throw Error(`Maximum HF determined by block number/ttd is lower than timestamp HF`);\n      }\n    }\n    const hardfork = hfs[hfIndex];\n    return hardfork.name;\n  }\n  /**\n   * Sets a new hardfork based on the block number or an optional\n   * total difficulty (Merge HF) provided.\n   *\n   * An optional TD takes precedence in case the corresponding HF block\n   * is set to `null` or otherwise needs to match (if not an error\n   * will be thrown).\n   *\n   * @param blockNumber\n   * @param td\n   * @param timestamp\n   * @returns The name of the HF set\n   */\n  setHardforkByBlockNumber(blockNumber, td, timestamp) {\n    const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);\n    this.setHardfork(hardfork);\n    return hardfork;\n  }\n  /**\n   * Internal helper function, returns the params for the given hardfork for the chain set\n   * @param hardfork Hardfork name\n   * @returns Dictionary with hardfork params or null if hardfork not on chain\n   */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  _getHardfork(hardfork) {\n    const hfs = this.hardforks();\n    for (const hf of hfs) {\n      if (hf.name === hardfork) return hf;\n    }\n    // eslint-disable-next-line no-null/no-null\n    return null;\n  }\n  /**\n   * Sets the active EIPs\n   * @param eips\n   */\n  setEIPs(eips = []) {\n    for (const eip of eips) {\n      if (!(eip in EIPs)) {\n        throw new Error(`${eip} not supported`);\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-argument\n      const minHF = this.gteHardfork(EIPs[eip].minimumHardfork);\n      if (!minHF) {\n        throw new Error(\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        `${eip} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${minHF}`);\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (EIPs[eip].requiredEIPs !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        for (const elem of EIPs[eip].requiredEIPs) {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n          if (!(eips.includes(elem) || this.isActivatedEIP(elem))) {\n            throw new Error(\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            `${eip} requires EIP ${elem}, but is not included in the EIP list`);\n          }\n        }\n      }\n    }\n    this._eips = eips;\n  }\n  /**\n   * Returns a parameter for the current chain setup\n   *\n   * If the parameter is present in an EIP, the EIP always takes precedence.\n   * Otherwise the parameter if taken from the latest applied HF with\n   * a change on the respective parameter.\n   *\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @returns The value requested or `BigInt(0)` if not found\n   */\n  param(topic, name) {\n    // TODO: consider the case that different active EIPs\n    // can change the same parameter\n    let value;\n    for (const eip of this._eips) {\n      value = this.paramByEIP(topic, name, eip);\n      if (value !== undefined) return value;\n    }\n    return this.paramByHardfork(topic, name, this._hardfork);\n  }\n  /**\n   * Returns the parameter corresponding to a hardfork\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @param hardfork Hardfork name\n   * @returns The value requested or `BigInt(0)` if not found\n   */\n  paramByHardfork(topic, name, hardfork) {\n    // eslint-disable-next-line no-null/no-null\n    let value = null;\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      // EIP-referencing HF file (e.g. berlin.json)\n      if ('eips' in hfChanges[1]) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment\n        const hfEIPs = hfChanges[1].eips;\n        for (const eip of hfEIPs) {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n          const valueEIP = this.paramByEIP(topic, name, eip);\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          value = typeof valueEIP === 'bigint' ? valueEIP : value;\n        }\n        // Parameter-inlining HF file (e.g. istanbul.json)\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        if (hfChanges[1][topic] === undefined) {\n          throw new Error(`Topic ${topic} not defined`);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        if (hfChanges[1][topic][name] !== undefined) {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment\n          value = hfChanges[1][topic][name].v;\n        }\n      }\n      if (hfChanges[0] === hardfork) break;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    return BigInt(value !== null && value !== void 0 ? value : 0);\n  }\n  /**\n   * Returns a parameter corresponding to an EIP\n   * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')\n   * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n   * @param eip Number of the EIP\n   * @returns The value requested or `undefined` if not found\n   */\n  // eslint-disable-next-line class-methods-use-this\n  paramByEIP(topic, name, eip) {\n    if (!(eip in EIPs)) {\n      throw new Error(`${eip} not supported`);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const eipParams = EIPs[eip];\n    if (!(topic in eipParams)) {\n      throw new Error(`Topic ${topic} not defined`);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (eipParams[topic][name] === undefined) {\n      return undefined;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment\n    const value = eipParams[topic][name].v;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    return BigInt(value);\n  }\n  /**\n   * Returns a parameter for the hardfork active on block number or\n   * optional provided total difficulty (Merge HF)\n   * @param topic Parameter topic\n   * @param name Parameter name\n   * @param blockNumber Block number\n   * @param td Total difficulty\n   *    * @returns The value requested or `BigInt(0)` if not found\n   */\n  paramByBlock(topic, name, blockNumber, td, timestamp) {\n    const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);\n    return this.paramByHardfork(topic, name, hardfork);\n  }\n  /**\n   * Checks if an EIP is activated by either being included in the EIPs\n   * manually passed in with the {@link CommonOpts.eips} or in a\n   * hardfork currently being active\n   *\n   * Note: this method only works for EIPs being supported\n   * by the {@link CommonOpts.eips} constructor option\n   * @param eip\n   */\n  isActivatedEIP(eip) {\n    if (this.eips().includes(eip)) {\n      return true;\n    }\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const hf = hfChanges[1];\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-argument\n      if (this.gteHardfork(hf.name) && 'eips' in hf) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        if (hf.eips.includes(eip)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks if set or provided hardfork is active on block number\n   * @param hardfork Hardfork name or null (for HF set)\n   * @param blockNumber\n   * @returns True if HF is active on block number\n   */\n  hardforkIsActiveOnBlock(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  _hardfork, _blockNumber) {\n    const blockNumber = toType(_blockNumber, TypeOutput.BigInt);\n    const hardfork = _hardfork !== null && _hardfork !== void 0 ? _hardfork : this._hardfork;\n    const hfBlock = this.hardforkBlock(hardfork);\n    if (typeof hfBlock === 'bigint' && hfBlock !== BigInt(0) && blockNumber >= hfBlock) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Alias to hardforkIsActiveOnBlock when hardfork is set\n   * @param blockNumber\n   * @returns True if HF is active on block number\n   */\n  activeOnBlock(blockNumber) {\n    // eslint-disable-next-line no-null/no-null\n    return this.hardforkIsActiveOnBlock(null, blockNumber);\n  }\n  /**\n   * Sequence based check if given or set HF1 is greater than or equal HF2\n   * @param hardfork1 Hardfork name or null (if set)\n   * @param hardfork2 Hardfork name\n   * @param opts Hardfork options\n   * @returns True if HF1 gte HF2\n   */\n  hardforkGteHardfork(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  _hardfork1, hardfork2) {\n    const hardfork1 = _hardfork1 !== null && _hardfork1 !== void 0 ? _hardfork1 : this._hardfork;\n    const hardforks = this.hardforks();\n    let posHf1 = -1;\n    let posHf2 = -1;\n    let index = 0;\n    for (const hf of hardforks) {\n      if (hf.name === hardfork1) posHf1 = index;\n      if (hf.name === hardfork2) posHf2 = index;\n      index += 1;\n    }\n    return posHf1 >= posHf2 && posHf2 !== -1;\n  }\n  /**\n   * Alias to hardforkGteHardfork when hardfork is set\n   * @param hardfork Hardfork name\n   * @returns True if hardfork set is greater than hardfork provided\n   */\n  gteHardfork(hardfork) {\n    // eslint-disable-next-line no-null/no-null\n    return this.hardforkGteHardfork(null, hardfork);\n  }\n  /**\n   * Returns the hardfork change block for hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block number or null if unscheduled\n   */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  hardforkBlock(_hardfork) {\n    var _a;\n    const hardfork = _hardfork !== null && _hardfork !== void 0 ? _hardfork : this._hardfork;\n    const block = (_a = this._getHardfork(hardfork)) === null || _a === void 0 ? void 0 : _a.block;\n    // eslint-disable-next-line no-null/no-null\n    if (block === undefined || block === null) {\n      // eslint-disable-next-line no-null/no-null\n      return null;\n    }\n    return BigInt(block);\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  hardforkTimestamp(_hardfork) {\n    var _a;\n    const hardfork = _hardfork !== null && _hardfork !== void 0 ? _hardfork : this._hardfork;\n    const timestamp = (_a = this._getHardfork(hardfork)) === null || _a === void 0 ? void 0 : _a.timestamp;\n    // eslint-disable-next-line no-null/no-null\n    if (timestamp === undefined || timestamp === null) {\n      // eslint-disable-next-line no-null/no-null\n      return null;\n    }\n    return BigInt(timestamp);\n  }\n  /**\n   * Returns the hardfork change block for eip\n   * @param eip EIP number\n   * @returns Block number or null if unscheduled\n   */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  eipBlock(eip) {\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const hf = hfChanges[1];\n      if ('eips' in hf) {\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n        if (hf.eips.includes(eip)) {\n          return this.hardforkBlock(typeof hfChanges[0] === 'number' ? String(hfChanges[0]) : hfChanges[0]);\n        }\n      }\n    }\n    // eslint-disable-next-line no-null/no-null\n    return null;\n  }\n  /**\n   * Returns the hardfork change total difficulty (Merge HF) for hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Total difficulty or null if no set\n   */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  hardforkTTD(_hardfork) {\n    var _a;\n    const hardfork = _hardfork !== null && _hardfork !== void 0 ? _hardfork : this._hardfork;\n    const ttd = (_a = this._getHardfork(hardfork)) === null || _a === void 0 ? void 0 : _a.ttd;\n    // eslint-disable-next-line no-null/no-null\n    if (ttd === undefined || ttd === null) {\n      // eslint-disable-next-line no-null/no-null\n      return null;\n    }\n    return BigInt(ttd);\n  }\n  /**\n   * True if block number provided is the hardfork (given or set) change block\n   * @param blockNumber Number of the block to check\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns True if blockNumber is HF block\n   * @deprecated\n   */\n  isHardforkBlock(_blockNumber, _hardfork) {\n    const blockNumber = toType(_blockNumber, TypeOutput.BigInt);\n    const hardfork = _hardfork !== null && _hardfork !== void 0 ? _hardfork : this._hardfork;\n    const block = this.hardforkBlock(hardfork);\n    return typeof block === 'bigint' && block !== BigInt(0) ? block === blockNumber : false;\n  }\n  /**\n   * Returns the change block for the next hardfork after the hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block timestamp, number or null if not available\n   */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  nextHardforkBlockOrTimestamp(_hardfork) {\n    var _a, _b, _c;\n    const hardfork = (_a = _hardfork) !== null && _a !== void 0 ? _a : this._hardfork;\n    const hfs = this.hardforks();\n    let hfIndex = hfs.findIndex(hf => hf.name === hardfork);\n    // If the current hardfork is merge, go one behind as merge hf is not part of these\n    // calcs even if the merge hf block is set\n    if (hardfork === Hardfork.Merge) {\n      hfIndex -= 1;\n    }\n    // Hardfork not found\n    if (hfIndex < 0) {\n      // eslint-disable-next-line no-null/no-null\n      return null;\n    }\n    let currHfTimeOrBlock = (_b = hfs[hfIndex].timestamp) !== null && _b !== void 0 ? _b : hfs[hfIndex].block;\n    currHfTimeOrBlock =\n    // eslint-disable-next-line no-null/no-null\n    currHfTimeOrBlock !== null && currHfTimeOrBlock !== undefined ? Number(currHfTimeOrBlock) :\n    // eslint-disable-next-line no-null/no-null\n    null;\n    const nextHf = hfs.slice(hfIndex + 1).find(hf => {\n      var _a;\n      let hfTimeOrBlock = (_a = hf.timestamp) !== null && _a !== void 0 ? _a : hf.block;\n      hfTimeOrBlock =\n      // eslint-disable-next-line no-null/no-null\n      hfTimeOrBlock !== null && hfTimeOrBlock !== undefined ? Number(hfTimeOrBlock) :\n      // eslint-disable-next-line no-null/no-null\n      null;\n      return hf.name !== Hardfork.Merge &&\n      // eslint-disable-next-line no-null/no-null\n      hfTimeOrBlock !== null && hfTimeOrBlock !== undefined && hfTimeOrBlock !== currHfTimeOrBlock;\n    });\n    // If no next hf found with valid block or timestamp return null\n    if (nextHf === undefined) {\n      // eslint-disable-next-line no-null/no-null\n      return null;\n    }\n    const nextHfBlock = (_c = nextHf.timestamp) !== null && _c !== void 0 ? _c : nextHf.block;\n    // eslint-disable-next-line no-null/no-null\n    if (nextHfBlock === null || nextHfBlock === undefined) {\n      // eslint-disable-next-line no-null/no-null\n      return null;\n    }\n    return BigInt(nextHfBlock);\n  }\n  /**\n   * Returns the change block for the next hardfork after the hardfork provided or set\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns Block number or null if not available\n   * @deprecated\n   */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  nextHardforkBlock(_hardfork) {\n    var _a;\n    const hardfork = (_a = _hardfork) !== null && _a !== void 0 ? _a : this._hardfork;\n    let hfBlock = this.hardforkBlock(hardfork);\n    // If this is a merge hardfork with block not set, then we fallback to previous hardfork\n    // to find the nextHardforkBlock\n    // eslint-disable-next-line no-null/no-null\n    if (hfBlock === null && hardfork === Hardfork.Merge) {\n      const hfs = this.hardforks();\n      // eslint-disable-next-line no-null/no-null\n      const mergeIndex = hfs.findIndex(hf => hf.ttd !== null && hf.ttd !== undefined);\n      if (mergeIndex < 0) {\n        throw Error(`Merge hardfork should have been found`);\n      }\n      hfBlock = this.hardforkBlock(hfs[mergeIndex - 1].name);\n    }\n    // eslint-disable-next-line no-null/no-null\n    if (hfBlock === null) {\n      // eslint-disable-next-line no-null/no-null\n      return null;\n    }\n    // Next fork block number or null if none available\n    // Logic: if accumulator is still null and on the first occurrence of\n    // a block greater than the current hfBlock set the accumulator,\n    // pass on the accumulator as the final result from this time on\n    // eslint-disable-next-line no-null/no-null, @typescript-eslint/ban-types\n    const nextHfBlock = this.hardforks().reduce((acc, hf) => {\n      // We need to ignore the merge block in our next hardfork calc\n      const block = BigInt(\n      // eslint-disable-next-line no-null/no-null\n      hf.block === null || hf.ttd !== undefined && hf.ttd !== null ? 0 : hf.block);\n      // TypeScript can't seem to follow that the hfBlock is not null at this point\n      // eslint-disable-next-line no-null/no-null\n      return block > hfBlock && acc === null ? block : acc;\n      // eslint-disable-next-line no-null/no-null\n    }, null);\n    return nextHfBlock;\n  }\n  /**\n   * True if block number provided is the hardfork change block following the hardfork given or set\n   * @param blockNumber Number of the block to check\n   * @param hardfork Hardfork name, optional if HF set\n   * @returns True if blockNumber is HF block\n   * @deprecated\n   */\n  isNextHardforkBlock(_blockNumber, _hardfork) {\n    const blockNumber = toType(_blockNumber, TypeOutput.BigInt);\n    const hardfork = _hardfork !== null && _hardfork !== void 0 ? _hardfork : this._hardfork;\n    // eslint-disable-next-line deprecation/deprecation\n    const nextHardforkBlock = this.nextHardforkBlock(hardfork);\n    // eslint-disable-next-line no-null/no-null\n    return nextHardforkBlock === null ? false : nextHardforkBlock === blockNumber;\n  }\n  /**\n   * Internal helper function to calculate a fork hash\n   * @param hardfork Hardfork name\n   * @param genesisHash Genesis block hash of the chain\n   * @returns Fork hash as hex string\n   */\n  _calcForkHash(hardfork, genesisHash) {\n    let hfUint8Array = new Uint8Array();\n    let prevBlockOrTime = 0;\n    for (const hf of this.hardforks()) {\n      const {\n        block,\n        timestamp,\n        name\n      } = hf;\n      // Timestamp to be used for timestamp based hfs even if we may bundle\n      // block number with them retrospectively\n      let blockOrTime = timestamp !== null && timestamp !== void 0 ? timestamp : block;\n      // eslint-disable-next-line no-null/no-null\n      blockOrTime = blockOrTime !== null ? Number(blockOrTime) : null;\n      // Skip for chainstart (0), not applied HFs (null) and\n      // when already applied on same blockOrTime HFs\n      // and on the merge since forkhash doesn't change on merge hf\n      if (typeof blockOrTime === 'number' && blockOrTime !== 0 && blockOrTime !== prevBlockOrTime && name !== Hardfork.Merge) {\n        const hfBlockUint8Array = hexToBytes(blockOrTime.toString(16).padStart(16, '0'));\n        hfUint8Array = uint8ArrayConcat(hfUint8Array, hfBlockUint8Array);\n        prevBlockOrTime = blockOrTime;\n      }\n      if (hf.name === hardfork) break;\n    }\n    const inputUint8Array = uint8ArrayConcat(genesisHash, hfUint8Array);\n    // CRC32 delivers result as signed (negative) 32-bit integer,\n    // convert to hex string\n    // eslint-disable-next-line no-bitwise\n    const forkhash = bytesToHex(intToUint8Array(crc32Uint8Array(inputUint8Array) >>> 0));\n    return forkhash;\n  }\n  /**\n   * Returns an eth/64 compliant fork hash (EIP-2124)\n   * @param hardfork Hardfork name, optional if HF set\n   * @param genesisHash Genesis block hash of the chain, optional if already defined and not needed to be calculated\n   */\n  forkHash(_hardfork, genesisHash) {\n    const hardfork = _hardfork !== null && _hardfork !== void 0 ? _hardfork : this._hardfork;\n    const data = this._getHardfork(hardfork);\n    if (\n    // eslint-disable-next-line no-null/no-null\n    data === null ||\n    // eslint-disable-next-line no-null/no-null\n    (data === null || data === void 0 ? void 0 : data.block) === null && (data === null || data === void 0 ? void 0 : data.timestamp) === undefined && (data === null || data === void 0 ? void 0 : data.ttd) === undefined) {\n      const msg = 'No fork hash calculation possible for future hardfork';\n      throw new Error(msg);\n    }\n    // eslint-disable-next-line no-null/no-null\n    if ((data === null || data === void 0 ? void 0 : data.forkHash) !== null && (data === null || data === void 0 ? void 0 : data.forkHash) !== undefined) {\n      return data.forkHash;\n    }\n    if (!genesisHash) throw new Error('genesisHash required for forkHash calculation');\n    return this._calcForkHash(hardfork, genesisHash);\n  }\n  /**\n   *\n   * @param forkHash Fork hash as a hex string\n   * @returns Array with hardfork data (name, block, forkHash)\n   */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  hardforkForForkHash(forkHash) {\n    const resArray = this.hardforks().filter(hf => hf.forkHash === forkHash);\n    // eslint-disable-next-line no-null/no-null\n    return resArray.length >= 1 ? resArray[resArray.length - 1] : null;\n  }\n  /**\n   * Sets any missing forkHashes on the passed-in {@link Common} instance\n   * @param common The {@link Common} to set the forkHashes for\n   * @param genesisHash The genesis block hash\n   */\n  setForkHashes(genesisHash) {\n    var _a;\n    for (const hf of this.hardforks()) {\n      const blockOrTime = (_a = hf.timestamp) !== null && _a !== void 0 ? _a : hf.block;\n      if (\n      // eslint-disable-next-line no-null/no-null\n      (hf.forkHash === null || hf.forkHash === undefined) && (\n      // eslint-disable-next-line no-null/no-null\n      blockOrTime !== null && blockOrTime !== undefined || typeof hf.ttd !== 'undefined')) {\n        hf.forkHash = this.forkHash(hf.name, genesisHash);\n      }\n    }\n  }\n  /**\n   * Returns the Genesis parameters of the current chain\n   * @returns Genesis dictionary\n   */\n  genesis() {\n    return this._chainParams.genesis;\n  }\n  /**\n   * Returns the hardforks for current chain\n   * @returns {Array} Array with arrays of hardforks\n   */\n  hardforks() {\n    return this._chainParams.hardforks;\n  }\n  /**\n   * Returns bootstrap nodes for the current chain\n   * @returns {Dictionary} Dict with bootstrap nodes\n   */\n  bootstrapNodes() {\n    return this._chainParams.bootstrapNodes;\n  }\n  /**\n   * Returns DNS networks for the current chain\n   * @returns {String[]} Array of DNS ENR urls\n   */\n  dnsNetworks() {\n    return this._chainParams.dnsNetworks;\n  }\n  /**\n   * Returns the hardfork set\n   * @returns Hardfork name\n   */\n  hardfork() {\n    return this._hardfork;\n  }\n  /**\n   * Returns the Id of current chain\n   * @returns chain Id\n   */\n  chainId() {\n    return BigInt(this._chainParams.chainId);\n  }\n  /**\n   * Returns the name of current chain\n   * @returns chain name (lower case)\n   */\n  chainName() {\n    return this._chainParams.name;\n  }\n  /**\n   * Returns the Id of current network\n   * @returns network Id\n   */\n  networkId() {\n    return BigInt(this._chainParams.networkId);\n  }\n  /**\n   * Returns the active EIPs\n   * @returns List of EIPs\n   */\n  eips() {\n    return this._eips;\n  }\n  /**\n   * Returns the consensus type of the network\n   * Possible values: \"pow\"|\"poa\"|\"pos\"\n   *\n   * Note: This value can update along a Hardfork.\n   */\n  consensusType() {\n    const hardfork = this.hardfork();\n    let value;\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment\n        value = hfChanges[1].consensus.type;\n      }\n      if (hfChanges[0] === hardfork) break;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return value !== null && value !== void 0 ? value : this._chainParams.consensus.type;\n  }\n  /**\n   * Returns the concrete consensus implementation\n   * algorithm or protocol for the network\n   * e.g. \"ethash\" for \"pow\" consensus type,\n   * \"clique\" for \"poa\" consensus type or\n   * \"casper\" for \"pos\" consensus type.\n   *\n   * Note: This value can update along a Hardfork.\n   */\n  consensusAlgorithm() {\n    const hardfork = this.hardfork();\n    let value;\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment\n        value = hfChanges[1].consensus.algorithm;\n      }\n      if (hfChanges[0] === hardfork) break;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return value !== null && value !== void 0 ? value : this._chainParams.consensus.algorithm;\n  }\n  /**\n   * Returns a dictionary with consensus configuration\n   * parameters based on the consensus algorithm\n   *\n   * Expected returns (parameters must be present in\n   * the respective chain json files):\n   *\n   * ethash: empty object\n   * clique: period, epoch\n   * casper: empty object\n   *\n   * Note: This value can update along a Hardfork.\n   */\n  consensusConfig() {\n    var _a;\n    const hardfork = this.hardfork();\n    let value;\n    for (const hfChanges of this.HARDFORK_CHANGES) {\n      if ('consensus' in hfChanges[1]) {\n        // The config parameter is named after the respective consensus algorithm\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment\n        value = hfChanges[1].consensus[hfChanges[1].consensus.algorithm];\n      }\n      if (hfChanges[0] === hardfork) break;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return (_a = value !== null && value !== void 0 ? value : this._chainParams.consensus[this.consensusAlgorithm()]) !== null && _a !== void 0 ? _a : {};\n  }\n  /**\n   * Returns a deep copy of this {@link Common} instance.\n   */\n  copy() {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment\n    const copy = Object.assign(Object.create(Object.getPrototypeOf(this)), this);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n    copy.removeAllListeners();\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return copy;\n  }\n  static _getInitializedChains(customChains) {\n    const names = {};\n    for (const [name, id] of Object.entries(Chain)) {\n      names[id] = name.toLowerCase();\n    }\n    const chains = {\n      mainnet,\n      goerli,\n      sepolia\n    };\n    if (customChains) {\n      for (const chain of customChains) {\n        const {\n          name\n        } = chain;\n        names[chain.chainId.toString()] = name;\n        chains[name] = chain;\n      }\n    }\n    chains.names = names;\n    return chains;\n  }\n}\n//# sourceMappingURL=common.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}