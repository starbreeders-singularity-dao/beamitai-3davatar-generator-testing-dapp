{"ast":null,"code":"import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit(bvh, nodeIndices = null) {\n  if (nodeIndices && Array.isArray(nodeIndices)) {\n    nodeIndices = new Set(nodeIndices);\n  }\n  const geometry = bvh.geometry;\n  const indexArr = geometry.index ? geometry.index.array : null;\n  const posAttr = geometry.attributes.position;\n  let buffer, uint32Array, uint16Array, float32Array;\n  let byteOffset = 0;\n  const roots = bvh._roots;\n  for (let i = 0, l = roots.length; i < l; i++) {\n    buffer = roots[i];\n    uint32Array = new Uint32Array(buffer);\n    uint16Array = new Uint16Array(buffer);\n    float32Array = new Float32Array(buffer);\n    _traverse(0, byteOffset);\n    byteOffset += buffer.byteLength;\n  }\n  function _traverse(node32Index, byteOffset, force = false) {\n    const node16Index = node32Index * 2;\n    const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n    if (isLeaf) {\n      const offset = uint32Array[node32Index + 6];\n      const count = uint16Array[node16Index + 14];\n      let minx = Infinity;\n      let miny = Infinity;\n      let minz = Infinity;\n      let maxx = -Infinity;\n      let maxy = -Infinity;\n      let maxz = -Infinity;\n      for (let i = 3 * offset, l = 3 * (offset + count); i < l; i++) {\n        let index = indexArr[i];\n        const x = posAttr.getX(index);\n        const y = posAttr.getY(index);\n        const z = posAttr.getZ(index);\n        if (x < minx) minx = x;\n        if (x > maxx) maxx = x;\n        if (y < miny) miny = y;\n        if (y > maxy) maxy = y;\n        if (z < minz) minz = z;\n        if (z > maxz) maxz = z;\n      }\n      if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n        float32Array[node32Index + 0] = minx;\n        float32Array[node32Index + 1] = miny;\n        float32Array[node32Index + 2] = minz;\n        float32Array[node32Index + 3] = maxx;\n        float32Array[node32Index + 4] = maxy;\n        float32Array[node32Index + 5] = maxz;\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      const left = node32Index + 8;\n      const right = uint32Array[node32Index + 6];\n\n      // the identifying node indices provided by the shapecast function include offsets of all\n      // root buffers to guarantee they're unique between roots so offset left and right indices here.\n      const offsetLeft = left + byteOffset;\n      const offsetRight = right + byteOffset;\n      let forceChildren = force;\n      let includesLeft = false;\n      let includesRight = false;\n      if (nodeIndices) {\n        // if we see that neither the left or right child are included in the set that need to be updated\n        // then we assume that all children need to be updated.\n        if (!forceChildren) {\n          includesLeft = nodeIndices.has(offsetLeft);\n          includesRight = nodeIndices.has(offsetRight);\n          forceChildren = !includesLeft && !includesRight;\n        }\n      } else {\n        includesLeft = true;\n        includesRight = true;\n      }\n      const traverseLeft = forceChildren || includesLeft;\n      const traverseRight = forceChildren || includesRight;\n      let leftChange = false;\n      if (traverseLeft) {\n        leftChange = _traverse(left, byteOffset, forceChildren);\n      }\n      let rightChange = false;\n      if (traverseRight) {\n        rightChange = _traverse(right, byteOffset, forceChildren);\n      }\n      const didChange = leftChange || rightChange;\n      if (didChange) {\n        for (let i = 0; i < 3; i++) {\n          const lefti = left + i;\n          const righti = right + i;\n          const minLeftValue = float32Array[lefti];\n          const maxLeftValue = float32Array[lefti + 3];\n          const minRightValue = float32Array[righti];\n          const maxRightValue = float32Array[righti + 3];\n          float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n          float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n        }\n      }\n      return didChange;\n    }\n  }\n}\nexport { refit };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}