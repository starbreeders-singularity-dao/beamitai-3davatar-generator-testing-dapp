{"ast":null,"code":"import { isAddress } from './validation/address.js';\nimport { isBlockNumber, isBlockNumberOrTag, isBlockTag } from './validation/block.js';\nimport { isBloom } from './validation/bloom.js';\nimport { isBoolean } from './validation/boolean.js';\nimport { isBytes } from './validation/bytes.js';\nimport { isFilterObject } from './validation/filter.js';\nimport { isHexStrict, isString } from './validation/string.js';\nimport { isNumber, isInt, isUInt } from './validation/numbers.js';\nconst formats = {\n  address: data => isAddress(data),\n  bloom: data => isBloom(data),\n  blockNumber: data => isBlockNumber(data),\n  blockTag: data => isBlockTag(data),\n  blockNumberOrTag: data => isBlockNumberOrTag(data),\n  bool: data => isBoolean(data),\n  bytes: data => isBytes(data),\n  filter: data => isFilterObject(data),\n  hex: data => isHexStrict(data),\n  uint: data => isUInt(data),\n  int: data => isInt(data),\n  number: data => isNumber(data),\n  string: data => isString(data)\n};\n// generate formats for all numbers types\nfor (let bitSize = 8; bitSize <= 256; bitSize += 8) {\n  formats[`int${bitSize}`] = data => isInt(data, {\n    bitSize\n  });\n  formats[`uint${bitSize}`] = data => isUInt(data, {\n    bitSize\n  });\n}\n// generate bytes\nfor (let size = 1; size <= 32; size += 1) {\n  formats[`bytes${size}`] = data => isBytes(data, {\n    size\n  });\n}\nformats.bytes256 = formats.bytes;\nexport default formats;\n//# sourceMappingURL=formats.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}