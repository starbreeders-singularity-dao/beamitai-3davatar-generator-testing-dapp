{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { toChecksumAddress, utf8ToHex } from 'web3-utils';\nimport { formatTransaction } from 'web3-eth';\nimport { ETH_DATA_FORMAT } from 'web3-types';\nimport { validator, isHexStrict } from 'web3-validator';\nimport { personalRpcMethods } from 'web3-rpc-methods';\nexport const getAccounts = requestManager => __awaiter(void 0, void 0, void 0, function* () {\n  const result = yield personalRpcMethods.getAccounts(requestManager);\n  return result.map(toChecksumAddress);\n});\nexport const newAccount = (requestManager, password) => __awaiter(void 0, void 0, void 0, function* () {\n  validator.validate(['string'], [password]);\n  const result = yield personalRpcMethods.newAccount(requestManager, password);\n  return toChecksumAddress(result);\n});\nexport const unlockAccount = (requestManager, address, password, unlockDuration) => __awaiter(void 0, void 0, void 0, function* () {\n  validator.validate(['address', 'string', 'uint'], [address, password, unlockDuration]);\n  return personalRpcMethods.unlockAccount(requestManager, address, password, unlockDuration);\n});\nexport const lockAccount = (requestManager, address) => __awaiter(void 0, void 0, void 0, function* () {\n  validator.validate(['address'], [address]);\n  return personalRpcMethods.lockAccount(requestManager, address);\n});\nexport const importRawKey = (requestManager, keyData, passphrase) => __awaiter(void 0, void 0, void 0, function* () {\n  validator.validate(['string', 'string'], [keyData, passphrase]);\n  return personalRpcMethods.importRawKey(requestManager, keyData, passphrase);\n});\nexport const sendTransaction = (requestManager, tx, passphrase, config) => __awaiter(void 0, void 0, void 0, function* () {\n  const formattedTx = formatTransaction(tx, ETH_DATA_FORMAT, {\n    transactionSchema: config === null || config === void 0 ? void 0 : config.customTransactionSchema\n  });\n  return personalRpcMethods.sendTransaction(requestManager, formattedTx, passphrase);\n});\nexport const signTransaction = (requestManager, tx, passphrase, config) => __awaiter(void 0, void 0, void 0, function* () {\n  const formattedTx = formatTransaction(tx, ETH_DATA_FORMAT, {\n    transactionSchema: config === null || config === void 0 ? void 0 : config.customTransactionSchema\n  });\n  return personalRpcMethods.signTransaction(requestManager, formattedTx, passphrase);\n});\nexport const sign = (requestManager, data, address, passphrase) => __awaiter(void 0, void 0, void 0, function* () {\n  validator.validate(['string', 'address', 'string'], [data, address, passphrase]);\n  const dataToSign = isHexStrict(data) ? data : utf8ToHex(data);\n  return personalRpcMethods.sign(requestManager, dataToSign, address, passphrase);\n});\nexport const ecRecover = (requestManager, signedData, signature) => __awaiter(void 0, void 0, void 0, function* () {\n  validator.validate(['string', 'string'], [signedData, signature]);\n  const signedDataString = isHexStrict(signedData) ? signedData : utf8ToHex(signedData);\n  return personalRpcMethods.ecRecover(requestManager, signedDataString, signature);\n});\n//# sourceMappingURL=rpc_method_wrappers.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}