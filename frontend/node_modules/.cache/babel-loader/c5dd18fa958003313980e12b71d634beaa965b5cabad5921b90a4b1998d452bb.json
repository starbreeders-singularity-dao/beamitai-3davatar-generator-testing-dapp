{"ast":null,"code":"import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */new Matrix4();\nconst obb = /* @__PURE__ */new OrientedBox();\nconst obb2 = /* @__PURE__ */new OrientedBox();\nconst temp1 = /* @__PURE__ */new Vector3();\nconst temp2 = /* @__PURE__ */new Vector3();\nconst temp3 = /* @__PURE__ */new Vector3();\nconst temp4 = /* @__PURE__ */new Vector3();\nfunction closestPointToGeometry(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {\n  if (!otherGeometry.boundingBox) {\n    otherGeometry.computeBoundingBox();\n  }\n  obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n  obb.needsUpdate = true;\n  const geometry = bvh.geometry;\n  const pos = geometry.attributes.position;\n  const index = geometry.index;\n  const otherPos = otherGeometry.attributes.position;\n  const otherIndex = otherGeometry.index;\n  const triangle = ExtendedTrianglePool.getPrimitive();\n  const triangle2 = ExtendedTrianglePool.getPrimitive();\n  let tempTarget1 = temp1;\n  let tempTargetDest1 = temp2;\n  let tempTarget2 = null;\n  let tempTargetDest2 = null;\n  if (target2) {\n    tempTarget2 = temp3;\n    tempTargetDest2 = temp4;\n  }\n  let closestDistance = Infinity;\n  let closestDistanceTriIndex = null;\n  let closestDistanceOtherTriIndex = null;\n  tempMatrix.copy(geometryToBvh).invert();\n  obb2.matrix.copy(tempMatrix);\n  bvh.shapecast({\n    boundsTraverseOrder: box => {\n      return obb.distanceToBox(box);\n    },\n    intersectsBounds: (box, isLeaf, score) => {\n      if (score < closestDistance && score < maxThreshold) {\n        // if we know the triangles of this bounds will be intersected next then\n        // save the bounds to use during triangle checks.\n        if (isLeaf) {\n          obb2.min.copy(box.min);\n          obb2.max.copy(box.max);\n          obb2.needsUpdate = true;\n        }\n        return true;\n      }\n      return false;\n    },\n    intersectsRange: (offset, count) => {\n      if (otherGeometry.boundsTree) {\n        // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n        // the closest bounds in the other geometry to check.\n        const otherBvh = otherGeometry.boundsTree;\n        return otherBvh.shapecast({\n          boundsTraverseOrder: box => {\n            return obb2.distanceToBox(box);\n          },\n          intersectsBounds: (box, isLeaf, score) => {\n            return score < closestDistance && score < maxThreshold;\n          },\n          intersectsRange: (otherOffset, otherCount) => {\n            for (let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++) {\n              setTriangle(triangle2, 3 * i2, otherIndex, otherPos);\n              triangle2.a.applyMatrix4(geometryToBvh);\n              triangle2.b.applyMatrix4(geometryToBvh);\n              triangle2.c.applyMatrix4(geometryToBvh);\n              triangle2.needsUpdate = true;\n              for (let i = offset, l = offset + count; i < l; i++) {\n                setTriangle(triangle, 3 * i, index, pos);\n                triangle.needsUpdate = true;\n                const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                if (dist < closestDistance) {\n                  tempTargetDest1.copy(tempTarget1);\n                  if (tempTargetDest2) {\n                    tempTargetDest2.copy(tempTarget2);\n                  }\n                  closestDistance = dist;\n                  closestDistanceTriIndex = i;\n                  closestDistanceOtherTriIndex = i2;\n                }\n\n                // stop traversal if we find a point that's under the given threshold\n                if (dist < minThreshold) {\n                  return true;\n                }\n              }\n            }\n          }\n        });\n      } else {\n        // If no bounds tree then we'll just check every triangle.\n        const triCount = getTriCount(otherGeometry);\n        for (let i2 = 0, l2 = triCount; i2 < l2; i2++) {\n          setTriangle(triangle2, 3 * i2, otherIndex, otherPos);\n          triangle2.a.applyMatrix4(geometryToBvh);\n          triangle2.b.applyMatrix4(geometryToBvh);\n          triangle2.c.applyMatrix4(geometryToBvh);\n          triangle2.needsUpdate = true;\n          for (let i = offset, l = offset + count; i < l; i++) {\n            setTriangle(triangle, 3 * i, index, pos);\n            triangle.needsUpdate = true;\n            const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n            if (dist < closestDistance) {\n              tempTargetDest1.copy(tempTarget1);\n              if (tempTargetDest2) {\n                tempTargetDest2.copy(tempTarget2);\n              }\n              closestDistance = dist;\n              closestDistanceTriIndex = i;\n              closestDistanceOtherTriIndex = i2;\n            }\n\n            // stop traversal if we find a point that's under the given threshold\n            if (dist < minThreshold) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  });\n  ExtendedTrianglePool.releasePrimitive(triangle);\n  ExtendedTrianglePool.releasePrimitive(triangle2);\n  if (closestDistance === Infinity) {\n    return null;\n  }\n  if (!target1.point) {\n    target1.point = tempTargetDest1.clone();\n  } else {\n    target1.point.copy(tempTargetDest1);\n  }\n  target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;\n  if (target2) {\n    if (!target2.point) target2.point = tempTargetDest2.clone();else target2.point.copy(tempTargetDest2);\n    target2.point.applyMatrix4(tempMatrix);\n    tempTargetDest1.applyMatrix4(tempMatrix);\n    target2.distance = tempTargetDest1.sub(target2.point).length();\n    target2.faceIndex = closestDistanceOtherTriIndex;\n  }\n  return target1;\n}\nexport { closestPointToGeometry };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}