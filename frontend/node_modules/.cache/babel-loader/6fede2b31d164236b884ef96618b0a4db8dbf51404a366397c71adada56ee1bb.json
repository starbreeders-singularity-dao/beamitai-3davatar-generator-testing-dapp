{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, Group, MeshPhongMaterial, DoubleSide, AdditiveBlending, BufferGeometry, Mesh, Float32BufferAttribute, Matrix4, TextureLoader, Color } from \"three\";\nclass TDSLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.debug = false;\n    this.group = null;\n    this.position = 0;\n    this.materials = [];\n    this.meshes = [];\n  }\n  /**\n   * Load 3ds file from url.\n   *\n   * @method load\n   * @param {[type]} url URL for the file.\n   * @param {Function} onLoad onLoad callback, receives group Object3D as argument.\n   * @param {Function} onProgress onProgress callback.\n   * @param {Function} onError onError callback.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = this.path === \"\" ? LoaderUtils.extractUrlBase(url) : this.path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        onLoad(scope.parse(data, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  /**\n   * Parse arraybuffer data and load 3ds file.\n   *\n   * @method parse\n   * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n   * @param {String} path Path for external resources.\n   * @return {Group} Group loaded from 3ds file.\n   */\n  parse(arraybuffer, path) {\n    this.group = new Group();\n    this.position = 0;\n    this.materials = [];\n    this.meshes = [];\n    this.readFile(arraybuffer, path);\n    for (let i = 0; i < this.meshes.length; i++) {\n      this.group.add(this.meshes[i]);\n    }\n    return this.group;\n  }\n  /**\n   * Decode file content to read 3ds data.\n   *\n   * @method readFile\n   * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n   * @param {String} path Path for external resources.\n   */\n  readFile(arraybuffer, path) {\n    const data = new DataView(arraybuffer);\n    const chunk = this.readChunk(data);\n    if (chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC) {\n      let next = this.nextChunk(data, chunk);\n      while (next !== 0) {\n        if (next === M3D_VERSION) {\n          const version = this.readDWord(data);\n          this.debugMessage(\"3DS file version: \" + version);\n        } else if (next === MDATA) {\n          this.resetPosition(data);\n          this.readMeshData(data, path);\n        } else {\n          this.debugMessage(\"Unknown main chunk: \" + next.toString(16));\n        }\n        next = this.nextChunk(data, chunk);\n      }\n    }\n    this.debugMessage(\"Parsed \" + this.meshes.length + \" meshes\");\n  }\n  /**\n   * Read mesh data chunk.\n   *\n   * @method readMeshData\n   * @param {Dataview} data Dataview in use.\n   * @param {String} path Path for external resources.\n   */\n  readMeshData(data, path) {\n    const chunk = this.readChunk(data);\n    let next = this.nextChunk(data, chunk);\n    while (next !== 0) {\n      if (next === MESH_VERSION) {\n        const version = +this.readDWord(data);\n        this.debugMessage(\"Mesh Version: \" + version);\n      } else if (next === MASTER_SCALE) {\n        const scale = this.readFloat(data);\n        this.debugMessage(\"Master scale: \" + scale);\n        this.group.scale.set(scale, scale, scale);\n      } else if (next === NAMED_OBJECT) {\n        this.debugMessage(\"Named Object\");\n        this.resetPosition(data);\n        this.readNamedObject(data);\n      } else if (next === MAT_ENTRY) {\n        this.debugMessage(\"Material\");\n        this.resetPosition(data);\n        this.readMaterialEntry(data, path);\n      } else {\n        this.debugMessage(\"Unknown MDATA chunk: \" + next.toString(16));\n      }\n      next = this.nextChunk(data, chunk);\n    }\n  }\n  /**\n   * Read named object chunk.\n   *\n   * @method readNamedObject\n   * @param {Dataview} data Dataview in use.\n   */\n  readNamedObject(data) {\n    const chunk = this.readChunk(data);\n    const name = this.readString(data, 64);\n    chunk.cur = this.position;\n    let next = this.nextChunk(data, chunk);\n    while (next !== 0) {\n      if (next === N_TRI_OBJECT) {\n        this.resetPosition(data);\n        const mesh = this.readMesh(data);\n        mesh.name = name;\n        this.meshes.push(mesh);\n      } else {\n        this.debugMessage(\"Unknown named object chunk: \" + next.toString(16));\n      }\n      next = this.nextChunk(data, chunk);\n    }\n    this.endChunk(chunk);\n  }\n  /**\n   * Read material data chunk and add it to the material list.\n   *\n   * @method readMaterialEntry\n   * @param {Dataview} data Dataview in use.\n   * @param {String} path Path for external resources.\n   */\n  readMaterialEntry(data, path) {\n    const chunk = this.readChunk(data);\n    let next = this.nextChunk(data, chunk);\n    const material = new MeshPhongMaterial();\n    while (next !== 0) {\n      if (next === MAT_NAME) {\n        material.name = this.readString(data, 64);\n        this.debugMessage(\"   Name: \" + material.name);\n      } else if (next === MAT_WIRE) {\n        this.debugMessage(\"   Wireframe\");\n        material.wireframe = true;\n      } else if (next === MAT_WIRE_SIZE) {\n        const value = this.readByte(data);\n        material.wireframeLinewidth = value;\n        this.debugMessage(\"   Wireframe Thickness: \" + value);\n      } else if (next === MAT_TWO_SIDE) {\n        material.side = DoubleSide;\n        this.debugMessage(\"   DoubleSided\");\n      } else if (next === MAT_ADDITIVE) {\n        this.debugMessage(\"   Additive Blending\");\n        material.blending = AdditiveBlending;\n      } else if (next === MAT_DIFFUSE) {\n        this.debugMessage(\"   Diffuse Color\");\n        material.color = this.readColor(data);\n      } else if (next === MAT_SPECULAR) {\n        this.debugMessage(\"   Specular Color\");\n        material.specular = this.readColor(data);\n      } else if (next === MAT_AMBIENT) {\n        this.debugMessage(\"   Ambient color\");\n        material.color = this.readColor(data);\n      } else if (next === MAT_SHININESS) {\n        const shininess = this.readPercentage(data);\n        material.shininess = shininess * 100;\n        this.debugMessage(\"   Shininess : \" + shininess);\n      } else if (next === MAT_TRANSPARENCY) {\n        const transparency = this.readPercentage(data);\n        material.opacity = 1 - transparency;\n        this.debugMessage(\"  Transparency : \" + transparency);\n        material.transparent = material.opacity < 1 ? true : false;\n      } else if (next === MAT_TEXMAP) {\n        this.debugMessage(\"   ColorMap\");\n        this.resetPosition(data);\n        material.map = this.readMap(data, path);\n      } else if (next === MAT_BUMPMAP) {\n        this.debugMessage(\"   BumpMap\");\n        this.resetPosition(data);\n        material.bumpMap = this.readMap(data, path);\n      } else if (next === MAT_OPACMAP) {\n        this.debugMessage(\"   OpacityMap\");\n        this.resetPosition(data);\n        material.alphaMap = this.readMap(data, path);\n      } else if (next === MAT_SPECMAP) {\n        this.debugMessage(\"   SpecularMap\");\n        this.resetPosition(data);\n        material.specularMap = this.readMap(data, path);\n      } else {\n        this.debugMessage(\"   Unknown material chunk: \" + next.toString(16));\n      }\n      next = this.nextChunk(data, chunk);\n    }\n    this.endChunk(chunk);\n    this.materials[material.name] = material;\n  }\n  /**\n   * Read mesh data chunk.\n   *\n   * @method readMesh\n   * @param {Dataview} data Dataview in use.\n   * @return {Mesh} The parsed mesh.\n   */\n  readMesh(data) {\n    const chunk = this.readChunk(data);\n    let next = this.nextChunk(data, chunk);\n    const geometry = new BufferGeometry();\n    const material = new MeshPhongMaterial();\n    const mesh = new Mesh(geometry, material);\n    mesh.name = \"mesh\";\n    while (next !== 0) {\n      if (next === POINT_ARRAY) {\n        const points = this.readWord(data);\n        this.debugMessage(\"   Vertex: \" + points);\n        const vertices = [];\n        for (let i = 0; i < points; i++) {\n          vertices.push(this.readFloat(data));\n          vertices.push(this.readFloat(data));\n          vertices.push(this.readFloat(data));\n        }\n        geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n      } else if (next === FACE_ARRAY) {\n        this.resetPosition(data);\n        this.readFaceArray(data, mesh);\n      } else if (next === TEX_VERTS) {\n        const texels = this.readWord(data);\n        this.debugMessage(\"   UV: \" + texels);\n        const uvs = [];\n        for (let i = 0; i < texels; i++) {\n          uvs.push(this.readFloat(data));\n          uvs.push(this.readFloat(data));\n        }\n        geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n      } else if (next === MESH_MATRIX) {\n        this.debugMessage(\"   Tranformation Matrix (TODO)\");\n        const values = [];\n        for (let i = 0; i < 12; i++) {\n          values[i] = this.readFloat(data);\n        }\n        const matrix = new Matrix4();\n        matrix.elements[0] = values[0];\n        matrix.elements[1] = values[6];\n        matrix.elements[2] = values[3];\n        matrix.elements[3] = values[9];\n        matrix.elements[4] = values[2];\n        matrix.elements[5] = values[8];\n        matrix.elements[6] = values[5];\n        matrix.elements[7] = values[11];\n        matrix.elements[8] = values[1];\n        matrix.elements[9] = values[7];\n        matrix.elements[10] = values[4];\n        matrix.elements[11] = values[10];\n        matrix.elements[12] = 0;\n        matrix.elements[13] = 0;\n        matrix.elements[14] = 0;\n        matrix.elements[15] = 1;\n        matrix.transpose();\n        const inverse = new Matrix4();\n        inverse.copy(matrix).invert();\n        geometry.applyMatrix4(inverse);\n        matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);\n      } else {\n        this.debugMessage(\"   Unknown mesh chunk: \" + next.toString(16));\n      }\n      next = this.nextChunk(data, chunk);\n    }\n    this.endChunk(chunk);\n    geometry.computeVertexNormals();\n    return mesh;\n  }\n  /**\n   * Read face array data chunk.\n   *\n   * @method readFaceArray\n   * @param {Dataview} data Dataview in use.\n   * @param {Mesh} mesh Mesh to be filled with the data read.\n   */\n  readFaceArray(data, mesh) {\n    const chunk = this.readChunk(data);\n    const faces = this.readWord(data);\n    this.debugMessage(\"   Faces: \" + faces);\n    const index = [];\n    for (let i = 0; i < faces; ++i) {\n      index.push(this.readWord(data), this.readWord(data), this.readWord(data));\n      this.readWord(data);\n    }\n    mesh.geometry.setIndex(index);\n    let materialIndex = 0;\n    let start = 0;\n    while (this.position < chunk.end) {\n      const subchunk = this.readChunk(data);\n      if (subchunk.id === MSH_MAT_GROUP) {\n        this.debugMessage(\"      Material Group\");\n        this.resetPosition(data);\n        const group = this.readMaterialGroup(data);\n        const count = group.index.length * 3;\n        mesh.geometry.addGroup(start, count, materialIndex);\n        start += count;\n        materialIndex++;\n        const material = this.materials[group.name];\n        if (Array.isArray(mesh.material) === false) mesh.material = [];\n        if (material !== void 0) {\n          mesh.material.push(material);\n        }\n      } else {\n        this.debugMessage(\"      Unknown face array chunk: \" + subchunk.toString(16));\n      }\n      this.endChunk(subchunk);\n    }\n    if (mesh.material.length === 1) mesh.material = mesh.material[0];\n    this.endChunk(chunk);\n  }\n  /**\n   * Read texture map data chunk.\n   *\n   * @method readMap\n   * @param {Dataview} data Dataview in use.\n   * @param {String} path Path for external resources.\n   * @return {Texture} Texture read from this data chunk.\n   */\n  readMap(data, path) {\n    const chunk = this.readChunk(data);\n    let next = this.nextChunk(data, chunk);\n    let texture = {};\n    const loader = new TextureLoader(this.manager);\n    loader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    while (next !== 0) {\n      if (next === MAT_MAPNAME) {\n        const name = this.readString(data, 128);\n        texture = loader.load(name);\n        this.debugMessage(\"      File: \" + path + name);\n      } else if (next === MAT_MAP_UOFFSET) {\n        texture.offset.x = this.readFloat(data);\n        this.debugMessage(\"      OffsetX: \" + texture.offset.x);\n      } else if (next === MAT_MAP_VOFFSET) {\n        texture.offset.y = this.readFloat(data);\n        this.debugMessage(\"      OffsetY: \" + texture.offset.y);\n      } else if (next === MAT_MAP_USCALE) {\n        texture.repeat.x = this.readFloat(data);\n        this.debugMessage(\"      RepeatX: \" + texture.repeat.x);\n      } else if (next === MAT_MAP_VSCALE) {\n        texture.repeat.y = this.readFloat(data);\n        this.debugMessage(\"      RepeatY: \" + texture.repeat.y);\n      } else {\n        this.debugMessage(\"      Unknown map chunk: \" + next.toString(16));\n      }\n      next = this.nextChunk(data, chunk);\n    }\n    this.endChunk(chunk);\n    return texture;\n  }\n  /**\n   * Read material group data chunk.\n   *\n   * @method readMaterialGroup\n   * @param {Dataview} data Dataview in use.\n   * @return {Object} Object with name and index of the object.\n   */\n  readMaterialGroup(data) {\n    this.readChunk(data);\n    const name = this.readString(data, 64);\n    const numFaces = this.readWord(data);\n    this.debugMessage(\"         Name: \" + name);\n    this.debugMessage(\"         Faces: \" + numFaces);\n    const index = [];\n    for (let i = 0; i < numFaces; ++i) {\n      index.push(this.readWord(data));\n    }\n    return {\n      name,\n      index\n    };\n  }\n  /**\n   * Read a color value.\n   *\n   * @method readColor\n   * @param {DataView} data Dataview.\n   * @return {Color} Color value read..\n   */\n  readColor(data) {\n    const chunk = this.readChunk(data);\n    const color = new Color();\n    if (chunk.id === COLOR_24 || chunk.id === LIN_COLOR_24) {\n      const r = this.readByte(data);\n      const g = this.readByte(data);\n      const b = this.readByte(data);\n      color.setRGB(r / 255, g / 255, b / 255);\n      this.debugMessage(\"      Color: \" + color.r + \", \" + color.g + \", \" + color.b);\n    } else if (chunk.id === COLOR_F || chunk.id === LIN_COLOR_F) {\n      const r = this.readFloat(data);\n      const g = this.readFloat(data);\n      const b = this.readFloat(data);\n      color.setRGB(r, g, b);\n      this.debugMessage(\"      Color: \" + color.r + \", \" + color.g + \", \" + color.b);\n    } else {\n      this.debugMessage(\"      Unknown color chunk: \" + chunk.toString(16));\n    }\n    this.endChunk(chunk);\n    return color;\n  }\n  /**\n   * Read next chunk of data.\n   *\n   * @method readChunk\n   * @param {DataView} data Dataview.\n   * @return {Object} Chunk of data read.\n   */\n  readChunk(data) {\n    const chunk = {};\n    chunk.cur = this.position;\n    chunk.id = this.readWord(data);\n    chunk.size = this.readDWord(data);\n    chunk.end = chunk.cur + chunk.size;\n    chunk.cur += 6;\n    return chunk;\n  }\n  /**\n   * Set position to the end of the current chunk of data.\n   *\n   * @method endChunk\n   * @param {Object} chunk Data chunk.\n   */\n  endChunk(chunk) {\n    this.position = chunk.end;\n  }\n  /**\n   * Move to the next data chunk.\n   *\n   * @method nextChunk\n   * @param {DataView} data Dataview.\n   * @param {Object} chunk Data chunk.\n   */\n  nextChunk(data, chunk) {\n    if (chunk.cur >= chunk.end) {\n      return 0;\n    }\n    this.position = chunk.cur;\n    try {\n      const next = this.readChunk(data);\n      chunk.cur += next.size;\n      return next.id;\n    } catch (e) {\n      this.debugMessage(\"Unable to read chunk at \" + this.position);\n      return 0;\n    }\n  }\n  /**\n   * Reset dataview position.\n   *\n   * @method resetPosition\n   */\n  resetPosition() {\n    this.position -= 6;\n  }\n  /**\n   * Read byte value.\n   *\n   * @method readByte\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readByte(data) {\n    const v = data.getUint8(this.position, true);\n    this.position += 1;\n    return v;\n  }\n  /**\n   * Read 32 bit float value.\n   *\n   * @method readFloat\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readFloat(data) {\n    try {\n      const v = data.getFloat32(this.position, true);\n      this.position += 4;\n      return v;\n    } catch (e) {\n      this.debugMessage(e + \" \" + this.position + \" \" + data.byteLength);\n    }\n  }\n  /**\n   * Read 32 bit signed integer value.\n   *\n   * @method readInt\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readInt(data) {\n    const v = data.getInt32(this.position, true);\n    this.position += 4;\n    return v;\n  }\n  /**\n   * Read 16 bit signed integer value.\n   *\n   * @method readShort\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readShort(data) {\n    const v = data.getInt16(this.position, true);\n    this.position += 2;\n    return v;\n  }\n  /**\n   * Read 64 bit unsigned integer value.\n   *\n   * @method readDWord\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readDWord(data) {\n    const v = data.getUint32(this.position, true);\n    this.position += 4;\n    return v;\n  }\n  /**\n   * Read 32 bit unsigned integer value.\n   *\n   * @method readWord\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readWord(data) {\n    const v = data.getUint16(this.position, true);\n    this.position += 2;\n    return v;\n  }\n  /**\n   * Read string value.\n   *\n   * @method readString\n   * @param {DataView} data Dataview to read data from.\n   * @param {Number} maxLength Max size of the string to be read.\n   * @return {String} Data read from the dataview.\n   */\n  readString(data, maxLength) {\n    let s = \"\";\n    for (let i = 0; i < maxLength; i++) {\n      const c = this.readByte(data);\n      if (!c) {\n        break;\n      }\n      s += String.fromCharCode(c);\n    }\n    return s;\n  }\n  /**\n   * Read percentage value.\n   *\n   * @method readPercentage\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readPercentage(data) {\n    const chunk = this.readChunk(data);\n    let value;\n    switch (chunk.id) {\n      case INT_PERCENTAGE:\n        value = this.readShort(data) / 100;\n        break;\n      case FLOAT_PERCENTAGE:\n        value = this.readFloat(data);\n        break;\n      default:\n        this.debugMessage(\"      Unknown percentage chunk: \" + chunk.toString(16));\n    }\n    this.endChunk(chunk);\n    return value;\n  }\n  /**\n   * Print debug message to the console.\n   *\n   * Is controlled by a flag to show or hide debug messages.\n   *\n   * @method debugMessage\n   * @param {Object} message Debug message to print to the console.\n   */\n  debugMessage(message) {\n    if (this.debug) {\n      console.log(message);\n    }\n  }\n}\nconst M3DMAGIC = 19789;\nconst MLIBMAGIC = 15786;\nconst CMAGIC = 49725;\nconst M3D_VERSION = 2;\nconst COLOR_F = 16;\nconst COLOR_24 = 17;\nconst LIN_COLOR_24 = 18;\nconst LIN_COLOR_F = 19;\nconst INT_PERCENTAGE = 48;\nconst FLOAT_PERCENTAGE = 49;\nconst MDATA = 15677;\nconst MESH_VERSION = 15678;\nconst MASTER_SCALE = 256;\nconst MAT_ENTRY = 45055;\nconst MAT_NAME = 40960;\nconst MAT_AMBIENT = 40976;\nconst MAT_DIFFUSE = 40992;\nconst MAT_SPECULAR = 41008;\nconst MAT_SHININESS = 41024;\nconst MAT_TRANSPARENCY = 41040;\nconst MAT_TWO_SIDE = 41089;\nconst MAT_ADDITIVE = 41091;\nconst MAT_WIRE = 41093;\nconst MAT_WIRE_SIZE = 41095;\nconst MAT_TEXMAP = 41472;\nconst MAT_OPACMAP = 41488;\nconst MAT_BUMPMAP = 41520;\nconst MAT_SPECMAP = 41476;\nconst MAT_MAPNAME = 41728;\nconst MAT_MAP_USCALE = 41812;\nconst MAT_MAP_VSCALE = 41814;\nconst MAT_MAP_UOFFSET = 41816;\nconst MAT_MAP_VOFFSET = 41818;\nconst NAMED_OBJECT = 16384;\nconst N_TRI_OBJECT = 16640;\nconst POINT_ARRAY = 16656;\nconst FACE_ARRAY = 16672;\nconst MSH_MAT_GROUP = 16688;\nconst TEX_VERTS = 16704;\nconst MESH_MATRIX = 16736;\nexport { TDSLoader };\n//# sourceMappingURL=TDSLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}