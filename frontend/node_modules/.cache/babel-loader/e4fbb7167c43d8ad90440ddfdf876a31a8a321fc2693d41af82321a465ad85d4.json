{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Matrix4, Mesh, BufferGeometry, MathUtils, DataTexture, RGBAFormat, FloatType, BufferAttribute } from \"three\";\nconst ID_ATTR_NAME = \"_batch_id_\";\nconst _identityMatrix = new Matrix4();\nconst _zeroScaleMatrix = new Matrix4().set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);\nconst batchingParsVertex = /* glsl */\n`\n#ifdef BATCHING\n\tattribute float ${ID_ATTR_NAME};\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\n\t}\n#endif\n`;\nconst batchingbaseVertex = /* glsl */\n`\n#ifdef BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( ${ID_ATTR_NAME} );\n#endif\n`;\nconst batchingnormalVertex = /* glsl */\n`\n#ifdef BATCHING\n\tobjectNormal = vec4( batchingMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( batchingMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\n`;\nconst batchingVertex = /* glsl */\n`\n#ifdef BATCHING\n\ttransformed = ( batchingMatrix * vec4( transformed, 1.0 ) ).xyz;\n#endif\n`;\nfunction copyAttributeData(src, target, targetOffset = 0) {\n  const itemSize = target.itemSize;\n  if (src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor) {\n    const vertexCount = src.count;\n    for (let i = 0; i < vertexCount; i++) {\n      for (let c = 0; c < itemSize; c++) {\n        target.setComponent(i + targetOffset, c, src.getComponent(i, c));\n      }\n    }\n  } else {\n    target.array.set(src.array, targetOffset * itemSize);\n  }\n  target.needsUpdate = true;\n}\nclass BatchedMesh extends Mesh {\n  constructor(maxGeometryCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material) {\n    super(new BufferGeometry(), material);\n    __publicField(this, \"_vertexStarts\");\n    __publicField(this, \"_vertexCounts\");\n    __publicField(this, \"_indexStarts\");\n    __publicField(this, \"_indexCounts\");\n    __publicField(this, \"_reservedRanges\");\n    __publicField(this, \"_visible\");\n    __publicField(this, \"_active\");\n    __publicField(this, \"_maxGeometryCount\");\n    __publicField(this, \"_maxVertexCount\");\n    __publicField(this, \"_maxIndexCount\");\n    __publicField(this, \"_geometryInitialized\");\n    __publicField(this, \"_geometryCount\");\n    __publicField(this, \"_matrices\");\n    __publicField(this, \"_matricesTexture\");\n    __publicField(this, \"_customUniforms\");\n    this._vertexStarts = [];\n    this._vertexCounts = [];\n    this._indexStarts = [];\n    this._indexCounts = [];\n    this._reservedRanges = [];\n    this._visible = [];\n    this._active = [];\n    this._maxGeometryCount = maxGeometryCount;\n    this._maxVertexCount = maxVertexCount;\n    this._maxIndexCount = maxIndexCount;\n    this._geometryInitialized = false;\n    this._geometryCount = 0;\n    this._matrices = [];\n    this._matricesTexture = null;\n    this.frustumCulled = false;\n    this._customUniforms = {\n      batchingTexture: {\n        value: null\n      }\n    };\n    this._initMatricesTexture();\n    this._initShader();\n    this.onBeforeRender = function () {\n      if (this.material.defines) {\n        this.material.defines.BATCHING = true;\n      }\n    };\n    this.onAfterRender = function () {\n      if (this.material.defines) {\n        this.material.defines.BATCHING = false;\n      }\n    };\n  }\n  _initMatricesTexture() {\n    let size = Math.sqrt(this._maxGeometryCount * 4);\n    size = MathUtils.ceilPowerOfTwo(size);\n    size = Math.max(size, 4);\n    const matricesArray = new Float32Array(size * size * 4);\n    const matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType);\n    this._matricesTexture = matricesTexture;\n    this._customUniforms.batchingTexture.value = this._matricesTexture;\n  }\n  _initShader() {\n    const material = this.material;\n    const currentOnBeforeCompile = material.onBeforeCompile;\n    const customUniforms = this._customUniforms;\n    material.onBeforeCompile = function onBeforeCompile(parameters, renderer) {\n      parameters.vertexShader = parameters.vertexShader.replace(\"#include <skinning_pars_vertex>\", \"#include <skinning_pars_vertex>\\n\" + batchingParsVertex).replace(\"#include <uv_vertex>\", \"#include <uv_vertex>\\n\" + batchingbaseVertex).replace(\"#include <skinnormal_vertex>\", \"#include <skinnormal_vertex>\\n\" + batchingnormalVertex).replace(\"#include <skinning_vertex>\", \"#include <skinning_vertex>\\n\" + batchingVertex);\n      for (const uniformName in customUniforms) {\n        parameters.uniforms[uniformName] = customUniforms[uniformName];\n      }\n      currentOnBeforeCompile.call(this, parameters, renderer);\n    };\n    material.defines = material.defines || {};\n    material.defines.BATCHING = false;\n  }\n  _initializeGeometry(reference) {\n    const geometry = this.geometry;\n    const maxVertexCount = this._maxVertexCount;\n    const maxGeometryCount = this._maxGeometryCount;\n    const maxIndexCount = this._maxIndexCount;\n    if (this._geometryInitialized === false) {\n      for (const attributeName in reference.attributes) {\n        const srcAttribute = reference.getAttribute(attributeName);\n        const {\n          array,\n          itemSize,\n          normalized\n        } = srcAttribute;\n        const dstArray = new array.constructor(maxVertexCount * itemSize);\n        const dstAttribute = new srcAttribute.constructor(dstArray, itemSize, normalized);\n        dstAttribute.setUsage(srcAttribute.usage);\n        geometry.setAttribute(attributeName, dstAttribute);\n      }\n      if (reference.getIndex() !== null) {\n        const indexArray = maxVertexCount > 65536 ? new Uint32Array(maxIndexCount) : new Uint16Array(maxIndexCount);\n        geometry.setIndex(new BufferAttribute(indexArray, 1));\n      }\n      const idArray = maxGeometryCount > 65536 ? new Uint32Array(maxVertexCount) : new Uint16Array(maxVertexCount);\n      geometry.setAttribute(ID_ATTR_NAME, new BufferAttribute(idArray, 1));\n      this._geometryInitialized = true;\n    }\n  }\n  // Make sure the geometry is compatible with the existing combined geometry atributes\n  _validateGeometry(geometry) {\n    if (geometry.getAttribute(ID_ATTR_NAME)) {\n      throw new Error(`BatchedMesh: Geometry cannot use attribute \"${ID_ATTR_NAME}\"`);\n    }\n    const batchGeometry = this.geometry;\n    if (Boolean(geometry.getIndex()) !== Boolean(batchGeometry.getIndex())) {\n      throw new Error('BatchedMesh: All geometries must consistently have \"index\".');\n    }\n    for (const attributeName in batchGeometry.attributes) {\n      if (attributeName === ID_ATTR_NAME) {\n        continue;\n      }\n      if (!geometry.hasAttribute(attributeName)) {\n        throw new Error(`BatchedMesh: Added geometry missing \"${attributeName}\". All geometries must have consistent attributes.`);\n      }\n      const srcAttribute = geometry.getAttribute(attributeName);\n      const dstAttribute = batchGeometry.getAttribute(attributeName);\n      if (srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized) {\n        throw new Error(\"BatchedMesh: All attributes must have a consistent itemSize and normalized value.\");\n      }\n    }\n  }\n  getGeometryCount() {\n    return this._geometryCount;\n  }\n  getVertexCount() {\n    const reservedRanges = this._reservedRanges;\n    if (reservedRanges.length === 0) {\n      return 0;\n    } else {\n      const finalRange = reservedRanges[reservedRanges.length - 1];\n      return finalRange.vertexStart + finalRange.vertexCount;\n    }\n  }\n  getIndexCount() {\n    const reservedRanges = this._reservedRanges;\n    const geometry = this.geometry;\n    if (geometry.getIndex() === null || reservedRanges.length === 0) {\n      return 0;\n    } else {\n      const finalRange = reservedRanges[reservedRanges.length - 1];\n      return finalRange.indexStart + finalRange.indexCount;\n    }\n  }\n  addGeometry(geometry, vertexCount = -1, indexCount = -1) {\n    this._initializeGeometry(geometry);\n    this._validateGeometry(geometry);\n    if (this._geometryCount >= this._maxGeometryCount) {\n      throw new Error(\"BatchedMesh: Maximum geometry count reached.\");\n    }\n    const range = {\n      vertexStart: -1,\n      vertexCount: -1,\n      indexStart: -1,\n      indexCount: -1\n    };\n    let lastRange = null;\n    const reservedRanges = this._reservedRanges;\n    if (this._geometryCount !== 0) {\n      lastRange = reservedRanges[reservedRanges.length - 1];\n    }\n    if (vertexCount === -1) {\n      range.vertexCount = geometry.getAttribute(\"position\").count;\n    } else {\n      range.vertexCount = vertexCount;\n    }\n    if (lastRange === null) {\n      range.vertexStart = 0;\n    } else {\n      range.vertexStart = lastRange.vertexStart + lastRange.vertexCount;\n    }\n    if (geometry.getIndex() !== null) {\n      if (indexCount === -1) {\n        range.indexCount = geometry.getIndex().count;\n      } else {\n        range.indexCount = indexCount;\n      }\n      if (lastRange === null) {\n        range.indexStart = 0;\n      } else {\n        range.indexStart = lastRange.indexStart + lastRange.indexCount;\n      }\n    }\n    if (range.indexStart !== -1 && range.indexStart + range.indexCount > this._maxIndexCount || range.vertexStart + range.vertexCount > this._maxVertexCount) {\n      throw new Error(\"BatchedMesh: Reserved space request exceeds the maximum buffer size.\");\n    }\n    const indexCounts = this._indexCounts;\n    const indexStarts = this._indexStarts;\n    const vertexCounts = this._vertexCounts;\n    const vertexStarts = this._vertexStarts;\n    const visible = this._visible;\n    const active = this._active;\n    const matricesTexture = this._matricesTexture;\n    const matrices = this._matrices;\n    const matricesArray = this._matricesTexture.image.data;\n    visible.push(true);\n    active.push(true);\n    const geometryId = this._geometryCount;\n    this._geometryCount++;\n    matrices.push(new Matrix4());\n    _identityMatrix.toArray(matricesArray, geometryId * 16);\n    matricesTexture.needsUpdate = true;\n    reservedRanges.push(range);\n    vertexStarts.push(range.vertexStart);\n    vertexCounts.push(range.vertexCount);\n    if (geometry.getIndex() !== null) {\n      indexStarts.push(range.indexCount);\n      indexCounts.push(range.indexCount);\n    }\n    const idAttribute = this.geometry.getAttribute(ID_ATTR_NAME);\n    for (let i = 0; i < range.vertexCount; i++) {\n      idAttribute.setX(range.vertexStart + i, geometryId);\n    }\n    idAttribute.needsUpdate = true;\n    this.setGeometryAt(geometryId, geometry);\n    return geometryId;\n  }\n  /**\n   * @deprecated use `addGeometry` instead.\n   */\n  applyGeometry(geometry) {\n    return this.addGeometry(geometry);\n  }\n  setGeometryAt(id, geometry) {\n    if (id >= this._geometryCount) {\n      throw new Error(\"BatchedMesh: Maximum geometry count reached.\");\n    }\n    this._validateGeometry(geometry);\n    const range = this._reservedRanges[id];\n    if (geometry.getIndex() !== null && geometry.getIndex().count > range.indexCount || geometry.attributes.position.count > range.vertexCount) {\n      throw new Error(\"BatchedMesh: Reserved space not large enough for provided geometry.\");\n    }\n    const batchGeometry = this.geometry;\n    const srcPositionAttribute = geometry.getAttribute(\"position\");\n    const hasIndex = batchGeometry.getIndex() !== null;\n    const dstIndex = batchGeometry.getIndex();\n    const srcIndex = geometry.getIndex();\n    const vertexStart = range.vertexStart;\n    const vertexCount = range.vertexCount;\n    for (const attributeName in batchGeometry.attributes) {\n      if (attributeName === ID_ATTR_NAME) {\n        continue;\n      }\n      const srcAttribute = geometry.getAttribute(attributeName);\n      const dstAttribute = batchGeometry.getAttribute(attributeName);\n      copyAttributeData(srcAttribute, dstAttribute, vertexStart);\n      const itemSize = srcAttribute.itemSize;\n      for (let i = srcAttribute.count, l = vertexCount; i < l; i++) {\n        const index = vertexStart + i;\n        for (let c = 0; c < itemSize; c++) {\n          dstAttribute.setComponent(index, c, 0);\n        }\n      }\n      dstAttribute.needsUpdate = true;\n    }\n    this._vertexCounts[id] = srcPositionAttribute.count;\n    if (hasIndex) {\n      const indexStart = range.indexStart;\n      for (let i = 0; i < srcIndex.count; i++) {\n        dstIndex.setX(indexStart + i, vertexStart + srcIndex.getX(i));\n      }\n      for (let i = srcIndex.count, l = range.indexCount; i < l; i++) {\n        dstIndex.setX(indexStart + i, vertexStart);\n      }\n      dstIndex.needsUpdate = true;\n      this._indexCounts[id] = srcIndex.count;\n    }\n    return id;\n  }\n  deleteGeometry(geometryId) {\n    const active = this._active;\n    const matricesTexture = this._matricesTexture;\n    const matricesArray = matricesTexture.image.data;\n    if (geometryId >= active.length || active[geometryId] === false) {\n      return this;\n    }\n    active[geometryId] = false;\n    _zeroScaleMatrix.toArray(matricesArray, geometryId * 16);\n    matricesTexture.needsUpdate = true;\n    return this;\n  }\n  optimize() {\n    throw new Error(\"BatchedMesh: Optimize function not implemented.\");\n  }\n  setMatrixAt(geometryId, matrix) {\n    const visible = this._visible;\n    const active = this._active;\n    const matricesTexture = this._matricesTexture;\n    const matrices = this._matrices;\n    const matricesArray = matricesTexture.image.data;\n    if (geometryId >= matrices.length || active[geometryId] === false) {\n      return this;\n    }\n    if (visible[geometryId] === true) {\n      matrix.toArray(matricesArray, geometryId * 16);\n      matricesTexture.needsUpdate = true;\n    }\n    matrices[geometryId].copy(matrix);\n    return this;\n  }\n  getMatrixAt(geometryId, matrix) {\n    const matrices = this._matrices;\n    const active = this._active;\n    if (geometryId >= matrices.length || active[geometryId] === false) {\n      return matrix;\n    }\n    return matrix.copy(matrices[geometryId]);\n  }\n  setVisibleAt(geometryId, value) {\n    const visible = this._visible;\n    const active = this._active;\n    const matricesTexture = this._matricesTexture;\n    const matrices = this._matrices;\n    const matricesArray = matricesTexture.image.data;\n    if (geometryId >= visible.length || active[geometryId] === false || visible[geometryId] === value) {\n      return this;\n    }\n    if (value === true) {\n      matrices[geometryId].toArray(matricesArray, geometryId * 16);\n    } else {\n      _zeroScaleMatrix.toArray(matricesArray, geometryId * 16);\n    }\n    matricesTexture.needsUpdate = true;\n    visible[geometryId] = value;\n    return this;\n  }\n  getVisibleAt(geometryId) {\n    const visible = this._visible;\n    const active = this._active;\n    if (geometryId >= visible.length || active[geometryId] === false) {\n      return false;\n    }\n    return visible[geometryId];\n  }\n  raycast() {\n    console.warn(\"BatchedMesh: Raycast function not implemented.\");\n  }\n  copy() {\n    throw new Error(\"BatchedMesh: Copy function not implemented.\");\n  }\n  toJSON() {\n    throw new Error(\"BatchedMesh: toJSON function not implemented.\");\n  }\n  dispose() {\n    this.geometry.dispose();\n    this._matricesTexture.dispose();\n    this._matricesTexture = null;\n    return this;\n  }\n}\nexport { BatchedMesh };\n//# sourceMappingURL=BatchedMesh.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}