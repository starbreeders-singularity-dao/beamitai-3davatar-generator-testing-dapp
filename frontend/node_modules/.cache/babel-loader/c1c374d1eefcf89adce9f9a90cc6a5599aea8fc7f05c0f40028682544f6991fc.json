{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BoxGeometry, BufferGeometry, DoubleSide, Float32BufferAttribute, Mesh, PlaneGeometry, Vector2 } from 'three';\nimport { Damper } from './Damper.js';\nconst RADIUS = 0.2;\nconst LINE_WIDTH = 0.03;\nconst MAX_OPACITY = 0.75;\nconst SEGMENTS = 12;\nconst DELTA_PHI = Math.PI / (2 * SEGMENTS);\nconst vector2 = new Vector2();\n/**\n * Adds a quarter-annulus of vertices to the array, centered on cornerX,\n * cornerY.\n */\nconst addCorner = (vertices, cornerX, cornerY) => {\n  let phi = cornerX > 0 ? cornerY > 0 ? 0 : -Math.PI / 2 : cornerY > 0 ? Math.PI / 2 : Math.PI;\n  for (let i = 0; i <= SEGMENTS; ++i) {\n    vertices.push(cornerX + (RADIUS - LINE_WIDTH) * Math.cos(phi), cornerY + (RADIUS - LINE_WIDTH) * Math.sin(phi), 0, cornerX + RADIUS * Math.cos(phi), cornerY + RADIUS * Math.sin(phi), 0);\n    phi += DELTA_PHI;\n  }\n};\n/**\n * This class is a set of two coincident planes. The first is just a cute box\n * outline with rounded corners and damped opacity to indicate the floor extents\n * of a scene. It is purposely larger than the scene's bounding box by RADIUS on\n * all sides so that small scenes are still visible / selectable. Its center is\n * actually carved out by vertices to ensure its fragment shader doesn't add\n * much time.\n *\n * The child plane is a simple plane with the same extents for use in hit\n * testing (translation is triggered when the touch hits the plane, rotation\n * otherwise).\n */\nexport class PlacementBox extends Mesh {\n  constructor(scene, side) {\n    const geometry = new BufferGeometry();\n    const triangles = [];\n    const vertices = [];\n    const {\n      size,\n      boundingBox\n    } = scene;\n    const x = size.x / 2;\n    const y = (side === 'back' ? size.y : size.z) / 2;\n    addCorner(vertices, x, y);\n    addCorner(vertices, -x, y);\n    addCorner(vertices, -x, -y);\n    addCorner(vertices, x, -y);\n    const numVertices = vertices.length / 3;\n    for (let i = 0; i < numVertices - 2; i += 2) {\n      triangles.push(i, i + 1, i + 3, i, i + 3, i + 2);\n    }\n    const i = numVertices - 2;\n    triangles.push(i, i + 1, 1, i, 1, 0);\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    geometry.setIndex(triangles);\n    super(geometry);\n    this.side = side;\n    const material = this.material;\n    material.side = DoubleSide;\n    material.transparent = true;\n    material.opacity = 0;\n    this.goalOpacity = 0;\n    this.opacityDamper = new Damper();\n    this.hitPlane = new Mesh(new PlaneGeometry(2 * (x + RADIUS), 2 * (y + RADIUS)));\n    this.hitPlane.visible = false;\n    this.hitPlane.material.side = DoubleSide;\n    this.add(this.hitPlane);\n    // The box matches the dimensions of the plane (extra radius all around),\n    // but only the top is expanded by radius, not the bottom.\n    this.hitBox = new Mesh(new BoxGeometry(size.x + 2 * RADIUS, size.y + RADIUS, size.z + 2 * RADIUS));\n    this.hitBox.visible = false;\n    this.hitBox.material.side = DoubleSide;\n    this.add(this.hitBox);\n    boundingBox.getCenter(this.position);\n    switch (side) {\n      case 'bottom':\n        this.rotateX(-Math.PI / 2);\n        this.shadowHeight = boundingBox.min.y;\n        this.position.y = this.shadowHeight;\n        break;\n      case 'back':\n        this.shadowHeight = boundingBox.min.z;\n        this.position.z = this.shadowHeight;\n    }\n    scene.target.add(this);\n    this.hitBox.position.y = (size.y + RADIUS) / 2 + boundingBox.min.y;\n    scene.target.add(this.hitBox);\n    this.offsetHeight = 0;\n  }\n  /**\n   * Get the world hit position if the touch coordinates hit the box, and null\n   * otherwise. Pass the scene in to get access to its raycaster.\n   */\n  getHit(scene, screenX, screenY) {\n    vector2.set(screenX, -screenY);\n    this.hitPlane.visible = true;\n    const hitResult = scene.positionAndNormalFromPoint(vector2, this.hitPlane);\n    this.hitPlane.visible = false;\n    return hitResult == null ? null : hitResult.position;\n  }\n  getExpandedHit(scene, screenX, screenY) {\n    this.hitPlane.scale.set(1000, 1000, 1000);\n    this.hitPlane.updateMatrixWorld();\n    const hitResult = this.getHit(scene, screenX, screenY);\n    this.hitPlane.scale.set(1, 1, 1);\n    return hitResult;\n  }\n  controllerIntersection(scene, controller) {\n    this.hitBox.visible = true;\n    const hitResult = scene.hitFromController(controller, this.hitBox);\n    this.hitBox.visible = false;\n    return hitResult;\n  }\n  /**\n   * Offset the height of the box relative to the bottom of the scene. Positive\n   * is up, so generally only negative values are used.\n   */\n  set offsetHeight(offset) {\n    offset -= 0.001; // push 1 mm below shadow to avoid z-fighting\n    if (this.side === 'back') {\n      this.position.z = this.shadowHeight + offset;\n    } else {\n      this.position.y = this.shadowHeight + offset;\n    }\n  }\n  get offsetHeight() {\n    if (this.side === 'back') {\n      return this.position.z - this.shadowHeight;\n    } else {\n      return this.position.y - this.shadowHeight;\n    }\n  }\n  /**\n   * Set the box's visibility; it will fade in and out.\n   */\n  set show(visible) {\n    this.goalOpacity = visible ? MAX_OPACITY : 0;\n  }\n  /**\n   * Call on each frame with the frame delta to fade the box.\n   */\n  updateOpacity(delta) {\n    const material = this.material;\n    material.opacity = this.opacityDamper.update(material.opacity, this.goalOpacity, delta, 1);\n    this.visible = material.opacity > 0;\n  }\n  /**\n   * Call this to clean up Three's cache when you remove the box.\n   */\n  dispose() {\n    const {\n      geometry,\n      material\n    } = this.hitPlane;\n    geometry.dispose();\n    material.dispose();\n    this.hitBox.geometry.dispose();\n    this.hitBox.material.dispose();\n    this.geometry.dispose();\n    this.material.dispose();\n    this.hitBox.removeFromParent();\n    this.removeFromParent();\n  }\n}\n//# sourceMappingURL=PlacementBox.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}