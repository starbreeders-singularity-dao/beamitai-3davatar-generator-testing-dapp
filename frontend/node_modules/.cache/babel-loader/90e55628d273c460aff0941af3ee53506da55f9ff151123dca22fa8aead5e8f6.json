{"ast":null,"code":"import { Vector4, Vector3 } from \"three\";\nfunction findSpan(p, u, U) {\n  const n = U.length - p - 1;\n  if (u >= U[n]) {\n    return n - 1;\n  }\n  if (u <= U[p]) {\n    return p;\n  }\n  let low = p;\n  let high = n;\n  let mid = Math.floor((low + high) / 2);\n  while (u < U[mid] || u >= U[mid + 1]) {\n    if (u < U[mid]) {\n      high = mid;\n    } else {\n      low = mid;\n    }\n    mid = Math.floor((low + high) / 2);\n  }\n  return mid;\n}\nfunction calcBasisFunctions(span, u, p, U) {\n  const N = [];\n  const left = [];\n  const right = [];\n  N[0] = 1;\n  for (let j = 1; j <= p; ++j) {\n    left[j] = u - U[span + 1 - j];\n    right[j] = U[span + j] - u;\n    let saved = 0;\n    for (let r = 0; r < j; ++r) {\n      const rv = right[r + 1];\n      const lv = left[j - r];\n      const temp = N[r] / (rv + lv);\n      N[r] = saved + rv * temp;\n      saved = lv * temp;\n    }\n    N[j] = saved;\n  }\n  return N;\n}\nfunction calcBSplinePoint(p, U, P, u) {\n  const span = findSpan(p, u, U);\n  const N = calcBasisFunctions(span, u, p, U);\n  const C = new Vector4(0, 0, 0, 0);\n  for (let j = 0; j <= p; ++j) {\n    const point = P[span - p + j];\n    const Nj = N[j];\n    const wNj = point.w * Nj;\n    C.x += point.x * wNj;\n    C.y += point.y * wNj;\n    C.z += point.z * wNj;\n    C.w += point.w * Nj;\n  }\n  return C;\n}\nfunction calcBasisFunctionDerivatives(span, u, p, n, U) {\n  const zeroArr = [];\n  for (let i = 0; i <= p; ++i) zeroArr[i] = 0;\n  const ders = [];\n  for (let i = 0; i <= n; ++i) ders[i] = zeroArr.slice(0);\n  const ndu = [];\n  for (let i = 0; i <= p; ++i) ndu[i] = zeroArr.slice(0);\n  ndu[0][0] = 1;\n  const left = zeroArr.slice(0);\n  const right = zeroArr.slice(0);\n  for (let j = 1; j <= p; ++j) {\n    left[j] = u - U[span + 1 - j];\n    right[j] = U[span + j] - u;\n    let saved = 0;\n    for (let r2 = 0; r2 < j; ++r2) {\n      const rv = right[r2 + 1];\n      const lv = left[j - r2];\n      ndu[j][r2] = rv + lv;\n      const temp = ndu[r2][j - 1] / ndu[j][r2];\n      ndu[r2][j] = saved + rv * temp;\n      saved = lv * temp;\n    }\n    ndu[j][j] = saved;\n  }\n  for (let j = 0; j <= p; ++j) {\n    ders[0][j] = ndu[j][p];\n  }\n  for (let r2 = 0; r2 <= p; ++r2) {\n    let s1 = 0;\n    let s2 = 1;\n    const a = [];\n    for (let i = 0; i <= p; ++i) {\n      a[i] = zeroArr.slice(0);\n    }\n    a[0][0] = 1;\n    for (let k = 1; k <= n; ++k) {\n      let d = 0;\n      const rk = r2 - k;\n      const pk = p - k;\n      if (r2 >= k) {\n        a[s2][0] = a[s1][0] / ndu[pk + 1][rk];\n        d = a[s2][0] * ndu[rk][pk];\n      }\n      const j1 = rk >= -1 ? 1 : -rk;\n      const j2 = r2 - 1 <= pk ? k - 1 : p - r2;\n      for (let j3 = j1; j3 <= j2; ++j3) {\n        a[s2][j3] = (a[s1][j3] - a[s1][j3 - 1]) / ndu[pk + 1][rk + j3];\n        d += a[s2][j3] * ndu[rk + j3][pk];\n      }\n      if (r2 <= pk) {\n        a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r2];\n        d += a[s2][k] * ndu[r2][pk];\n      }\n      ders[k][r2] = d;\n      const j = s1;\n      s1 = s2;\n      s2 = j;\n    }\n  }\n  let r = p;\n  for (let k = 1; k <= n; ++k) {\n    for (let j = 0; j <= p; ++j) {\n      ders[k][j] *= r;\n    }\n    r *= p - k;\n  }\n  return ders;\n}\nfunction calcBSplineDerivatives(p, U, P, u, nd) {\n  const du = nd < p ? nd : p;\n  const CK = [];\n  const span = findSpan(p, u, U);\n  const nders = calcBasisFunctionDerivatives(span, u, p, du, U);\n  const Pw = [];\n  for (let i = 0; i < P.length; ++i) {\n    const point = P[i].clone();\n    const w = point.w;\n    point.x *= w;\n    point.y *= w;\n    point.z *= w;\n    Pw[i] = point;\n  }\n  for (let k = 0; k <= du; ++k) {\n    const point = Pw[span - p].clone().multiplyScalar(nders[k][0]);\n    for (let j = 1; j <= p; ++j) {\n      point.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]));\n    }\n    CK[k] = point;\n  }\n  for (let k = du + 1; k <= nd + 1; ++k) {\n    CK[k] = new Vector4(0, 0, 0);\n  }\n  return CK;\n}\nfunction calcKoverI(k, i) {\n  let nom = 1;\n  for (let j = 2; j <= k; ++j) {\n    nom *= j;\n  }\n  let denom = 1;\n  for (let j = 2; j <= i; ++j) {\n    denom *= j;\n  }\n  for (let j = 2; j <= k - i; ++j) {\n    denom *= j;\n  }\n  return nom / denom;\n}\nfunction calcRationalCurveDerivatives(Pders) {\n  const nd = Pders.length;\n  const Aders = [];\n  const wders = [];\n  for (let i = 0; i < nd; ++i) {\n    const point = Pders[i];\n    Aders[i] = new Vector3(point.x, point.y, point.z);\n    wders[i] = point.w;\n  }\n  const CK = [];\n  for (let k = 0; k < nd; ++k) {\n    const v = Aders[k].clone();\n    for (let i = 1; i <= k; ++i) {\n      v.sub(CK[k - i].clone().multiplyScalar(calcKoverI(k, i) * wders[i]));\n    }\n    CK[k] = v.divideScalar(wders[0]);\n  }\n  return CK;\n}\nfunction calcNURBSDerivatives(p, U, P, u, nd) {\n  const Pders = calcBSplineDerivatives(p, U, P, u, nd);\n  return calcRationalCurveDerivatives(Pders);\n}\nfunction calcSurfacePoint(p, q, U, V, P, u, v, target) {\n  const uspan = findSpan(p, u, U);\n  const vspan = findSpan(q, v, V);\n  const Nu = calcBasisFunctions(uspan, u, p, U);\n  const Nv = calcBasisFunctions(vspan, v, q, V);\n  const temp = [];\n  for (let l = 0; l <= q; ++l) {\n    temp[l] = new Vector4(0, 0, 0, 0);\n    for (let k = 0; k <= p; ++k) {\n      const point = P[uspan - p + k][vspan - q + l].clone();\n      const w = point.w;\n      point.x *= w;\n      point.y *= w;\n      point.z *= w;\n      temp[l].add(point.multiplyScalar(Nu[k]));\n    }\n  }\n  const Sw = new Vector4(0, 0, 0, 0);\n  for (let l = 0; l <= q; ++l) {\n    Sw.add(temp[l].multiplyScalar(Nv[l]));\n  }\n  Sw.divideScalar(Sw.w);\n  target.set(Sw.x, Sw.y, Sw.z);\n}\nexport { calcBSplineDerivatives, calcBSplinePoint, calcBasisFunctionDerivatives, calcBasisFunctions, calcKoverI, calcNURBSDerivatives, calcRationalCurveDerivatives, calcSurfacePoint, findSpan };\n//# sourceMappingURL=NURBSUtils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}