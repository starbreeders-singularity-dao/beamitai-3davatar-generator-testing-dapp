{"ast":null,"code":"import { Loader, FileLoader, TextureLoader, Group, Color, Matrix4, BufferGeometry, Float32BufferAttribute, Mesh, MeshPhongMaterial, BufferAttribute, MeshStandardMaterial, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, LinearFilter, LinearMipmapLinearFilter, NearestFilter } from \"three\";\nimport { unzipSync } from \"fflate\";\nimport { decodeText } from \"../_polyfill/LoaderUtils.js\";\nclass ThreeMFLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.availableExtensions = [];\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (buffer) {\n      try {\n        onLoad(scope.parse(buffer));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(data) {\n    const scope = this;\n    const textureLoader = new TextureLoader(this.manager);\n    function loadDocument(data2) {\n      let zip = null;\n      let file = null;\n      let relsName;\n      let modelRelsName;\n      const modelPartNames = [];\n      const texturesPartNames = [];\n      let modelRels;\n      const modelParts = {};\n      const printTicketParts = {};\n      const texturesParts = {};\n      const otherParts = {};\n      try {\n        zip = unzipSync(new Uint8Array(data2));\n      } catch (e) {\n        if (e instanceof ReferenceError) {\n          console.error(\"THREE.3MFLoader: fflate missing and file is compressed.\");\n          return null;\n        }\n      }\n      for (file in zip) {\n        if (file.match(/\\_rels\\/.rels$/)) {\n          relsName = file;\n        } else if (file.match(/3D\\/_rels\\/.*\\.model\\.rels$/)) {\n          modelRelsName = file;\n        } else if (file.match(/^3D\\/.*\\.model$/)) {\n          modelPartNames.push(file);\n        } else if (file.match(/^3D\\/Metadata\\/.*\\.xml$/)) ;else if (file.match(/^3D\\/Textures?\\/.*/)) {\n          texturesPartNames.push(file);\n        } else if (file.match(/^3D\\/Other\\/.*/)) ;\n      }\n      const relsView = zip[relsName];\n      const relsFileText = decodeText(relsView);\n      const rels = parseRelsXml(relsFileText);\n      if (modelRelsName) {\n        const relsView2 = zip[modelRelsName];\n        const relsFileText2 = decodeText(relsView2);\n        modelRels = parseRelsXml(relsFileText2);\n      }\n      for (let i = 0; i < modelPartNames.length; i++) {\n        const modelPart = modelPartNames[i];\n        const view = zip[modelPart];\n        const fileText = decodeText(view);\n        const xmlData = new DOMParser().parseFromString(fileText, \"application/xml\");\n        if (xmlData.documentElement.nodeName.toLowerCase() !== \"model\") {\n          console.error(\"THREE.3MFLoader: Error loading 3MF - no 3MF document found: \", modelPart);\n        }\n        const modelNode = xmlData.querySelector(\"model\");\n        const extensions = {};\n        for (let i2 = 0; i2 < modelNode.attributes.length; i2++) {\n          const attr = modelNode.attributes[i2];\n          if (attr.name.match(/^xmlns:(.+)$/)) {\n            extensions[attr.value] = RegExp.$1;\n          }\n        }\n        const modelData = parseModelNode(modelNode);\n        modelData[\"xml\"] = modelNode;\n        if (0 < Object.keys(extensions).length) {\n          modelData[\"extensions\"] = extensions;\n        }\n        modelParts[modelPart] = modelData;\n      }\n      for (let i = 0; i < texturesPartNames.length; i++) {\n        const texturesPartName = texturesPartNames[i];\n        texturesParts[texturesPartName] = zip[texturesPartName].buffer;\n      }\n      return {\n        rels,\n        modelRels,\n        model: modelParts,\n        printTicket: printTicketParts,\n        texture: texturesParts,\n        other: otherParts\n      };\n    }\n    function parseRelsXml(relsFileText) {\n      const relationships = [];\n      const relsXmlData = new DOMParser().parseFromString(relsFileText, \"application/xml\");\n      const relsNodes = relsXmlData.querySelectorAll(\"Relationship\");\n      for (let i = 0; i < relsNodes.length; i++) {\n        const relsNode = relsNodes[i];\n        const relationship = {\n          target: relsNode.getAttribute(\"Target\"),\n          //required\n          id: relsNode.getAttribute(\"Id\"),\n          //required\n          type: relsNode.getAttribute(\"Type\")\n          //required\n        };\n        relationships.push(relationship);\n      }\n      return relationships;\n    }\n    function parseMetadataNodes(metadataNodes) {\n      const metadataData = {};\n      for (let i = 0; i < metadataNodes.length; i++) {\n        const metadataNode = metadataNodes[i];\n        const name = metadataNode.getAttribute(\"name\");\n        const validNames = [\"Title\", \"Designer\", \"Description\", \"Copyright\", \"LicenseTerms\", \"Rating\", \"CreationDate\", \"ModificationDate\"];\n        if (0 <= validNames.indexOf(name)) {\n          metadataData[name] = metadataNode.textContent;\n        }\n      }\n      return metadataData;\n    }\n    function parseBasematerialsNode(basematerialsNode) {\n      const basematerialsData = {\n        id: basematerialsNode.getAttribute(\"id\"),\n        // required\n        basematerials: []\n      };\n      const basematerialNodes = basematerialsNode.querySelectorAll(\"base\");\n      for (let i = 0; i < basematerialNodes.length; i++) {\n        const basematerialNode = basematerialNodes[i];\n        const basematerialData = parseBasematerialNode(basematerialNode);\n        basematerialData.index = i;\n        basematerialsData.basematerials.push(basematerialData);\n      }\n      return basematerialsData;\n    }\n    function parseTexture2DNode(texture2DNode) {\n      const texture2dData = {\n        id: texture2DNode.getAttribute(\"id\"),\n        // required\n        path: texture2DNode.getAttribute(\"path\"),\n        // required\n        contenttype: texture2DNode.getAttribute(\"contenttype\"),\n        // required\n        tilestyleu: texture2DNode.getAttribute(\"tilestyleu\"),\n        tilestylev: texture2DNode.getAttribute(\"tilestylev\"),\n        filter: texture2DNode.getAttribute(\"filter\")\n      };\n      return texture2dData;\n    }\n    function parseTextures2DGroupNode(texture2DGroupNode) {\n      const texture2DGroupData = {\n        id: texture2DGroupNode.getAttribute(\"id\"),\n        // required\n        texid: texture2DGroupNode.getAttribute(\"texid\"),\n        // required\n        displaypropertiesid: texture2DGroupNode.getAttribute(\"displaypropertiesid\")\n      };\n      const tex2coordNodes = texture2DGroupNode.querySelectorAll(\"tex2coord\");\n      const uvs = [];\n      for (let i = 0; i < tex2coordNodes.length; i++) {\n        const tex2coordNode = tex2coordNodes[i];\n        const u = tex2coordNode.getAttribute(\"u\");\n        const v = tex2coordNode.getAttribute(\"v\");\n        uvs.push(parseFloat(u), parseFloat(v));\n      }\n      texture2DGroupData[\"uvs\"] = new Float32Array(uvs);\n      return texture2DGroupData;\n    }\n    function parseColorGroupNode(colorGroupNode) {\n      const colorGroupData = {\n        id: colorGroupNode.getAttribute(\"id\"),\n        // required\n        displaypropertiesid: colorGroupNode.getAttribute(\"displaypropertiesid\")\n      };\n      const colorNodes = colorGroupNode.querySelectorAll(\"color\");\n      const colors = [];\n      const colorObject = new Color();\n      for (let i = 0; i < colorNodes.length; i++) {\n        const colorNode = colorNodes[i];\n        const color = colorNode.getAttribute(\"color\");\n        colorObject.setStyle(color.substring(0, 7));\n        colorObject.convertSRGBToLinear();\n        colors.push(colorObject.r, colorObject.g, colorObject.b);\n      }\n      colorGroupData[\"colors\"] = new Float32Array(colors);\n      return colorGroupData;\n    }\n    function parseMetallicDisplaypropertiesNode(metallicDisplaypropetiesNode) {\n      const metallicDisplaypropertiesData = {\n        id: metallicDisplaypropetiesNode.getAttribute(\"id\")\n        // required\n      };\n      const metallicNodes = metallicDisplaypropetiesNode.querySelectorAll(\"pbmetallic\");\n      const metallicData = [];\n      for (let i = 0; i < metallicNodes.length; i++) {\n        const metallicNode = metallicNodes[i];\n        metallicData.push({\n          name: metallicNode.getAttribute(\"name\"),\n          // required\n          metallicness: parseFloat(metallicNode.getAttribute(\"metallicness\")),\n          // required\n          roughness: parseFloat(metallicNode.getAttribute(\"roughness\"))\n          // required\n        });\n      }\n      metallicDisplaypropertiesData.data = metallicData;\n      return metallicDisplaypropertiesData;\n    }\n    function parseBasematerialNode(basematerialNode) {\n      const basematerialData = {};\n      basematerialData[\"name\"] = basematerialNode.getAttribute(\"name\");\n      basematerialData[\"displaycolor\"] = basematerialNode.getAttribute(\"displaycolor\");\n      basematerialData[\"displaypropertiesid\"] = basematerialNode.getAttribute(\"displaypropertiesid\");\n      return basematerialData;\n    }\n    function parseMeshNode(meshNode) {\n      const meshData = {};\n      const vertices = [];\n      const vertexNodes = meshNode.querySelectorAll(\"vertices vertex\");\n      for (let i = 0; i < vertexNodes.length; i++) {\n        const vertexNode = vertexNodes[i];\n        const x = vertexNode.getAttribute(\"x\");\n        const y = vertexNode.getAttribute(\"y\");\n        const z = vertexNode.getAttribute(\"z\");\n        vertices.push(parseFloat(x), parseFloat(y), parseFloat(z));\n      }\n      meshData[\"vertices\"] = new Float32Array(vertices);\n      const triangleProperties = [];\n      const triangles = [];\n      const triangleNodes = meshNode.querySelectorAll(\"triangles triangle\");\n      for (let i = 0; i < triangleNodes.length; i++) {\n        const triangleNode = triangleNodes[i];\n        const v1 = triangleNode.getAttribute(\"v1\");\n        const v2 = triangleNode.getAttribute(\"v2\");\n        const v3 = triangleNode.getAttribute(\"v3\");\n        const p1 = triangleNode.getAttribute(\"p1\");\n        const p2 = triangleNode.getAttribute(\"p2\");\n        const p3 = triangleNode.getAttribute(\"p3\");\n        const pid = triangleNode.getAttribute(\"pid\");\n        const triangleProperty = {};\n        triangleProperty[\"v1\"] = parseInt(v1, 10);\n        triangleProperty[\"v2\"] = parseInt(v2, 10);\n        triangleProperty[\"v3\"] = parseInt(v3, 10);\n        triangles.push(triangleProperty[\"v1\"], triangleProperty[\"v2\"], triangleProperty[\"v3\"]);\n        if (p1) {\n          triangleProperty[\"p1\"] = parseInt(p1, 10);\n        }\n        if (p2) {\n          triangleProperty[\"p2\"] = parseInt(p2, 10);\n        }\n        if (p3) {\n          triangleProperty[\"p3\"] = parseInt(p3, 10);\n        }\n        if (pid) {\n          triangleProperty[\"pid\"] = pid;\n        }\n        if (0 < Object.keys(triangleProperty).length) {\n          triangleProperties.push(triangleProperty);\n        }\n      }\n      meshData[\"triangleProperties\"] = triangleProperties;\n      meshData[\"triangles\"] = new Uint32Array(triangles);\n      return meshData;\n    }\n    function parseComponentsNode(componentsNode) {\n      const components = [];\n      const componentNodes = componentsNode.querySelectorAll(\"component\");\n      for (let i = 0; i < componentNodes.length; i++) {\n        const componentNode = componentNodes[i];\n        const componentData = parseComponentNode(componentNode);\n        components.push(componentData);\n      }\n      return components;\n    }\n    function parseComponentNode(componentNode) {\n      const componentData = {};\n      componentData[\"objectId\"] = componentNode.getAttribute(\"objectid\");\n      const transform = componentNode.getAttribute(\"transform\");\n      if (transform) {\n        componentData[\"transform\"] = parseTransform(transform);\n      }\n      return componentData;\n    }\n    function parseTransform(transform) {\n      const t = [];\n      transform.split(\" \").forEach(function (s) {\n        t.push(parseFloat(s));\n      });\n      const matrix = new Matrix4();\n      matrix.set(t[0], t[3], t[6], t[9], t[1], t[4], t[7], t[10], t[2], t[5], t[8], t[11], 0, 0, 0, 1);\n      return matrix;\n    }\n    function parseObjectNode(objectNode) {\n      const objectData = {\n        type: objectNode.getAttribute(\"type\")\n      };\n      const id = objectNode.getAttribute(\"id\");\n      if (id) {\n        objectData[\"id\"] = id;\n      }\n      const pid = objectNode.getAttribute(\"pid\");\n      if (pid) {\n        objectData[\"pid\"] = pid;\n      }\n      const pindex = objectNode.getAttribute(\"pindex\");\n      if (pindex) {\n        objectData[\"pindex\"] = pindex;\n      }\n      const thumbnail = objectNode.getAttribute(\"thumbnail\");\n      if (thumbnail) {\n        objectData[\"thumbnail\"] = thumbnail;\n      }\n      const partnumber = objectNode.getAttribute(\"partnumber\");\n      if (partnumber) {\n        objectData[\"partnumber\"] = partnumber;\n      }\n      const name = objectNode.getAttribute(\"name\");\n      if (name) {\n        objectData[\"name\"] = name;\n      }\n      const meshNode = objectNode.querySelector(\"mesh\");\n      if (meshNode) {\n        objectData[\"mesh\"] = parseMeshNode(meshNode);\n      }\n      const componentsNode = objectNode.querySelector(\"components\");\n      if (componentsNode) {\n        objectData[\"components\"] = parseComponentsNode(componentsNode);\n      }\n      return objectData;\n    }\n    function parseResourcesNode(resourcesNode) {\n      const resourcesData = {};\n      resourcesData[\"basematerials\"] = {};\n      const basematerialsNodes = resourcesNode.querySelectorAll(\"basematerials\");\n      for (let i = 0; i < basematerialsNodes.length; i++) {\n        const basematerialsNode = basematerialsNodes[i];\n        const basematerialsData = parseBasematerialsNode(basematerialsNode);\n        resourcesData[\"basematerials\"][basematerialsData[\"id\"]] = basematerialsData;\n      }\n      resourcesData[\"texture2d\"] = {};\n      const textures2DNodes = resourcesNode.querySelectorAll(\"texture2d\");\n      for (let i = 0; i < textures2DNodes.length; i++) {\n        const textures2DNode = textures2DNodes[i];\n        const texture2DData = parseTexture2DNode(textures2DNode);\n        resourcesData[\"texture2d\"][texture2DData[\"id\"]] = texture2DData;\n      }\n      resourcesData[\"colorgroup\"] = {};\n      const colorGroupNodes = resourcesNode.querySelectorAll(\"colorgroup\");\n      for (let i = 0; i < colorGroupNodes.length; i++) {\n        const colorGroupNode = colorGroupNodes[i];\n        const colorGroupData = parseColorGroupNode(colorGroupNode);\n        resourcesData[\"colorgroup\"][colorGroupData[\"id\"]] = colorGroupData;\n      }\n      resourcesData[\"pbmetallicdisplayproperties\"] = {};\n      const pbmetallicdisplaypropertiesNodes = resourcesNode.querySelectorAll(\"pbmetallicdisplayproperties\");\n      for (let i = 0; i < pbmetallicdisplaypropertiesNodes.length; i++) {\n        const pbmetallicdisplaypropertiesNode = pbmetallicdisplaypropertiesNodes[i];\n        const pbmetallicdisplaypropertiesData = parseMetallicDisplaypropertiesNode(pbmetallicdisplaypropertiesNode);\n        resourcesData[\"pbmetallicdisplayproperties\"][pbmetallicdisplaypropertiesData[\"id\"]] = pbmetallicdisplaypropertiesData;\n      }\n      resourcesData[\"texture2dgroup\"] = {};\n      const textures2DGroupNodes = resourcesNode.querySelectorAll(\"texture2dgroup\");\n      for (let i = 0; i < textures2DGroupNodes.length; i++) {\n        const textures2DGroupNode = textures2DGroupNodes[i];\n        const textures2DGroupData = parseTextures2DGroupNode(textures2DGroupNode);\n        resourcesData[\"texture2dgroup\"][textures2DGroupData[\"id\"]] = textures2DGroupData;\n      }\n      resourcesData[\"object\"] = {};\n      const objectNodes = resourcesNode.querySelectorAll(\"object\");\n      for (let i = 0; i < objectNodes.length; i++) {\n        const objectNode = objectNodes[i];\n        const objectData = parseObjectNode(objectNode);\n        resourcesData[\"object\"][objectData[\"id\"]] = objectData;\n      }\n      return resourcesData;\n    }\n    function parseBuildNode(buildNode) {\n      const buildData = [];\n      const itemNodes = buildNode.querySelectorAll(\"item\");\n      for (let i = 0; i < itemNodes.length; i++) {\n        const itemNode = itemNodes[i];\n        const buildItem = {\n          objectId: itemNode.getAttribute(\"objectid\")\n        };\n        const transform = itemNode.getAttribute(\"transform\");\n        if (transform) {\n          buildItem[\"transform\"] = parseTransform(transform);\n        }\n        buildData.push(buildItem);\n      }\n      return buildData;\n    }\n    function parseModelNode(modelNode) {\n      const modelData = {\n        unit: modelNode.getAttribute(\"unit\") || \"millimeter\"\n      };\n      const metadataNodes = modelNode.querySelectorAll(\"metadata\");\n      if (metadataNodes) {\n        modelData[\"metadata\"] = parseMetadataNodes(metadataNodes);\n      }\n      const resourcesNode = modelNode.querySelector(\"resources\");\n      if (resourcesNode) {\n        modelData[\"resources\"] = parseResourcesNode(resourcesNode);\n      }\n      const buildNode = modelNode.querySelector(\"build\");\n      if (buildNode) {\n        modelData[\"build\"] = parseBuildNode(buildNode);\n      }\n      return modelData;\n    }\n    function buildTexture(texture2dgroup, objects2, modelData, textureData) {\n      const texid = texture2dgroup.texid;\n      const texture2ds = modelData.resources.texture2d;\n      const texture2d = texture2ds[texid];\n      if (texture2d) {\n        const data2 = textureData[texture2d.path];\n        const type = texture2d.contenttype;\n        const blob = new Blob([data2], {\n          type\n        });\n        const sourceURI = URL.createObjectURL(blob);\n        const texture = textureLoader.load(sourceURI, function () {\n          URL.revokeObjectURL(sourceURI);\n        });\n        if (\"colorSpace\" in texture) texture.colorSpace = \"srgb\";else texture.encoding = 3001;\n        switch (texture2d.tilestyleu) {\n          case \"wrap\":\n            texture.wrapS = RepeatWrapping;\n            break;\n          case \"mirror\":\n            texture.wrapS = MirroredRepeatWrapping;\n            break;\n          case \"none\":\n          case \"clamp\":\n            texture.wrapS = ClampToEdgeWrapping;\n            break;\n          default:\n            texture.wrapS = RepeatWrapping;\n        }\n        switch (texture2d.tilestylev) {\n          case \"wrap\":\n            texture.wrapT = RepeatWrapping;\n            break;\n          case \"mirror\":\n            texture.wrapT = MirroredRepeatWrapping;\n            break;\n          case \"none\":\n          case \"clamp\":\n            texture.wrapT = ClampToEdgeWrapping;\n            break;\n          default:\n            texture.wrapT = RepeatWrapping;\n        }\n        switch (texture2d.filter) {\n          case \"auto\":\n            texture.magFilter = LinearFilter;\n            texture.minFilter = LinearMipmapLinearFilter;\n            break;\n          case \"linear\":\n            texture.magFilter = LinearFilter;\n            texture.minFilter = LinearFilter;\n            break;\n          case \"nearest\":\n            texture.magFilter = NearestFilter;\n            texture.minFilter = NearestFilter;\n            break;\n          default:\n            texture.magFilter = LinearFilter;\n            texture.minFilter = LinearMipmapLinearFilter;\n        }\n        return texture;\n      } else {\n        return null;\n      }\n    }\n    function buildBasematerialsMeshes(basematerials, triangleProperties, meshData, objects2, modelData, textureData, objectData) {\n      const objectPindex = objectData.pindex;\n      const materialMap = {};\n      for (let i = 0, l = triangleProperties.length; i < l; i++) {\n        const triangleProperty = triangleProperties[i];\n        const pindex = triangleProperty.p1 !== void 0 ? triangleProperty.p1 : objectPindex;\n        if (materialMap[pindex] === void 0) materialMap[pindex] = [];\n        materialMap[pindex].push(triangleProperty);\n      }\n      const keys = Object.keys(materialMap);\n      const meshes = [];\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const materialIndex = keys[i];\n        const trianglePropertiesProps = materialMap[materialIndex];\n        const basematerialData = basematerials.basematerials[materialIndex];\n        const material = getBuild(basematerialData, objects2, modelData, textureData, objectData, buildBasematerial);\n        const geometry = new BufferGeometry();\n        const positionData = [];\n        const vertices = meshData.vertices;\n        for (let j = 0, jl = trianglePropertiesProps.length; j < jl; j++) {\n          const triangleProperty = trianglePropertiesProps[j];\n          positionData.push(vertices[triangleProperty.v1 * 3 + 0]);\n          positionData.push(vertices[triangleProperty.v1 * 3 + 1]);\n          positionData.push(vertices[triangleProperty.v1 * 3 + 2]);\n          positionData.push(vertices[triangleProperty.v2 * 3 + 0]);\n          positionData.push(vertices[triangleProperty.v2 * 3 + 1]);\n          positionData.push(vertices[triangleProperty.v2 * 3 + 2]);\n          positionData.push(vertices[triangleProperty.v3 * 3 + 0]);\n          positionData.push(vertices[triangleProperty.v3 * 3 + 1]);\n          positionData.push(vertices[triangleProperty.v3 * 3 + 2]);\n        }\n        geometry.setAttribute(\"position\", new Float32BufferAttribute(positionData, 3));\n        const mesh = new Mesh(geometry, material);\n        meshes.push(mesh);\n      }\n      return meshes;\n    }\n    function buildTexturedMesh(texture2dgroup, triangleProperties, meshData, objects2, modelData, textureData, objectData) {\n      const geometry = new BufferGeometry();\n      const positionData = [];\n      const uvData = [];\n      const vertices = meshData.vertices;\n      const uvs = texture2dgroup.uvs;\n      for (let i = 0, l = triangleProperties.length; i < l; i++) {\n        const triangleProperty = triangleProperties[i];\n        positionData.push(vertices[triangleProperty.v1 * 3 + 0]);\n        positionData.push(vertices[triangleProperty.v1 * 3 + 1]);\n        positionData.push(vertices[triangleProperty.v1 * 3 + 2]);\n        positionData.push(vertices[triangleProperty.v2 * 3 + 0]);\n        positionData.push(vertices[triangleProperty.v2 * 3 + 1]);\n        positionData.push(vertices[triangleProperty.v2 * 3 + 2]);\n        positionData.push(vertices[triangleProperty.v3 * 3 + 0]);\n        positionData.push(vertices[triangleProperty.v3 * 3 + 1]);\n        positionData.push(vertices[triangleProperty.v3 * 3 + 2]);\n        uvData.push(uvs[triangleProperty.p1 * 2 + 0]);\n        uvData.push(uvs[triangleProperty.p1 * 2 + 1]);\n        uvData.push(uvs[triangleProperty.p2 * 2 + 0]);\n        uvData.push(uvs[triangleProperty.p2 * 2 + 1]);\n        uvData.push(uvs[triangleProperty.p3 * 2 + 0]);\n        uvData.push(uvs[triangleProperty.p3 * 2 + 1]);\n      }\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(positionData, 3));\n      geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvData, 2));\n      const texture = getBuild(texture2dgroup, objects2, modelData, textureData, objectData, buildTexture);\n      const material = new MeshPhongMaterial({\n        map: texture,\n        flatShading: true\n      });\n      const mesh = new Mesh(geometry, material);\n      return mesh;\n    }\n    function buildVertexColorMesh(colorgroup, triangleProperties, meshData, objects2, modelData, objectData) {\n      const geometry = new BufferGeometry();\n      const positionData = [];\n      const colorData = [];\n      const vertices = meshData.vertices;\n      const colors = colorgroup.colors;\n      for (let i = 0, l = triangleProperties.length; i < l; i++) {\n        const triangleProperty = triangleProperties[i];\n        const v1 = triangleProperty.v1;\n        const v2 = triangleProperty.v2;\n        const v3 = triangleProperty.v3;\n        positionData.push(vertices[v1 * 3 + 0]);\n        positionData.push(vertices[v1 * 3 + 1]);\n        positionData.push(vertices[v1 * 3 + 2]);\n        positionData.push(vertices[v2 * 3 + 0]);\n        positionData.push(vertices[v2 * 3 + 1]);\n        positionData.push(vertices[v2 * 3 + 2]);\n        positionData.push(vertices[v3 * 3 + 0]);\n        positionData.push(vertices[v3 * 3 + 1]);\n        positionData.push(vertices[v3 * 3 + 2]);\n        const p1 = triangleProperty.p1 !== void 0 ? triangleProperty.p1 : objectData.pindex;\n        const p2 = triangleProperty.p2 !== void 0 ? triangleProperty.p2 : p1;\n        const p3 = triangleProperty.p3 !== void 0 ? triangleProperty.p3 : p1;\n        colorData.push(colors[p1 * 3 + 0]);\n        colorData.push(colors[p1 * 3 + 1]);\n        colorData.push(colors[p1 * 3 + 2]);\n        colorData.push(colors[p2 * 3 + 0]);\n        colorData.push(colors[p2 * 3 + 1]);\n        colorData.push(colors[p2 * 3 + 2]);\n        colorData.push(colors[p3 * 3 + 0]);\n        colorData.push(colors[p3 * 3 + 1]);\n        colorData.push(colors[p3 * 3 + 2]);\n      }\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(positionData, 3));\n      geometry.setAttribute(\"color\", new Float32BufferAttribute(colorData, 3));\n      const material = new MeshPhongMaterial({\n        vertexColors: true,\n        flatShading: true\n      });\n      const mesh = new Mesh(geometry, material);\n      return mesh;\n    }\n    function buildDefaultMesh(meshData) {\n      const geometry = new BufferGeometry();\n      geometry.setIndex(new BufferAttribute(meshData[\"triangles\"], 1));\n      geometry.setAttribute(\"position\", new BufferAttribute(meshData[\"vertices\"], 3));\n      const material = new MeshPhongMaterial({\n        color: 11184895,\n        flatShading: true\n      });\n      const mesh = new Mesh(geometry, material);\n      return mesh;\n    }\n    function buildMeshes(resourceMap, meshData, objects2, modelData, textureData, objectData) {\n      const keys = Object.keys(resourceMap);\n      const meshes = [];\n      for (let i = 0, il = keys.length; i < il; i++) {\n        const resourceId = keys[i];\n        const triangleProperties = resourceMap[resourceId];\n        const resourceType = getResourceType(resourceId, modelData);\n        switch (resourceType) {\n          case \"material\":\n            const basematerials = modelData.resources.basematerials[resourceId];\n            const newMeshes = buildBasematerialsMeshes(basematerials, triangleProperties, meshData, objects2, modelData, textureData, objectData);\n            for (let j = 0, jl = newMeshes.length; j < jl; j++) {\n              meshes.push(newMeshes[j]);\n            }\n            break;\n          case \"texture\":\n            const texture2dgroup = modelData.resources.texture2dgroup[resourceId];\n            meshes.push(buildTexturedMesh(texture2dgroup, triangleProperties, meshData, objects2, modelData, textureData, objectData));\n            break;\n          case \"vertexColors\":\n            const colorgroup = modelData.resources.colorgroup[resourceId];\n            meshes.push(buildVertexColorMesh(colorgroup, triangleProperties, meshData, objects2, modelData, objectData));\n            break;\n          case \"default\":\n            meshes.push(buildDefaultMesh(meshData));\n            break;\n          default:\n            console.error(\"THREE.3MFLoader: Unsupported resource type.\");\n        }\n      }\n      return meshes;\n    }\n    function getResourceType(pid, modelData) {\n      if (modelData.resources.texture2dgroup[pid] !== void 0) {\n        return \"texture\";\n      } else if (modelData.resources.basematerials[pid] !== void 0) {\n        return \"material\";\n      } else if (modelData.resources.colorgroup[pid] !== void 0) {\n        return \"vertexColors\";\n      } else if (pid === \"default\") {\n        return \"default\";\n      } else {\n        return void 0;\n      }\n    }\n    function analyzeObject(modelData, meshData, objectData) {\n      const resourceMap = {};\n      const triangleProperties = meshData[\"triangleProperties\"];\n      const objectPid = objectData.pid;\n      for (let i = 0, l = triangleProperties.length; i < l; i++) {\n        const triangleProperty = triangleProperties[i];\n        let pid = triangleProperty.pid !== void 0 ? triangleProperty.pid : objectPid;\n        if (pid === void 0) pid = \"default\";\n        if (resourceMap[pid] === void 0) resourceMap[pid] = [];\n        resourceMap[pid].push(triangleProperty);\n      }\n      return resourceMap;\n    }\n    function buildGroup(meshData, objects2, modelData, textureData, objectData) {\n      const group = new Group();\n      const resourceMap = analyzeObject(modelData, meshData, objectData);\n      const meshes = buildMeshes(resourceMap, meshData, objects2, modelData, textureData, objectData);\n      for (let i = 0, l = meshes.length; i < l; i++) {\n        group.add(meshes[i]);\n      }\n      return group;\n    }\n    function applyExtensions(extensions, meshData, modelXml) {\n      if (!extensions) {\n        return;\n      }\n      const availableExtensions = [];\n      const keys = Object.keys(extensions);\n      for (let i = 0; i < keys.length; i++) {\n        const ns = keys[i];\n        for (let j = 0; j < scope.availableExtensions.length; j++) {\n          const extension = scope.availableExtensions[j];\n          if (extension.ns === ns) {\n            availableExtensions.push(extension);\n          }\n        }\n      }\n      for (let i = 0; i < availableExtensions.length; i++) {\n        const extension = availableExtensions[i];\n        extension.apply(modelXml, extensions[extension[\"ns\"]], meshData);\n      }\n    }\n    function getBuild(data2, objects2, modelData, textureData, objectData, builder) {\n      if (data2.build !== void 0) return data2.build;\n      data2.build = builder(data2, objects2, modelData, textureData, objectData);\n      return data2.build;\n    }\n    function buildBasematerial(materialData, objects2, modelData) {\n      let material;\n      const displaypropertiesid = materialData.displaypropertiesid;\n      const pbmetallicdisplayproperties = modelData.resources.pbmetallicdisplayproperties;\n      if (displaypropertiesid !== null && pbmetallicdisplayproperties[displaypropertiesid] !== void 0) {\n        const pbmetallicdisplayproperty = pbmetallicdisplayproperties[displaypropertiesid];\n        const metallicData = pbmetallicdisplayproperty.data[materialData.index];\n        material = new MeshStandardMaterial({\n          flatShading: true,\n          roughness: metallicData.roughness,\n          metalness: metallicData.metallicness\n        });\n      } else {\n        material = new MeshPhongMaterial({\n          flatShading: true\n        });\n      }\n      material.name = materialData.name;\n      const displaycolor = materialData.displaycolor;\n      const color = displaycolor.substring(0, 7);\n      material.color.setStyle(color);\n      material.color.convertSRGBToLinear();\n      if (displaycolor.length === 9) {\n        material.opacity = parseInt(displaycolor.charAt(7) + displaycolor.charAt(8), 16) / 255;\n      }\n      return material;\n    }\n    function buildComposite(compositeData, objects2, modelData, textureData) {\n      const composite = new Group();\n      for (let j = 0; j < compositeData.length; j++) {\n        const component = compositeData[j];\n        let build2 = objects2[component.objectId];\n        if (build2 === void 0) {\n          buildObject(component.objectId, objects2, modelData, textureData);\n          build2 = objects2[component.objectId];\n        }\n        const object3D = build2.clone();\n        const transform = component.transform;\n        if (transform) {\n          object3D.applyMatrix4(transform);\n        }\n        composite.add(object3D);\n      }\n      return composite;\n    }\n    function buildObject(objectId, objects2, modelData, textureData) {\n      const objectData = modelData[\"resources\"][\"object\"][objectId];\n      if (objectData[\"mesh\"]) {\n        const meshData = objectData[\"mesh\"];\n        const extensions = modelData[\"extensions\"];\n        const modelXml = modelData[\"xml\"];\n        applyExtensions(extensions, meshData, modelXml);\n        objects2[objectData.id] = getBuild(meshData, objects2, modelData, textureData, objectData, buildGroup);\n      } else {\n        const compositeData = objectData[\"components\"];\n        objects2[objectData.id] = getBuild(compositeData, objects2, modelData, textureData, objectData, buildComposite);\n      }\n    }\n    function buildObjects(data3mf2) {\n      const modelsData = data3mf2.model;\n      const modelRels = data3mf2.modelRels;\n      const objects2 = {};\n      const modelsKeys = Object.keys(modelsData);\n      const textureData = {};\n      if (modelRels) {\n        for (let i = 0, l = modelRels.length; i < l; i++) {\n          const modelRel = modelRels[i];\n          const textureKey = modelRel.target.substring(1);\n          if (data3mf2.texture[textureKey]) {\n            textureData[modelRel.target] = data3mf2.texture[textureKey];\n          }\n        }\n      }\n      for (let i = 0; i < modelsKeys.length; i++) {\n        const modelsKey = modelsKeys[i];\n        const modelData = modelsData[modelsKey];\n        const objectIds = Object.keys(modelData[\"resources\"][\"object\"]);\n        for (let j = 0; j < objectIds.length; j++) {\n          const objectId = objectIds[j];\n          buildObject(objectId, objects2, modelData, textureData);\n        }\n      }\n      return objects2;\n    }\n    function fetch3DModelPart(rels) {\n      for (let i = 0; i < rels.length; i++) {\n        const rel = rels[i];\n        const extension = rel.target.split(\".\").pop();\n        if (extension.toLowerCase() === \"model\") return rel;\n      }\n    }\n    function build(objects2, data3mf2) {\n      const group = new Group();\n      const relationship = fetch3DModelPart(data3mf2[\"rels\"]);\n      const buildData = data3mf2.model[relationship[\"target\"].substring(1)][\"build\"];\n      for (let i = 0; i < buildData.length; i++) {\n        const buildItem = buildData[i];\n        const object3D = objects2[buildItem[\"objectId\"]];\n        const transform = buildItem[\"transform\"];\n        if (transform) {\n          object3D.applyMatrix4(transform);\n        }\n        group.add(object3D);\n      }\n      return group;\n    }\n    const data3mf = loadDocument(data);\n    const objects = buildObjects(data3mf);\n    return build(objects, data3mf);\n  }\n  addExtension(extension) {\n    this.availableExtensions.push(extension);\n  }\n}\nexport { ThreeMFLoader };\n//# sourceMappingURL=3MFLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}