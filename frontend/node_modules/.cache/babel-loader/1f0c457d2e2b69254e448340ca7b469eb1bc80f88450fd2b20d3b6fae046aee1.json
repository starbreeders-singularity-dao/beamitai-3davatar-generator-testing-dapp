{"ast":null,"code":"import * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber';\nimport { Line } from '../../core/Line.js';\nimport { Html } from '../Html.js';\nimport { context } from './context.js';\nconst vec1 = /* @__PURE__ */new THREE.Vector3();\nconst vec2 = /* @__PURE__ */new THREE.Vector3();\nconst calculateOffset = (clickPoint, normal, rayStart, rayDir) => {\n  const e1 = normal.dot(normal);\n  const e2 = normal.dot(clickPoint) - normal.dot(rayStart);\n  const e3 = normal.dot(rayDir);\n  if (e3 === 0) {\n    return -e2 / e1;\n  }\n  vec1.copy(rayDir).multiplyScalar(e1 / e3).sub(normal);\n  vec2.copy(rayDir).multiplyScalar(e2 / e3).add(rayStart).sub(clickPoint);\n  const offset = -vec1.dot(vec2) / vec1.dot(vec1);\n  return offset;\n};\nconst upV = /* @__PURE__ */new THREE.Vector3(0, 1, 0);\nconst offsetMatrix = /* @__PURE__ */new THREE.Matrix4();\nconst AxisArrow = ({\n  direction,\n  axis\n}) => {\n  const {\n    translation,\n    translationLimits,\n    annotations,\n    annotationsClass,\n    depthTest,\n    scale,\n    lineWidth,\n    fixed,\n    axisColors,\n    hoveredColor,\n    opacity,\n    onDragStart,\n    onDrag,\n    onDragEnd,\n    userData\n  } = React.useContext(context);\n\n  // @ts-expect-error new in @react-three/fiber@7.0.5\n  const camControls = useThree(state => state.controls);\n  const divRef = React.useRef(null);\n  const objRef = React.useRef(null);\n  const clickInfo = React.useRef(null);\n  const offset0 = React.useRef(0);\n  const [isHovered, setIsHovered] = React.useState(false);\n  const onPointerDown = React.useCallback(e => {\n    if (annotations) {\n      divRef.current.innerText = `${translation.current[axis].toFixed(2)}`;\n      divRef.current.style.display = 'block';\n    }\n    e.stopPropagation();\n    const rotation = new THREE.Matrix4().extractRotation(objRef.current.matrixWorld);\n    const clickPoint = e.point.clone();\n    const origin = new THREE.Vector3().setFromMatrixPosition(objRef.current.matrixWorld);\n    const dir = direction.clone().applyMatrix4(rotation).normalize();\n    clickInfo.current = {\n      clickPoint,\n      dir\n    };\n    offset0.current = translation.current[axis];\n    onDragStart({\n      component: 'Arrow',\n      axis,\n      origin,\n      directions: [dir]\n    });\n    camControls && (camControls.enabled = false);\n    // @ts-ignore - setPointerCapture is not in the type definition\n    e.target.setPointerCapture(e.pointerId);\n  }, [annotations, direction, camControls, onDragStart, translation, axis]);\n  const onPointerMove = React.useCallback(e => {\n    e.stopPropagation();\n    if (!isHovered) setIsHovered(true);\n    if (clickInfo.current) {\n      const {\n        clickPoint,\n        dir\n      } = clickInfo.current;\n      const [min, max] = (translationLimits == null ? void 0 : translationLimits[axis]) || [undefined, undefined];\n      let offset = calculateOffset(clickPoint, dir, e.ray.origin, e.ray.direction);\n      if (min !== undefined) {\n        offset = Math.max(offset, min - offset0.current);\n      }\n      if (max !== undefined) {\n        offset = Math.min(offset, max - offset0.current);\n      }\n      translation.current[axis] = offset0.current + offset;\n      if (annotations) {\n        divRef.current.innerText = `${translation.current[axis].toFixed(2)}`;\n      }\n      offsetMatrix.makeTranslation(dir.x * offset, dir.y * offset, dir.z * offset);\n      onDrag(offsetMatrix);\n    }\n  }, [annotations, onDrag, isHovered, translation, translationLimits, axis]);\n  const onPointerUp = React.useCallback(e => {\n    if (annotations) {\n      divRef.current.style.display = 'none';\n    }\n    e.stopPropagation();\n    clickInfo.current = null;\n    onDragEnd();\n    camControls && (camControls.enabled = true);\n    // @ts-ignore - releasePointerCapture & PointerEvent#pointerId is not in the type definition\n    e.target.releasePointerCapture(e.pointerId);\n  }, [annotations, camControls, onDragEnd]);\n  const onPointerOut = React.useCallback(e => {\n    e.stopPropagation();\n    setIsHovered(false);\n  }, []);\n  const {\n    cylinderLength,\n    coneWidth,\n    coneLength,\n    matrixL\n  } = React.useMemo(() => {\n    const coneWidth = fixed ? lineWidth / scale * 1.6 : scale / 20;\n    const coneLength = fixed ? 0.2 : scale / 5;\n    const cylinderLength = fixed ? 1 - coneLength : scale - coneLength;\n    const quaternion = new THREE.Quaternion().setFromUnitVectors(upV, direction.clone().normalize());\n    const matrixL = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);\n    return {\n      cylinderLength,\n      coneWidth,\n      coneLength,\n      matrixL\n    };\n  }, [direction, scale, lineWidth, fixed]);\n  const color_ = isHovered ? hoveredColor : axisColors[axis];\n  return /*#__PURE__*/React.createElement(\"group\", {\n    ref: objRef\n  }, /*#__PURE__*/React.createElement(\"group\", {\n    matrix: matrixL,\n    matrixAutoUpdate: false,\n    onPointerDown: onPointerDown,\n    onPointerMove: onPointerMove,\n    onPointerUp: onPointerUp,\n    onPointerOut: onPointerOut\n  }, annotations && /*#__PURE__*/React.createElement(Html, {\n    position: [0, -coneLength, 0]\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      display: 'none',\n      background: '#151520',\n      color: 'white',\n      padding: '6px 8px',\n      borderRadius: 7,\n      whiteSpace: 'nowrap'\n    },\n    className: annotationsClass,\n    ref: divRef\n  })), /*#__PURE__*/React.createElement(\"mesh\", {\n    visible: false,\n    position: [0, (cylinderLength + coneLength) / 2.0, 0],\n    userData: userData\n  }, /*#__PURE__*/React.createElement(\"cylinderGeometry\", {\n    args: [coneWidth * 1.4, coneWidth * 1.4, cylinderLength + coneLength, 8, 1]\n  })), /*#__PURE__*/React.createElement(Line, {\n    transparent: true,\n    raycast: () => null,\n    depthTest: depthTest,\n    points: [0, 0, 0, 0, cylinderLength, 0],\n    lineWidth: lineWidth,\n    side: THREE.DoubleSide,\n    color: color_,\n    opacity: opacity,\n    polygonOffset: true,\n    renderOrder: 1,\n    polygonOffsetFactor: -10,\n    fog: false\n  }), /*#__PURE__*/React.createElement(\"mesh\", {\n    raycast: () => null,\n    position: [0, cylinderLength + coneLength / 2.0, 0],\n    renderOrder: 500\n  }, /*#__PURE__*/React.createElement(\"coneGeometry\", {\n    args: [coneWidth, coneLength, 24, 1]\n  }), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    transparent: true,\n    depthTest: depthTest,\n    color: color_,\n    opacity: opacity,\n    polygonOffset: true,\n    polygonOffsetFactor: -10,\n    fog: false\n  }))));\n};\nexport { AxisArrow, calculateOffset };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}