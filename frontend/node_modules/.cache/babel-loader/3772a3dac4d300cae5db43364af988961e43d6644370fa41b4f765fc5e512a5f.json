{"ast":null,"code":"import { $getLoadedMaterial, $variantIndices } from '../material.js';\nimport { $correlatedObjects } from '../three-dom-element.js';\n// Defines the base level node methods and data.\nexport class Node {\n  constructor(name) {\n    this.name = '';\n    this.children = new Array();\n    this.name = name;\n  }\n}\n// Represents a primitive in a glTF mesh.\nexport class PrimitiveNode extends Node {\n  constructor(mesh, mvMaterials, modelVariants, correlatedSceneGraph) {\n    super(mesh.name);\n    // Maps glTF material index number to a material that this primitive supports.\n    this.materials = new Map();\n    // Maps variant index to material.\n    this.variantToMaterialMap = new Map();\n    this.initialMaterialIdx = 0;\n    this.activeMaterialIdx = 0;\n    this.mesh = mesh;\n    const {\n      gltf,\n      threeGLTF,\n      threeObjectMap\n    } = correlatedSceneGraph;\n    this.parser = threeGLTF.parser;\n    this.modelVariants = modelVariants;\n    this.mesh.userData.variantData = modelVariants;\n    // Captures the primitive's initial material.\n    const materialMappings = threeObjectMap.get(mesh.material);\n    if (materialMappings.materials != null) {\n      this.initialMaterialIdx = this.activeMaterialIdx = materialMappings.materials;\n    } else {\n      console.error(`Primitive (${mesh.name}) missing initial material reference.`);\n    }\n    // Gets the mesh index from the node.\n    const associations = mesh.userData.associations || {};\n    if (associations.meshes == null) {\n      console.error('Mesh is missing primitive index association');\n      return;\n    }\n    // The gltf mesh array to sample from.\n    const meshElementArray = gltf['meshes'] || [];\n    // List of primitives under the mesh.\n    const gltfPrimitives = meshElementArray[associations.meshes].primitives || [];\n    const gltfPrimitive = gltfPrimitives[associations.primitives];\n    if (gltfPrimitive == null) {\n      console.error('Mesh primitive definition is missing.');\n      return;\n    }\n    // Maps the gltfPrimitive default to a material.\n    if (gltfPrimitive.material != null) {\n      this.materials.set(gltfPrimitive.material, mvMaterials[gltfPrimitive.material]);\n    } else {\n      const defaultIdx = mvMaterials.findIndex(mat => {\n        return mat.name === 'Default';\n      });\n      if (defaultIdx >= 0) {\n        this.materials.set(defaultIdx, mvMaterials[defaultIdx]);\n      } else {\n        console.warn('gltfPrimitive has no material!');\n      }\n    }\n    if (gltfPrimitive.extensions && gltfPrimitive.extensions['KHR_materials_variants']) {\n      const variantsExtension = gltfPrimitive.extensions['KHR_materials_variants'];\n      const extensions = threeGLTF.parser.json.extensions;\n      const variantNames = extensions['KHR_materials_variants'].variants;\n      // Provides definition now that we know there are variants to\n      // support.\n      for (const mapping of variantsExtension.mappings) {\n        const mvMaterial = mvMaterials[mapping.material];\n        // Maps variant indices to Materials.\n        this.materials.set(mapping.material, mvMaterial);\n        for (const variant of mapping.variants) {\n          const {\n            name\n          } = variantNames[variant];\n          this.variantToMaterialMap.set(variant, mvMaterial);\n          // Provides variant info for material self lookup.\n          mvMaterial[$variantIndices].add(variant);\n          // Updates the models variant data.\n          if (!modelVariants.has(name)) {\n            modelVariants.set(name, {\n              name,\n              index: variant\n            });\n          }\n        }\n      }\n    }\n  }\n  async setActiveMaterial(material) {\n    const mvMaterial = this.materials.get(material);\n    if (material !== this.activeMaterialIdx) {\n      const backingMaterials = mvMaterial[$correlatedObjects];\n      const baseMaterial = await mvMaterial[$getLoadedMaterial]();\n      if (baseMaterial != null) {\n        this.mesh.material = baseMaterial;\n      } else {\n        this.mesh.material = backingMaterials.values().next().value;\n      }\n      this.parser.assignFinalMaterial(this.mesh);\n      backingMaterials.add(this.mesh.material);\n      this.activeMaterialIdx = material;\n    }\n    return this.mesh.material;\n  }\n  getActiveMaterial() {\n    return this.materials.get(this.activeMaterialIdx);\n  }\n  getMaterial(index) {\n    return this.materials.get(index);\n  }\n  async enableVariant(name) {\n    if (name == null) {\n      return this.setActiveMaterial(this.initialMaterialIdx);\n    }\n    if (this.variantToMaterialMap != null && this.modelVariants.has(name)) {\n      const modelVariants = this.modelVariants.get(name);\n      return this.enableVariantHelper(modelVariants.index);\n    }\n    return null;\n  }\n  async enableVariantHelper(index) {\n    if (this.variantToMaterialMap != null && index != null) {\n      const material = this.variantToMaterialMap.get(index);\n      if (material != null) {\n        return this.setActiveMaterial(material.index);\n      }\n    }\n    return null;\n  }\n  async instantiateVariants() {\n    if (this.variantToMaterialMap == null) {\n      return;\n    }\n    for (const index of this.variantToMaterialMap.keys()) {\n      const variantMaterial = this.mesh.userData.variantMaterials.get(index);\n      if (variantMaterial.material != null) {\n        continue;\n      }\n      const threeMaterial = await this.enableVariantHelper(index);\n      if (threeMaterial != null) {\n        variantMaterial.material = threeMaterial;\n      }\n    }\n  }\n  get variantInfo() {\n    return this.variantToMaterialMap;\n  }\n  addVariant(materialVariant, variantName) {\n    if (!this.ensureVariantIsUnused(variantName)) {\n      return false;\n    }\n    // Adds the variant to the model variants if needed.\n    if (!this.modelVariants.has(variantName)) {\n      this.modelVariants.set(variantName, {\n        name: variantName,\n        index: this.modelVariants.size\n      });\n    }\n    const modelVariantData = this.modelVariants.get(variantName);\n    const variantIndex = modelVariantData.index;\n    // Updates materials mapped to the variant.\n    materialVariant[$variantIndices].add(variantIndex);\n    // Updates internal mappings.\n    this.variantToMaterialMap.set(variantIndex, materialVariant);\n    this.materials.set(materialVariant.index, materialVariant);\n    this.updateVariantUserData(variantIndex, materialVariant);\n    return true;\n  }\n  deleteVariant(variantIndex) {\n    if (this.variantInfo.has(variantIndex)) {\n      this.variantInfo.delete(variantIndex);\n      const userDataMap = this.mesh.userData.variantMaterials;\n      if (userDataMap != null) {\n        userDataMap.delete(variantIndex);\n      }\n    }\n  }\n  updateVariantUserData(variantIndex, materialVariant) {\n    // Adds variants name to material variants set.\n    materialVariant[$variantIndices].add(variantIndex);\n    this.mesh.userData.variantData = this.modelVariants;\n    // Updates import data (see VariantMaterialLoaderPlugin.ts).\n    this.mesh.userData.variantMaterials = this.mesh.userData.variantMaterials || new Map();\n    const map = this.mesh.userData.variantMaterials;\n    map.set(variantIndex, {\n      material: materialVariant[$correlatedObjects].values().next().value,\n      gltfMaterialIndex: materialVariant.index\n    });\n  }\n  ensureVariantIsUnused(variantName) {\n    const modelVariants = this.modelVariants.get(variantName);\n    if (modelVariants != null && this.variantInfo.has(modelVariants.index)) {\n      console.warn(`Primitive cannot add variant '${variantName}' for this material, it already exists.`);\n      return false;\n    }\n    return true;\n  }\n}\n//# sourceMappingURL=primitive-node.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}