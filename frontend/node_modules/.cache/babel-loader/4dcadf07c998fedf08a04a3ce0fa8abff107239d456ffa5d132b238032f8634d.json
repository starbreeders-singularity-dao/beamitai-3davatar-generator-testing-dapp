{"ast":null,"code":"import { Box3, Matrix4 } from 'three';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, LEFT_NODE, OFFSET, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nconst _bufferStack1 = new BufferStack.constructor();\nconst _bufferStack2 = new BufferStack.constructor();\nconst _boxPool = new PrimitivePool(() => new Box3());\nconst _leftBox1 = new Box3();\nconst _rightBox1 = new Box3();\nconst _leftBox2 = new Box3();\nconst _rightBox2 = new Box3();\nlet _active = false;\nexport function bvhcast(bvh, otherBvh, matrixToLocal, intersectsRanges) {\n  if (_active) {\n    throw new Error('MeshBVH: Recursive calls to bvhcast not supported.');\n  }\n  _active = true;\n  const roots = bvh._roots;\n  const otherRoots = otherBvh._roots;\n  let result;\n  let offset1 = 0;\n  let offset2 = 0;\n  const invMat = new Matrix4().copy(matrixToLocal).invert();\n\n  // iterate over the first set of roots\n  for (let i = 0, il = roots.length; i < il; i++) {\n    _bufferStack1.setBuffer(roots[i]);\n    offset2 = 0;\n\n    // prep the initial root box\n    const localBox = _boxPool.getPrimitive();\n    arrayToBox(BOUNDING_DATA_INDEX(0), _bufferStack1.float32Array, localBox);\n    localBox.applyMatrix4(invMat);\n\n    // iterate over the second set of roots\n    for (let j = 0, jl = otherRoots.length; j < jl; j++) {\n      _bufferStack2.setBuffer(otherRoots[j]);\n      result = _traverse(0, 0, matrixToLocal, invMat, intersectsRanges, offset1, offset2, 0, 0, localBox);\n      _bufferStack2.clearBuffer();\n      offset2 += otherRoots[j].length;\n      if (result) {\n        break;\n      }\n    }\n\n    // release stack info\n    _boxPool.releasePrimitive(localBox);\n    _bufferStack1.clearBuffer();\n    offset1 += roots[i].length;\n    if (result) {\n      break;\n    }\n  }\n  _active = false;\n  return result;\n}\nfunction _traverse(node1Index32, node2Index32, matrix2to1, matrix1to2, intersectsRangesFunc,\n// offsets for ids\nnode1IndexByteOffset = 0, node2IndexByteOffset = 0,\n// tree depth\ndepth1 = 0, depth2 = 0, currBox = null, reversed = false) {\n  // get the buffer stacks associated with the current indices\n  let bufferStack1, bufferStack2;\n  if (reversed) {\n    bufferStack1 = _bufferStack2;\n    bufferStack2 = _bufferStack1;\n  } else {\n    bufferStack1 = _bufferStack1;\n    bufferStack2 = _bufferStack2;\n  }\n\n  // get the local instances of the typed buffers\n  const float32Array1 = bufferStack1.float32Array,\n    uint32Array1 = bufferStack1.uint32Array,\n    uint16Array1 = bufferStack1.uint16Array,\n    float32Array2 = bufferStack2.float32Array,\n    uint32Array2 = bufferStack2.uint32Array,\n    uint16Array2 = bufferStack2.uint16Array;\n  const node1Index16 = node1Index32 * 2;\n  const node2Index16 = node2Index32 * 2;\n  const isLeaf1 = IS_LEAF(node1Index16, uint16Array1);\n  const isLeaf2 = IS_LEAF(node2Index16, uint16Array2);\n  let result = false;\n  if (isLeaf2 && isLeaf1) {\n    // if both bounds are leaf nodes then fire the callback if the boxes intersect\n    if (reversed) {\n      result = intersectsRangesFunc(OFFSET(node2Index32, uint32Array2), COUNT(node2Index32 * 2, uint16Array2), OFFSET(node1Index32, uint32Array1), COUNT(node1Index32 * 2, uint16Array1), depth2, node2IndexByteOffset + node2Index32, depth1, node1IndexByteOffset + node1Index32);\n    } else {\n      result = intersectsRangesFunc(OFFSET(node1Index32, uint32Array1), COUNT(node1Index32 * 2, uint16Array1), OFFSET(node2Index32, uint32Array2), COUNT(node2Index32 * 2, uint16Array2), depth1, node1IndexByteOffset + node1Index32, depth2, node2IndexByteOffset + node2Index32);\n    }\n  } else if (isLeaf2) {\n    // SWAP\n    // If we've traversed to the leaf node on the other bvh then we need to swap over\n    // to traverse down the first one\n\n    // get the new box to use\n    const newBox = _boxPool.getPrimitive();\n    arrayToBox(BOUNDING_DATA_INDEX(node2Index32), float32Array2, newBox);\n    newBox.applyMatrix4(matrix2to1);\n\n    // get the child bounds to check before traversal\n    const cl1 = LEFT_NODE(node1Index32);\n    const cr1 = RIGHT_NODE(node1Index32, uint32Array1);\n    arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);\n    arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);\n\n    // precompute the intersections otherwise the global boxes will be modified during traversal\n    const intersectCl1 = newBox.intersectsBox(_leftBox1);\n    const intersectCr1 = newBox.intersectsBox(_rightBox1);\n    result = intersectCl1 && _traverse(node2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed) || intersectCr1 && _traverse(node2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed);\n    _boxPool.releasePrimitive(newBox);\n  } else {\n    // if neither are leaves then we should swap if one of the children does not\n    // intersect with the current bounds\n\n    // get the child bounds to check\n    const cl2 = LEFT_NODE(node2Index32);\n    const cr2 = RIGHT_NODE(node2Index32, uint32Array2);\n    arrayToBox(BOUNDING_DATA_INDEX(cl2), float32Array2, _leftBox2);\n    arrayToBox(BOUNDING_DATA_INDEX(cr2), float32Array2, _rightBox2);\n    const leftIntersects = currBox.intersectsBox(_leftBox2);\n    const rightIntersects = currBox.intersectsBox(_rightBox2);\n    if (leftIntersects && rightIntersects) {\n      // continue to traverse both children if they both intersect\n      result = _traverse(node1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed) || _traverse(node1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed);\n    } else if (leftIntersects) {\n      if (isLeaf1) {\n        // if the current box is a leaf then just continue\n        result = _traverse(node1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed);\n      } else {\n        // SWAP\n        // if only one box intersects then we have to swap to the other bvh to continue\n        const newBox = _boxPool.getPrimitive();\n        newBox.copy(_leftBox2).applyMatrix4(matrix2to1);\n        const cl1 = LEFT_NODE(node1Index32);\n        const cr1 = RIGHT_NODE(node1Index32, uint32Array1);\n        arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);\n        arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);\n\n        // precompute the intersections otherwise the global boxes will be modified during traversal\n        const intersectCl1 = newBox.intersectsBox(_leftBox1);\n        const intersectCr1 = newBox.intersectsBox(_rightBox1);\n        result = intersectCl1 && _traverse(cl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed) || intersectCr1 && _traverse(cl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed);\n        _boxPool.releasePrimitive(newBox);\n      }\n    } else if (rightIntersects) {\n      if (isLeaf1) {\n        // if the current box is a leaf then just continue\n        result = _traverse(node1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed);\n      } else {\n        // SWAP\n        // if only one box intersects then we have to swap to the other bvh to continue\n        const newBox = _boxPool.getPrimitive();\n        newBox.copy(_rightBox2).applyMatrix4(matrix2to1);\n        const cl1 = LEFT_NODE(node1Index32);\n        const cr1 = RIGHT_NODE(node1Index32, uint32Array1);\n        arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);\n        arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);\n\n        // precompute the intersections otherwise the global boxes will be modified during traversal\n        const intersectCl1 = newBox.intersectsBox(_leftBox1);\n        const intersectCr1 = newBox.intersectsBox(_rightBox1);\n        result = intersectCl1 && _traverse(cr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed) || intersectCr1 && _traverse(cr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed);\n        _boxPool.releasePrimitive(newBox);\n      }\n    }\n  }\n  return result;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}