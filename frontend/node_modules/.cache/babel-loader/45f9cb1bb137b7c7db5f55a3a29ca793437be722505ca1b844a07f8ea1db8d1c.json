{"ast":null,"code":"import { Loader, FileLoader, MeshStandardMaterial, Color, TextureLoader, Object3D, Matrix4, BufferGeometryLoader, DirectionalLight, PointLight, RectAreaLight, Vector3, SpotLight, CanvasTexture, LinearFilter, ClampToEdgeWrapping, SpriteMaterial, Sprite, LineBasicMaterial, Line, Mesh, PointsMaterial, Points } from \"three\";\nconst _taskCache = /* @__PURE__ */new WeakMap();\nclass Rhino3dmLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.libraryPath = \"\";\n    this.libraryPending = null;\n    this.libraryBinary = null;\n    this.libraryConfig = {};\n    this.url = \"\";\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = \"\";\n    this.workerConfig = {};\n    this.materials = [];\n  }\n  setLibraryPath(path) {\n    this.libraryPath = path;\n    return this;\n  }\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    this.url = url;\n    loader.load(url, buffer => {\n      if (_taskCache.has(buffer)) {\n        const cachedTask = _taskCache.get(buffer);\n        return cachedTask.promise.then(onLoad).catch(onError);\n      }\n      this.decodeObjects(buffer, url).then(onLoad).catch(onError);\n    }, onProgress, onError);\n  }\n  debug() {\n    console.log(\"Task load: \", this.workerPool.map(worker => worker._taskLoad));\n  }\n  decodeObjects(buffer, url) {\n    let worker;\n    let taskID;\n    const taskCost = buffer.byteLength;\n    const objectPending = this._getWorker(taskCost).then(_worker => {\n      worker = _worker;\n      taskID = this.workerNextTaskID++;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = {\n          resolve,\n          reject\n        };\n        worker.postMessage({\n          type: \"decode\",\n          id: taskID,\n          buffer\n        }, [buffer]);\n      });\n    }).then(message => this._createGeometry(message.data));\n    objectPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID);\n      }\n    });\n    _taskCache.set(buffer, {\n      url,\n      promise: objectPending\n    });\n    return objectPending;\n  }\n  parse(data, onLoad, onError) {\n    this.decodeObjects(data, \"\").then(onLoad).catch(onError);\n  }\n  _compareMaterials(material) {\n    const mat = {};\n    mat.name = material.name;\n    mat.color = {};\n    mat.color.r = material.color.r;\n    mat.color.g = material.color.g;\n    mat.color.b = material.color.b;\n    mat.type = material.type;\n    for (let i = 0; i < this.materials.length; i++) {\n      const m = this.materials[i];\n      const _mat = {};\n      _mat.name = m.name;\n      _mat.color = {};\n      _mat.color.r = m.color.r;\n      _mat.color.g = m.color.g;\n      _mat.color.b = m.color.b;\n      _mat.type = m.type;\n      if (JSON.stringify(mat) === JSON.stringify(_mat)) {\n        return m;\n      }\n    }\n    this.materials.push(material);\n    return material;\n  }\n  _createMaterial(material) {\n    if (material === void 0) {\n      return new MeshStandardMaterial({\n        color: new Color(1, 1, 1),\n        metalness: 0.8,\n        name: \"default\",\n        side: 2\n      });\n    }\n    const _diffuseColor = material.diffuseColor;\n    const diffusecolor = new Color(_diffuseColor.r / 255, _diffuseColor.g / 255, _diffuseColor.b / 255);\n    if (_diffuseColor.r === 0 && _diffuseColor.g === 0 && _diffuseColor.b === 0) {\n      diffusecolor.r = 1;\n      diffusecolor.g = 1;\n      diffusecolor.b = 1;\n    }\n    const mat = new MeshStandardMaterial({\n      color: diffusecolor,\n      name: material.name,\n      side: 2,\n      transparent: material.transparency > 0 ? true : false,\n      opacity: 1 - material.transparency\n    });\n    const textureLoader = new TextureLoader();\n    for (let i = 0; i < material.textures.length; i++) {\n      const texture = material.textures[i];\n      if (texture.image !== null) {\n        const map = textureLoader.load(texture.image);\n        switch (texture.type) {\n          case \"Diffuse\":\n            mat.map = map;\n            break;\n          case \"Bump\":\n            mat.bumpMap = map;\n            break;\n          case \"Transparency\":\n            mat.alphaMap = map;\n            mat.transparent = true;\n            break;\n          case \"Emap\":\n            mat.envMap = map;\n            break;\n        }\n      }\n    }\n    return mat;\n  }\n  _createGeometry(data) {\n    const object = new Object3D();\n    const instanceDefinitionObjects = [];\n    const instanceDefinitions = [];\n    const instanceReferences = [];\n    object.userData[\"layers\"] = data.layers;\n    object.userData[\"groups\"] = data.groups;\n    object.userData[\"settings\"] = data.settings;\n    object.userData[\"objectType\"] = \"File3dm\";\n    object.userData[\"materials\"] = null;\n    object.name = this.url;\n    let objects = data.objects;\n    const materials = data.materials;\n    for (let i = 0; i < objects.length; i++) {\n      const obj = objects[i];\n      const attributes = obj.attributes;\n      switch (obj.objectType) {\n        case \"InstanceDefinition\":\n          instanceDefinitions.push(obj);\n          break;\n        case \"InstanceReference\":\n          instanceReferences.push(obj);\n          break;\n        default:\n          let _object;\n          if (attributes.materialIndex >= 0) {\n            const rMaterial = materials[attributes.materialIndex];\n            let material = this._createMaterial(rMaterial);\n            material = this._compareMaterials(material);\n            _object = this._createObject(obj, material);\n          } else {\n            const material = this._createMaterial();\n            _object = this._createObject(obj, material);\n          }\n          if (_object === void 0) {\n            continue;\n          }\n          const layer = data.layers[attributes.layerIndex];\n          _object.visible = layer ? data.layers[attributes.layerIndex].visible : true;\n          if (attributes.isInstanceDefinitionObject) {\n            instanceDefinitionObjects.push(_object);\n          } else {\n            object.add(_object);\n          }\n          break;\n      }\n    }\n    for (let i = 0; i < instanceDefinitions.length; i++) {\n      const iDef = instanceDefinitions[i];\n      objects = [];\n      for (let j = 0; j < iDef.attributes.objectIds.length; j++) {\n        const objId = iDef.attributes.objectIds[j];\n        for (let p = 0; p < instanceDefinitionObjects.length; p++) {\n          const idoId = instanceDefinitionObjects[p].userData.attributes.id;\n          if (objId === idoId) {\n            objects.push(instanceDefinitionObjects[p]);\n          }\n        }\n      }\n      for (let j = 0; j < instanceReferences.length; j++) {\n        const iRef = instanceReferences[j];\n        if (iRef.geometry.parentIdefId === iDef.attributes.id) {\n          const iRefObject = new Object3D();\n          const xf = iRef.geometry.xform.array;\n          const matrix = new Matrix4();\n          matrix.set(xf[0], xf[1], xf[2], xf[3], xf[4], xf[5], xf[6], xf[7], xf[8], xf[9], xf[10], xf[11], xf[12], xf[13], xf[14], xf[15]);\n          iRefObject.applyMatrix4(matrix);\n          for (let p = 0; p < objects.length; p++) {\n            iRefObject.add(objects[p].clone(true));\n          }\n          object.add(iRefObject);\n        }\n      }\n    }\n    object.userData[\"materials\"] = this.materials;\n    return object;\n  }\n  _createObject(obj, mat) {\n    const loader = new BufferGeometryLoader();\n    const attributes = obj.attributes;\n    let geometry, material, _color, color;\n    switch (obj.objectType) {\n      case \"Point\":\n      case \"PointSet\":\n        geometry = loader.parse(obj.geometry);\n        if (geometry.attributes.hasOwnProperty(\"color\")) {\n          material = new PointsMaterial({\n            vertexColors: true,\n            sizeAttenuation: false,\n            size: 2\n          });\n        } else {\n          _color = attributes.drawColor;\n          color = new Color(_color.r / 255, _color.g / 255, _color.b / 255);\n          material = new PointsMaterial({\n            color,\n            sizeAttenuation: false,\n            size: 2\n          });\n        }\n        material = this._compareMaterials(material);\n        const points = new Points(geometry, material);\n        points.userData[\"attributes\"] = attributes;\n        points.userData[\"objectType\"] = obj.objectType;\n        if (attributes.name) {\n          points.name = attributes.name;\n        }\n        return points;\n      case \"Mesh\":\n      case \"Extrusion\":\n      case \"SubD\":\n      case \"Brep\":\n        if (obj.geometry === null) return;\n        geometry = loader.parse(obj.geometry);\n        if (geometry.attributes.hasOwnProperty(\"color\")) {\n          mat.vertexColors = true;\n        }\n        if (mat === null) {\n          mat = this._createMaterial();\n          mat = this._compareMaterials(mat);\n        }\n        const mesh = new Mesh(geometry, mat);\n        mesh.castShadow = attributes.castsShadows;\n        mesh.receiveShadow = attributes.receivesShadows;\n        mesh.userData[\"attributes\"] = attributes;\n        mesh.userData[\"objectType\"] = obj.objectType;\n        if (attributes.name) {\n          mesh.name = attributes.name;\n        }\n        return mesh;\n      case \"Curve\":\n        geometry = loader.parse(obj.geometry);\n        _color = attributes.drawColor;\n        color = new Color(_color.r / 255, _color.g / 255, _color.b / 255);\n        material = new LineBasicMaterial({\n          color\n        });\n        material = this._compareMaterials(material);\n        const lines = new Line(geometry, material);\n        lines.userData[\"attributes\"] = attributes;\n        lines.userData[\"objectType\"] = obj.objectType;\n        if (attributes.name) {\n          lines.name = attributes.name;\n        }\n        return lines;\n      case \"TextDot\":\n        geometry = obj.geometry;\n        const ctx = document.createElement(\"canvas\").getContext(\"2d\");\n        const font = `${geometry.fontHeight}px ${geometry.fontFace}`;\n        ctx.font = font;\n        const width = ctx.measureText(geometry.text).width + 10;\n        const height = geometry.fontHeight + 10;\n        const r = window.devicePixelRatio;\n        ctx.canvas.width = width * r;\n        ctx.canvas.height = height * r;\n        ctx.canvas.style.width = width + \"px\";\n        ctx.canvas.style.height = height + \"px\";\n        ctx.setTransform(r, 0, 0, r, 0, 0);\n        ctx.font = font;\n        ctx.textBaseline = \"middle\";\n        ctx.textAlign = \"center\";\n        color = attributes.drawColor;\n        ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},${color.a})`;\n        ctx.fillRect(0, 0, width, height);\n        ctx.fillStyle = \"white\";\n        ctx.fillText(geometry.text, width / 2, height / 2);\n        const texture = new CanvasTexture(ctx.canvas);\n        texture.minFilter = LinearFilter;\n        texture.wrapS = ClampToEdgeWrapping;\n        texture.wrapT = ClampToEdgeWrapping;\n        material = new SpriteMaterial({\n          map: texture,\n          depthTest: false\n        });\n        const sprite = new Sprite(material);\n        sprite.position.set(geometry.point[0], geometry.point[1], geometry.point[2]);\n        sprite.scale.set(width / 10, height / 10, 1);\n        sprite.userData[\"attributes\"] = attributes;\n        sprite.userData[\"objectType\"] = obj.objectType;\n        if (attributes.name) {\n          sprite.name = attributes.name;\n        }\n        return sprite;\n      case \"Light\":\n        geometry = obj.geometry;\n        let light;\n        if (geometry.isDirectionalLight) {\n          light = new DirectionalLight();\n          light.castShadow = attributes.castsShadows;\n          light.position.set(geometry.location[0], geometry.location[1], geometry.location[2]);\n          light.target.position.set(geometry.direction[0], geometry.direction[1], geometry.direction[2]);\n          light.shadow.normalBias = 0.1;\n        } else if (geometry.isPointLight) {\n          light = new PointLight();\n          light.castShadow = attributes.castsShadows;\n          light.position.set(geometry.location[0], geometry.location[1], geometry.location[2]);\n          light.shadow.normalBias = 0.1;\n        } else if (geometry.isRectangularLight) {\n          light = new RectAreaLight();\n          const width2 = Math.abs(geometry.width[2]);\n          const height2 = Math.abs(geometry.length[0]);\n          light.position.set(geometry.location[0] - height2 / 2, geometry.location[1], geometry.location[2] - width2 / 2);\n          light.height = height2;\n          light.width = width2;\n          light.lookAt(new Vector3(geometry.direction[0], geometry.direction[1], geometry.direction[2]));\n        } else if (geometry.isSpotLight) {\n          light = new SpotLight();\n          light.castShadow = attributes.castsShadows;\n          light.position.set(geometry.location[0], geometry.location[1], geometry.location[2]);\n          light.target.position.set(geometry.direction[0], geometry.direction[1], geometry.direction[2]);\n          light.angle = geometry.spotAngleRadians;\n          light.shadow.normalBias = 0.1;\n        } else if (geometry.isLinearLight) {\n          console.warn(\"THREE.3DMLoader:  No conversion exists for linear lights.\");\n          return;\n        }\n        if (light) {\n          light.intensity = geometry.intensity;\n          _color = geometry.diffuse;\n          color = new Color(_color.r / 255, _color.g / 255, _color.b / 255);\n          light.color = color;\n          light.userData[\"attributes\"] = attributes;\n          light.userData[\"objectType\"] = obj.objectType;\n        }\n        return light;\n    }\n  }\n  _initLibrary() {\n    if (!this.libraryPending) {\n      const jsLoader = new FileLoader(this.manager);\n      jsLoader.setPath(this.libraryPath);\n      const jsContent = new Promise((resolve, reject) => {\n        jsLoader.load(\"rhino3dm.js\", resolve, void 0, reject);\n      });\n      const binaryLoader = new FileLoader(this.manager);\n      binaryLoader.setPath(this.libraryPath);\n      binaryLoader.setResponseType(\"arraybuffer\");\n      const binaryContent = new Promise((resolve, reject) => {\n        binaryLoader.load(\"rhino3dm.wasm\", resolve, void 0, reject);\n      });\n      this.libraryPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {\n        this.libraryConfig.wasmBinary = binaryContent2;\n        const fn = Rhino3dmWorker.toString();\n        const body = [\"/* rhino3dm.js */\", jsContent2, \"/* worker */\", fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))].join(\"\\n\");\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n      });\n    }\n    return this.libraryPending;\n  }\n  _getWorker(taskCost) {\n    return this._initLibrary().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker2 = new Worker(this.workerSourceURL);\n        worker2._callbacks = {};\n        worker2._taskCosts = {};\n        worker2._taskLoad = 0;\n        worker2.postMessage({\n          type: \"init\",\n          libraryConfig: this.libraryConfig\n        });\n        worker2.onmessage = function (e) {\n          const message = e.data;\n          switch (message.type) {\n            case \"decode\":\n              worker2._callbacks[message.id].resolve(message);\n              break;\n            case \"error\":\n              worker2._callbacks[message.id].reject(message);\n              break;\n            default:\n              console.error('THREE.Rhino3dmLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n        this.workerPool.push(worker2);\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n    this.workerPool.length = 0;\n    return this;\n  }\n}\nfunction Rhino3dmWorker() {\n  let libraryPending;\n  let libraryConfig;\n  let rhino;\n  onmessage = function (e) {\n    const message = e.data;\n    switch (message.type) {\n      case \"init\":\n        libraryConfig = message.libraryConfig;\n        const wasmBinary = libraryConfig.wasmBinary;\n        let RhinoModule;\n        libraryPending = new Promise(function (resolve) {\n          RhinoModule = {\n            wasmBinary,\n            onRuntimeInitialized: resolve\n          };\n          rhino3dm(RhinoModule);\n        }).then(() => {\n          rhino = RhinoModule;\n        });\n        break;\n      case \"decode\":\n        const buffer = message.buffer;\n        libraryPending.then(() => {\n          const data = decodeObjects(rhino, buffer);\n          self.postMessage({\n            type: \"decode\",\n            id: message.id,\n            data\n          });\n        });\n        break;\n    }\n  };\n  function decodeObjects(rhino2, buffer) {\n    const arr = new Uint8Array(buffer);\n    const doc = rhino2.File3dm.fromByteArray(arr);\n    const objects = [];\n    const materials = [];\n    const layers = [];\n    const views = [];\n    const namedViews = [];\n    const groups = [];\n    const objs = doc.objects();\n    const cnt = objs.count;\n    for (let i = 0; i < cnt; i++) {\n      const _object = objs.get(i);\n      const object = extractObjectData(_object, doc);\n      _object.delete();\n      if (object) {\n        objects.push(object);\n      }\n    }\n    for (let i = 0; i < doc.instanceDefinitions().count(); i++) {\n      const idef = doc.instanceDefinitions().get(i);\n      const idefAttributes = extractProperties(idef);\n      idefAttributes.objectIds = idef.getObjectIds();\n      objects.push({\n        geometry: null,\n        attributes: idefAttributes,\n        objectType: \"InstanceDefinition\"\n      });\n    }\n    const textureTypes = [\n    // rhino.TextureType.Bitmap,\n    rhino2.TextureType.Diffuse, rhino2.TextureType.Bump, rhino2.TextureType.Transparency, rhino2.TextureType.Opacity, rhino2.TextureType.Emap];\n    const pbrTextureTypes = [rhino2.TextureType.PBR_BaseColor, rhino2.TextureType.PBR_Subsurface, rhino2.TextureType.PBR_SubsurfaceScattering, rhino2.TextureType.PBR_SubsurfaceScatteringRadius, rhino2.TextureType.PBR_Metallic, rhino2.TextureType.PBR_Specular, rhino2.TextureType.PBR_SpecularTint, rhino2.TextureType.PBR_Roughness, rhino2.TextureType.PBR_Anisotropic, rhino2.TextureType.PBR_Anisotropic_Rotation, rhino2.TextureType.PBR_Sheen, rhino2.TextureType.PBR_SheenTint, rhino2.TextureType.PBR_Clearcoat, rhino2.TextureType.PBR_ClearcoatBump, rhino2.TextureType.PBR_ClearcoatRoughness, rhino2.TextureType.PBR_OpacityIor, rhino2.TextureType.PBR_OpacityRoughness, rhino2.TextureType.PBR_Emission, rhino2.TextureType.PBR_AmbientOcclusion, rhino2.TextureType.PBR_Displacement];\n    for (let i = 0; i < doc.materials().count(); i++) {\n      const _material = doc.materials().get(i);\n      const _pbrMaterial = _material.physicallyBased();\n      let material = extractProperties(_material);\n      const textures = [];\n      for (let j = 0; j < textureTypes.length; j++) {\n        const _texture = _material.getTexture(textureTypes[j]);\n        if (_texture) {\n          let textureType = textureTypes[j].constructor.name;\n          textureType = textureType.substring(12, textureType.length);\n          const texture = {\n            type: textureType\n          };\n          const image = doc.getEmbeddedFileAsBase64(_texture.fileName);\n          if (image) {\n            texture.image = \"data:image/png;base64,\" + image;\n          } else {\n            console.warn(`THREE.3DMLoader: Image for ${textureType} texture not embedded in file.`);\n            texture.image = null;\n          }\n          textures.push(texture);\n          _texture.delete();\n        }\n      }\n      material.textures = textures;\n      if (_pbrMaterial.supported) {\n        console.log(\"pbr true\");\n        for (let j = 0; j < pbrTextureTypes.length; j++) {\n          const _texture = _material.getTexture(textureTypes[j]);\n          if (_texture) {\n            const image = doc.getEmbeddedFileAsBase64(_texture.fileName);\n            let textureType = textureTypes[j].constructor.name;\n            textureType = textureType.substring(12, textureType.length);\n            const texture = {\n              type: textureType,\n              image: \"data:image/png;base64,\" + image\n            };\n            textures.push(texture);\n            _texture.delete();\n          }\n        }\n        const pbMaterialProperties = extractProperties(_material.physicallyBased());\n        material = Object.assign(pbMaterialProperties, material);\n      }\n      materials.push(material);\n      _material.delete();\n      _pbrMaterial.delete();\n    }\n    for (let i = 0; i < doc.layers().count(); i++) {\n      const _layer = doc.layers().get(i);\n      const layer = extractProperties(_layer);\n      layers.push(layer);\n      _layer.delete();\n    }\n    for (let i = 0; i < doc.views().count(); i++) {\n      const _view = doc.views().get(i);\n      const view = extractProperties(_view);\n      views.push(view);\n      _view.delete();\n    }\n    for (let i = 0; i < doc.namedViews().count(); i++) {\n      const _namedView = doc.namedViews().get(i);\n      const namedView = extractProperties(_namedView);\n      namedViews.push(namedView);\n      _namedView.delete();\n    }\n    for (let i = 0; i < doc.groups().count(); i++) {\n      const _group = doc.groups().get(i);\n      const group = extractProperties(_group);\n      groups.push(group);\n      _group.delete();\n    }\n    const settings = extractProperties(doc.settings());\n    doc.delete();\n    return {\n      objects,\n      materials,\n      layers,\n      views,\n      namedViews,\n      groups,\n      settings\n    };\n  }\n  function extractObjectData(object, doc) {\n    const _geometry = object.geometry();\n    const _attributes = object.attributes();\n    let objectType = _geometry.objectType;\n    let geometry, attributes, position, data, mesh;\n    switch (objectType) {\n      case rhino.ObjectType.Curve:\n        const pts = curveToPoints(_geometry, 100);\n        position = {};\n        attributes = {};\n        data = {};\n        position.itemSize = 3;\n        position.type = \"Float32Array\";\n        position.array = [];\n        for (let j = 0; j < pts.length; j++) {\n          position.array.push(pts[j][0]);\n          position.array.push(pts[j][1]);\n          position.array.push(pts[j][2]);\n        }\n        attributes.position = position;\n        data.attributes = attributes;\n        geometry = {\n          data\n        };\n        break;\n      case rhino.ObjectType.Point:\n        const pt = _geometry.location;\n        position = {};\n        const color = {};\n        attributes = {};\n        data = {};\n        position.itemSize = 3;\n        position.type = \"Float32Array\";\n        position.array = [pt[0], pt[1], pt[2]];\n        const _color = _attributes.drawColor(doc);\n        color.itemSize = 3;\n        color.type = \"Float32Array\";\n        color.array = [_color.r / 255, _color.g / 255, _color.b / 255];\n        attributes.position = position;\n        attributes.color = color;\n        data.attributes = attributes;\n        geometry = {\n          data\n        };\n        break;\n      case rhino.ObjectType.PointSet:\n      case rhino.ObjectType.Mesh:\n        geometry = _geometry.toThreejsJSON();\n        break;\n      case rhino.ObjectType.Brep:\n        const faces = _geometry.faces();\n        mesh = new rhino.Mesh();\n        for (let faceIndex = 0; faceIndex < faces.count; faceIndex++) {\n          const face = faces.get(faceIndex);\n          const _mesh = face.getMesh(rhino.MeshType.Any);\n          if (_mesh) {\n            mesh.append(_mesh);\n            _mesh.delete();\n          }\n          face.delete();\n        }\n        if (mesh.faces().count > 0) {\n          mesh.compact();\n          geometry = mesh.toThreejsJSON();\n          faces.delete();\n        }\n        mesh.delete();\n        break;\n      case rhino.ObjectType.Extrusion:\n        mesh = _geometry.getMesh(rhino.MeshType.Any);\n        if (mesh) {\n          geometry = mesh.toThreejsJSON();\n          mesh.delete();\n        }\n        break;\n      case rhino.ObjectType.TextDot:\n        geometry = extractProperties(_geometry);\n        break;\n      case rhino.ObjectType.Light:\n        geometry = extractProperties(_geometry);\n        break;\n      case rhino.ObjectType.InstanceReference:\n        geometry = extractProperties(_geometry);\n        geometry.xform = extractProperties(_geometry.xform);\n        geometry.xform.array = _geometry.xform.toFloatArray(true);\n        break;\n      case rhino.ObjectType.SubD:\n        _geometry.subdivide(3);\n        mesh = rhino.Mesh.createFromSubDControlNet(_geometry);\n        if (mesh) {\n          geometry = mesh.toThreejsJSON();\n          mesh.delete();\n        }\n        break;\n      default:\n        console.warn(`THREE.3DMLoader: TODO: Implement ${objectType.constructor.name}`);\n        break;\n    }\n    if (geometry) {\n      attributes = extractProperties(_attributes);\n      attributes.geometry = extractProperties(_geometry);\n      if (_attributes.groupCount > 0) {\n        attributes.groupIds = _attributes.getGroupList();\n      }\n      if (_attributes.userStringCount > 0) {\n        attributes.userStrings = _attributes.getUserStrings();\n      }\n      if (_geometry.userStringCount > 0) {\n        attributes.geometry.userStrings = _geometry.getUserStrings();\n      }\n      attributes.drawColor = _attributes.drawColor(doc);\n      objectType = objectType.constructor.name;\n      objectType = objectType.substring(11, objectType.length);\n      return {\n        geometry,\n        attributes,\n        objectType\n      };\n    } else {\n      console.warn(`THREE.3DMLoader: ${objectType.constructor.name} has no associated mesh geometry.`);\n    }\n  }\n  function extractProperties(object) {\n    const result = {};\n    for (const property in object) {\n      const value = object[property];\n      if (typeof value !== \"function\") {\n        if (typeof value === \"object\" && value !== null && value.hasOwnProperty(\"constructor\")) {\n          result[property] = {\n            name: value.constructor.name,\n            value: value.value\n          };\n        } else {\n          result[property] = value;\n        }\n      }\n    }\n    return result;\n  }\n  function curveToPoints(curve, pointLimit) {\n    let pointCount = pointLimit;\n    let rc = [];\n    const ts = [];\n    if (curve instanceof rhino.LineCurve) {\n      return [curve.pointAtStart, curve.pointAtEnd];\n    }\n    if (curve instanceof rhino.PolylineCurve) {\n      pointCount = curve.pointCount;\n      for (let i = 0; i < pointCount; i++) {\n        rc.push(curve.point(i));\n      }\n      return rc;\n    }\n    if (curve instanceof rhino.PolyCurve) {\n      const segmentCount = curve.segmentCount;\n      for (let i = 0; i < segmentCount; i++) {\n        const segment = curve.segmentCurve(i);\n        const segmentArray = curveToPoints(segment, pointCount);\n        rc = rc.concat(segmentArray);\n        segment.delete();\n      }\n      return rc;\n    }\n    if (curve instanceof rhino.ArcCurve) {\n      pointCount = Math.floor(curve.angleDegrees / 5);\n      pointCount = pointCount < 2 ? 2 : pointCount;\n    }\n    if (curve instanceof rhino.NurbsCurve && curve.degree === 1) {\n      const pLine = curve.tryGetPolyline();\n      for (let i = 0; i < pLine.count; i++) {\n        rc.push(pLine.get(i));\n      }\n      pLine.delete();\n      return rc;\n    }\n    const domain = curve.domain;\n    const divisions = pointCount - 1;\n    for (let j = 0; j < pointCount; j++) {\n      const t = domain[0] + j / divisions * (domain[1] - domain[0]);\n      if (t === domain[0] || t === domain[1]) {\n        ts.push(t);\n        continue;\n      }\n      const tan = curve.tangentAt(t);\n      const prevTan = curve.tangentAt(ts.slice(-1)[0]);\n      const tS = tan[0] * tan[0] + tan[1] * tan[1] + tan[2] * tan[2];\n      const ptS = prevTan[0] * prevTan[0] + prevTan[1] * prevTan[1] + prevTan[2] * prevTan[2];\n      const denominator = Math.sqrt(tS * ptS);\n      let angle;\n      if (denominator === 0) {\n        angle = Math.PI / 2;\n      } else {\n        const theta = (tan.x * prevTan.x + tan.y * prevTan.y + tan.z * prevTan.z) / denominator;\n        angle = Math.acos(Math.max(-1, Math.min(1, theta)));\n      }\n      if (angle < 0.1) continue;\n      ts.push(t);\n    }\n    rc = ts.map(t => curve.pointAt(t));\n    return rc;\n  }\n}\nexport { Rhino3dmLoader };\n//# sourceMappingURL=3DMLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}