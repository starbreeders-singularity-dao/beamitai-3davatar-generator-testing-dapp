{"ast":null,"code":"import { DataTexture, FloatType, IntType, UnsignedIntType, ByteType, UnsignedByteType, ShortType, UnsignedShortType, RedFormat, RGFormat, RGBAFormat, RedIntegerFormat, RGIntegerFormat, RGBAIntegerFormat, NearestFilter } from 'three';\nfunction countToStringFormat(count) {\n  switch (count) {\n    case 1:\n      return 'R';\n    case 2:\n      return 'RG';\n    case 3:\n      return 'RGBA';\n    case 4:\n      return 'RGBA';\n  }\n  throw new Error();\n}\nfunction countToFormat(count) {\n  switch (count) {\n    case 1:\n      return RedFormat;\n    case 2:\n      return RGFormat;\n    case 3:\n      return RGBAFormat;\n    case 4:\n      return RGBAFormat;\n  }\n}\nfunction countToIntFormat(count) {\n  switch (count) {\n    case 1:\n      return RedIntegerFormat;\n    case 2:\n      return RGIntegerFormat;\n    case 3:\n      return RGBAIntegerFormat;\n    case 4:\n      return RGBAIntegerFormat;\n  }\n}\nexport class VertexAttributeTexture extends DataTexture {\n  constructor() {\n    super();\n    this.minFilter = NearestFilter;\n    this.magFilter = NearestFilter;\n    this.generateMipmaps = false;\n    this.overrideItemSize = null;\n    this._forcedType = null;\n  }\n  updateFrom(attr) {\n    const overrideItemSize = this.overrideItemSize;\n    const originalItemSize = attr.itemSize;\n    const originalCount = attr.count;\n    if (overrideItemSize !== null) {\n      if (originalItemSize * originalCount % overrideItemSize !== 0.0) {\n        throw new Error('VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.');\n      }\n      attr.itemSize = overrideItemSize;\n      attr.count = originalCount * originalItemSize / overrideItemSize;\n    }\n    const itemSize = attr.itemSize;\n    const count = attr.count;\n    const normalized = attr.normalized;\n    const originalBufferCons = attr.array.constructor;\n    const byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n    let targetType = this._forcedType;\n    let finalStride = itemSize;\n\n    // derive the type of texture this should be in the shader\n    if (targetType === null) {\n      switch (originalBufferCons) {\n        case Float32Array:\n          targetType = FloatType;\n          break;\n        case Uint8Array:\n        case Uint16Array:\n        case Uint32Array:\n          targetType = UnsignedIntType;\n          break;\n        case Int8Array:\n        case Int16Array:\n        case Int32Array:\n          targetType = IntType;\n          break;\n      }\n    }\n\n    // get the target format to store the texture as\n    let type, format, normalizeValue, targetBufferCons;\n    let internalFormat = countToStringFormat(itemSize);\n    switch (targetType) {\n      case FloatType:\n        normalizeValue = 1.0;\n        format = countToFormat(itemSize);\n        if (normalized && byteCount === 1) {\n          targetBufferCons = originalBufferCons;\n          internalFormat += '8';\n          if (originalBufferCons === Uint8Array) {\n            type = UnsignedByteType;\n          } else {\n            type = ByteType;\n            internalFormat += '_SNORM';\n          }\n        } else {\n          targetBufferCons = Float32Array;\n          internalFormat += '32F';\n          type = FloatType;\n        }\n        break;\n      case IntType:\n        internalFormat += byteCount * 8 + 'I';\n        normalizeValue = normalized ? Math.pow(2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1) : 1.0;\n        format = countToIntFormat(itemSize);\n        if (byteCount === 1) {\n          targetBufferCons = Int8Array;\n          type = ByteType;\n        } else if (byteCount === 2) {\n          targetBufferCons = Int16Array;\n          type = ShortType;\n        } else {\n          targetBufferCons = Int32Array;\n          type = IntType;\n        }\n        break;\n      case UnsignedIntType:\n        internalFormat += byteCount * 8 + 'UI';\n        normalizeValue = normalized ? Math.pow(2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1) : 1.0;\n        format = countToIntFormat(itemSize);\n        if (byteCount === 1) {\n          targetBufferCons = Uint8Array;\n          type = UnsignedByteType;\n        } else if (byteCount === 2) {\n          targetBufferCons = Uint16Array;\n          type = UnsignedShortType;\n        } else {\n          targetBufferCons = Uint32Array;\n          type = UnsignedIntType;\n        }\n        break;\n    }\n\n    // there will be a mismatch between format length and final length because\n    // RGBFormat and RGBIntegerFormat was removed\n    if (finalStride === 3 && (format === RGBAFormat || format === RGBAIntegerFormat)) {\n      finalStride = 4;\n    }\n\n    // copy the data over to the new texture array\n    const dimension = Math.ceil(Math.sqrt(count)) || 1;\n    const length = finalStride * dimension * dimension;\n    const dataArray = new targetBufferCons(length);\n\n    // temporarily set the normalized state to false since we have custom normalization logic\n    const originalNormalized = attr.normalized;\n    attr.normalized = false;\n    for (let i = 0; i < count; i++) {\n      const ii = finalStride * i;\n      dataArray[ii] = attr.getX(i) / normalizeValue;\n      if (itemSize >= 2) {\n        dataArray[ii + 1] = attr.getY(i) / normalizeValue;\n      }\n      if (itemSize >= 3) {\n        dataArray[ii + 2] = attr.getZ(i) / normalizeValue;\n        if (finalStride === 4) {\n          dataArray[ii + 3] = 1.0;\n        }\n      }\n      if (itemSize >= 4) {\n        dataArray[ii + 3] = attr.getW(i) / normalizeValue;\n      }\n    }\n    attr.normalized = originalNormalized;\n    this.internalFormat = internalFormat;\n    this.format = format;\n    this.type = type;\n    this.image.width = dimension;\n    this.image.height = dimension;\n    this.image.data = dataArray;\n    this.needsUpdate = true;\n    this.dispose();\n    attr.itemSize = originalItemSize;\n    attr.count = originalCount;\n  }\n}\nexport class UIntVertexAttributeTexture extends VertexAttributeTexture {\n  constructor() {\n    super();\n    this._forcedType = UnsignedIntType;\n  }\n}\nexport class IntVertexAttributeTexture extends VertexAttributeTexture {\n  constructor() {\n    super();\n    this._forcedType = IntType;\n  }\n}\nexport class FloatVertexAttributeTexture extends VertexAttributeTexture {\n  constructor() {\n    super();\n    this._forcedType = FloatType;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}