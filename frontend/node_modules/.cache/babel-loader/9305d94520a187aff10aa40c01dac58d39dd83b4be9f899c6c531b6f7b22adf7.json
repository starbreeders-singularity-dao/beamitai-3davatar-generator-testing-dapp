{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { clamp } from '../utilities.js';\n// Adapted from https://gist.github.com/gre/1650294\nexport const easeInOutQuad = t => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n/**\n * Creates a TimingFunction that uses a given ease to interpolate between\n * two configured number values.\n */\nexport const interpolate = (start, end, ease = easeInOutQuad) => time => start + (end - start) * ease(time);\n/**\n * Creates a TimingFunction that interpolates through a weighted list\n * of other TimingFunctions (\"tracks\"). Tracks are interpolated in order, and\n * allocated a percentage of the total time based on their relative weight.\n */\nexport const sequence = (tracks, weights) => {\n  const cumulativeSum = sum => value => sum += value;\n  const times = weights.map(cumulativeSum(0));\n  return time => {\n    time = clamp(time, 0, 1);\n    time *= times[times.length - 1];\n    const i = times.findIndex(val => val >= time);\n    const start = i < 1 ? 0 : times[i - 1];\n    const end = times[i];\n    return tracks[i]((time - start) / (end - start));\n  };\n};\n/**\n * Creates a \"timeline\" TimingFunction out of an initial value and a series of\n * Keyframes. The timeline function accepts value from 0-1 and returns the\n * current value based on keyframe interpolation across the total number of\n * frames. Frames are only used to indicate the relative length of each keyframe\n * transition, so interpolated values will be computed for fractional frames.\n */\nexport const timeline = path => {\n  const tracks = [];\n  const weights = [];\n  let lastValue = path.initialValue;\n  for (let i = 0; i < path.keyframes.length; ++i) {\n    const keyframe = path.keyframes[i];\n    const {\n      value,\n      frames\n    } = keyframe;\n    const ease = keyframe.ease || easeInOutQuad;\n    const track = interpolate(lastValue, value, ease);\n    tracks.push(track);\n    weights.push(frames);\n    lastValue = value;\n  }\n  return sequence(tracks, weights);\n};\n//# sourceMappingURL=animation.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}