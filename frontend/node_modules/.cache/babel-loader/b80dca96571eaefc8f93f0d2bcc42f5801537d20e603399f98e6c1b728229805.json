{"ast":null,"code":"import { Panel } from \"./panel.js\";\nconst _Stats = class _Stats2 {\n  constructor({\n    trackGPU = false,\n    logsPerSecond = 30,\n    samplesLog = 60,\n    samplesGraph = 10,\n    precision = 2,\n    minimal = false,\n    horizontal = true,\n    mode = 0\n  } = {}) {\n    this.gl = null;\n    this.ext = null;\n    this.activeQuery = null;\n    this.gpuQueries = [];\n    this.threeRendererPatched = false;\n    this.frames = 0;\n    this.renderCount = 0;\n    this.isRunningCPUProfiling = false;\n    this.totalCpuDuration = 0;\n    this.totalGpuDuration = 0;\n    this.totalGpuDurationCompute = 0;\n    this.totalFps = 0;\n    this.gpuPanel = null;\n    this.gpuPanelCompute = null;\n    this.averageFps = {\n      logs: [],\n      graph: []\n    };\n    this.averageCpu = {\n      logs: [],\n      graph: []\n    };\n    this.averageGpu = {\n      logs: [],\n      graph: []\n    };\n    this.averageGpuCompute = {\n      logs: [],\n      graph: []\n    };\n    this.handleClick = event => {\n      event.preventDefault();\n      this.showPanel(++this.mode % this.dom.children.length);\n    };\n    this.handleResize = () => {\n      this.resizePanel(this.fpsPanel, 0);\n      this.resizePanel(this.msPanel, 1);\n      if (this.gpuPanel) this.resizePanel(this.gpuPanel, 2);\n      if (this.gpuPanelCompute) this.resizePanel(this.gpuPanelCompute, 3);\n    };\n    this.mode = mode;\n    this.horizontal = horizontal;\n    this.minimal = minimal;\n    this.trackGPU = trackGPU;\n    this.samplesLog = samplesLog;\n    this.samplesGraph = samplesGraph;\n    this.precision = precision;\n    this.logsPerSecond = logsPerSecond;\n    this.dom = document.createElement(\"div\");\n    this.initializeDOM();\n    this.beginTime = performance.now();\n    this.prevTime = this.beginTime;\n    this.prevCpuTime = this.beginTime;\n    this.fpsPanel = this.addPanel(new _Stats2.Panel(\"FPS\", \"#0ff\", \"#002\"), 0);\n    this.msPanel = this.addPanel(new _Stats2.Panel(\"CPU\", \"#0f0\", \"#020\"), 1);\n    this.setupEventListeners();\n  }\n  initializeDOM() {\n    this.dom.style.cssText = `\n      position: fixed;\n      top: 0;\n      left: 0;\n      opacity: 0.9;\n      z-index: 10000;\n      ${this.minimal ? \"cursor: pointer;\" : \"\"}\n    `;\n  }\n  setupEventListeners() {\n    if (this.minimal) {\n      this.dom.addEventListener(\"click\", this.handleClick);\n      this.showPanel(this.mode);\n    } else {\n      window.addEventListener(\"resize\", this.handleResize);\n    }\n  }\n  async init(canvasOrGL) {\n    if (!canvasOrGL) {\n      console.error('Stats: The \"canvas\" parameter is undefined.');\n      return;\n    }\n    if (this.handleThreeRenderer(canvasOrGL)) return;\n    if (await this.handleWebGPURenderer(canvasOrGL)) return;\n    if (!this.initializeWebGL(canvasOrGL)) return;\n  }\n  handleThreeRenderer(renderer) {\n    if (renderer.isWebGLRenderer && !this.threeRendererPatched) {\n      this.patchThreeRenderer(renderer);\n      this.gl = renderer.getContext();\n      if (this.trackGPU) {\n        this.initializeGPUTracking();\n      }\n      return true;\n    }\n    return false;\n  }\n  async handleWebGPURenderer(renderer) {\n    if (renderer.isWebGPURenderer) {\n      if (this.trackGPU) {\n        renderer.backend.trackTimestamp = true;\n        if (await renderer.hasFeatureAsync(\"timestamp-query\")) {\n          this.initializeWebGPUPanels();\n        }\n      }\n      this.info = renderer.info;\n      return true;\n    }\n    return false;\n  }\n  initializeWebGPUPanels() {\n    this.gpuPanel = this.addPanel(new _Stats2.Panel(\"GPU\", \"#ff0\", \"#220\"), 2);\n    this.gpuPanelCompute = this.addPanel(new _Stats2.Panel(\"CPT\", \"#e1e1e1\", \"#212121\"), 3);\n  }\n  initializeWebGL(canvasOrGL) {\n    if (canvasOrGL instanceof WebGL2RenderingContext) {\n      this.gl = canvasOrGL;\n    } else if (canvasOrGL instanceof HTMLCanvasElement || canvasOrGL instanceof OffscreenCanvas) {\n      this.gl = canvasOrGL.getContext(\"webgl2\");\n      if (!this.gl) {\n        console.error(\"Stats: Unable to obtain WebGL2 context.\");\n        return false;\n      }\n    } else {\n      console.error(\"Stats: Invalid input type. Expected WebGL2RenderingContext, HTMLCanvasElement, or OffscreenCanvas.\");\n      return false;\n    }\n    return true;\n  }\n  initializeGPUTracking() {\n    if (this.gl) {\n      this.ext = this.gl.getExtension(\"EXT_disjoint_timer_query_webgl2\");\n      if (this.ext) {\n        this.gpuPanel = this.addPanel(new _Stats2.Panel(\"GPU\", \"#ff0\", \"#220\"), 2);\n      }\n    }\n  }\n  begin() {\n    if (!this.isRunningCPUProfiling) {\n      this.beginProfiling(\"cpu-started\");\n    }\n    if (!this.gl || !this.ext) return;\n    if (this.activeQuery) {\n      this.gl.endQuery(this.ext.TIME_ELAPSED_EXT);\n    }\n    this.activeQuery = this.gl.createQuery();\n    if (this.activeQuery) {\n      this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, this.activeQuery);\n    }\n  }\n  end() {\n    this.renderCount++;\n    if (this.gl && this.ext && this.activeQuery) {\n      this.gl.endQuery(this.ext.TIME_ELAPSED_EXT);\n      this.gpuQueries.push({\n        query: this.activeQuery\n      });\n      this.activeQuery = null;\n    }\n  }\n  update() {\n    if (!this.info) {\n      this.processGpuQueries();\n    } else {\n      this.processWebGPUTimestamps();\n    }\n    this.endProfiling(\"cpu-started\", \"cpu-finished\", \"cpu-duration\");\n    this.updateAverages();\n    this.resetCounters();\n  }\n  processWebGPUTimestamps() {\n    this.totalGpuDuration = this.info.render.timestamp;\n    this.totalGpuDurationCompute = this.info.compute.timestamp;\n    this.addToAverage(this.totalGpuDurationCompute, this.averageGpuCompute);\n  }\n  updateAverages() {\n    this.addToAverage(this.totalCpuDuration, this.averageCpu);\n    this.addToAverage(this.totalGpuDuration, this.averageGpu);\n  }\n  resetCounters() {\n    this.renderCount = 0;\n    if (this.totalCpuDuration === 0) {\n      this.beginProfiling(\"cpu-started\");\n    }\n    this.totalCpuDuration = 0;\n    this.totalFps = 0;\n    this.beginTime = this.endInternal();\n  }\n  resizePanel(panel, offset) {\n    panel.canvas.style.position = \"absolute\";\n    if (this.minimal) {\n      panel.canvas.style.display = \"none\";\n    } else {\n      panel.canvas.style.display = \"block\";\n      if (this.horizontal) {\n        panel.canvas.style.top = \"0px\";\n        panel.canvas.style.left = offset * panel.WIDTH / panel.PR + \"px\";\n      } else {\n        panel.canvas.style.left = \"0px\";\n        panel.canvas.style.top = offset * panel.HEIGHT / panel.PR + \"px\";\n      }\n    }\n  }\n  addPanel(panel, offset) {\n    if (panel.canvas) {\n      this.dom.appendChild(panel.canvas);\n      this.resizePanel(panel, offset);\n    }\n    return panel;\n  }\n  showPanel(id) {\n    for (let i = 0; i < this.dom.children.length; i++) {\n      const child = this.dom.children[i];\n      child.style.display = i === id ? \"block\" : \"none\";\n    }\n    this.mode = id;\n  }\n  processGpuQueries() {\n    if (!this.gl || !this.ext) return;\n    this.totalGpuDuration = 0;\n    this.gpuQueries.forEach((queryInfo, index) => {\n      if (this.gl) {\n        const available = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT_AVAILABLE);\n        const disjoint = this.gl.getParameter(this.ext.GPU_DISJOINT_EXT);\n        if (available && !disjoint) {\n          const elapsed = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT);\n          const duration = elapsed * 1e-6;\n          this.totalGpuDuration += duration;\n          this.gl.deleteQuery(queryInfo.query);\n          this.gpuQueries.splice(index, 1);\n        }\n      }\n    });\n  }\n  endInternal() {\n    this.frames++;\n    const time = (performance || Date).now();\n    const elapsed = time - this.prevTime;\n    if (time >= this.prevCpuTime + 1e3 / this.logsPerSecond) {\n      const fps = Math.round(this.frames * 1e3 / elapsed);\n      this.addToAverage(fps, this.averageFps);\n      this.updatePanel(this.fpsPanel, this.averageFps, 0);\n      this.updatePanel(this.msPanel, this.averageCpu, this.precision);\n      this.updatePanel(this.gpuPanel, this.averageGpu, this.precision);\n      if (this.gpuPanelCompute) {\n        this.updatePanel(this.gpuPanelCompute, this.averageGpuCompute);\n      }\n      this.frames = 0;\n      this.prevCpuTime = time;\n      this.prevTime = time;\n    }\n    return time;\n  }\n  addToAverage(value, averageArray) {\n    averageArray.logs.push(value);\n    if (averageArray.logs.length > this.samplesLog) {\n      averageArray.logs.shift();\n    }\n    averageArray.graph.push(value);\n    if (averageArray.graph.length > this.samplesGraph) {\n      averageArray.graph.shift();\n    }\n  }\n  beginProfiling(marker) {\n    if (window.performance) {\n      window.performance.mark(marker);\n      this.isRunningCPUProfiling = true;\n    }\n  }\n  endProfiling(startMarker, endMarker, measureName) {\n    if (window.performance && endMarker && this.isRunningCPUProfiling) {\n      window.performance.mark(endMarker);\n      const cpuMeasure = performance.measure(measureName, startMarker, endMarker);\n      this.totalCpuDuration += cpuMeasure.duration;\n      this.isRunningCPUProfiling = false;\n    }\n  }\n  updatePanel(panel, averageArray, precision = 2) {\n    if (averageArray.logs.length > 0) {\n      let sumLog = 0;\n      let max = 0.01;\n      for (let i = 0; i < averageArray.logs.length; i++) {\n        sumLog += averageArray.logs[i];\n        if (averageArray.logs[i] > max) {\n          max = averageArray.logs[i];\n        }\n      }\n      let sumGraph = 0;\n      let maxGraph = 0.01;\n      for (let i = 0; i < averageArray.graph.length; i++) {\n        sumGraph += averageArray.graph[i];\n        if (averageArray.graph[i] > maxGraph) {\n          maxGraph = averageArray.graph[i];\n        }\n      }\n      if (panel) {\n        panel.update(sumLog / Math.min(averageArray.logs.length, this.samplesLog), sumGraph / Math.min(averageArray.graph.length, this.samplesGraph), max, maxGraph, precision);\n      }\n    }\n  }\n  get domElement() {\n    return this.dom;\n  }\n  patchThreeRenderer(renderer) {\n    const originalRenderMethod = renderer.render;\n    const statsInstance = this;\n    renderer.render = function (scene, camera) {\n      statsInstance.begin();\n      originalRenderMethod.call(this, scene, camera);\n      statsInstance.end();\n    };\n    this.threeRendererPatched = true;\n  }\n};\n_Stats.Panel = Panel;\nlet Stats = _Stats;\nexport { Stats as default };\n//# sourceMappingURL=main.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}