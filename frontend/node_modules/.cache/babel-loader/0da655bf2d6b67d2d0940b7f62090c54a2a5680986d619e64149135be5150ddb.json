{"ast":null,"code":"import { cloneElement } from 'react';\nimport PropTypes from 'prop-types';\nexport default function Composer(props) {\n  return renderRecursive(props.children, props.components);\n}\nComposer.propTypes = {\n  children: PropTypes.func.isRequired,\n  components: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.element, PropTypes.func])).isRequired\n};\n\n/**\n * Recursively build up elements from props.components and accumulate `results` along the way.\n * @param {function} render\n * @param {Array.<ReactElement|Function>} remaining\n * @param {Array} [results]\n * @returns {ReactElement}\n */\nfunction renderRecursive(render, remaining, results) {\n  results = results || [];\n  // Once components is exhausted, we can render out the results array.\n  if (!remaining[0]) {\n    return render(results);\n  }\n\n  // Continue recursion for remaining items.\n  // results.concat([value]) ensures [...results, value] instead of [...results, ...value]\n  function nextRender(value) {\n    return renderRecursive(render, remaining.slice(1), results.concat([value]));\n  }\n\n  // Each props.components entry is either an element or function [element factory]\n  return typeof remaining[0] === 'function' ?\n  // When it is a function, produce an element by invoking it with \"render component values\".\n  remaining[0]({\n    results: results,\n    render: nextRender\n  }) :\n  // When it is an element, enhance the element's props with the render prop.\n  cloneElement(remaining[0], {\n    children: nextRender\n  });\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}