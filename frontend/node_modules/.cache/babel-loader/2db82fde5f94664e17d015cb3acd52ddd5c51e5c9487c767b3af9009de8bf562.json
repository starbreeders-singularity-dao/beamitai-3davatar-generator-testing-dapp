{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { BufferGeometry, Vector3, Uint32BufferAttribute, Float32BufferAttribute, DynamicDrawUsage, MathUtils } from \"three\";\nimport { SimplexNoise } from \"../math/SimplexNoise.js\";\nconst _LightningStrike = class extends BufferGeometry {\n  constructor(rayParameters = {}) {\n    super();\n    this.isLightningStrike = true;\n    this.type = \"LightningStrike\";\n    this.init(_LightningStrike.copyParameters(rayParameters, rayParameters));\n    this.createMesh();\n  }\n  static createRandomGenerator() {\n    const numSeeds = 2053;\n    const seeds = [];\n    for (let i = 0; i < numSeeds; i++) {\n      seeds.push(Math.random());\n    }\n    const generator = {\n      currentSeed: 0,\n      random: function () {\n        const value = seeds[generator.currentSeed];\n        generator.currentSeed = (generator.currentSeed + 1) % numSeeds;\n        return value;\n      },\n      getSeed: function () {\n        return generator.currentSeed / numSeeds;\n      },\n      setSeed: function (seed) {\n        generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;\n      }\n    };\n    return generator;\n  }\n  static copyParameters(dest = {}, source = {}) {\n    const vecCopy = function (v) {\n      if (source === dest) {\n        return v;\n      } else {\n        return v.clone();\n      }\n    };\n    dest.sourceOffset = source.sourceOffset !== void 0 ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0), dest.destOffset = source.destOffset !== void 0 ? vecCopy(source.destOffset) : new Vector3(0, 0, 0), dest.timeScale = source.timeScale !== void 0 ? source.timeScale : 1, dest.roughness = source.roughness !== void 0 ? source.roughness : 0.9, dest.straightness = source.straightness !== void 0 ? source.straightness : 0.7, dest.up0 = source.up0 !== void 0 ? vecCopy(source.up0) : new Vector3(0, 0, 1);\n    dest.up1 = source.up1 !== void 0 ? vecCopy(source.up1) : new Vector3(0, 0, 1), dest.radius0 = source.radius0 !== void 0 ? source.radius0 : 1, dest.radius1 = source.radius1 !== void 0 ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== void 0 ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== void 0 ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== void 0 ? source.minRadius : 0.2,\n    // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n    dest.isEternal = source.isEternal !== void 0 ? source.isEternal : source.birthTime === void 0 || source.deathTime === void 0, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== void 0 ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== void 0 ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== void 0 ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== void 0 ? source.subrayDutyCycle : 0.6;\n    dest.maxIterations = source.maxIterations !== void 0 ? source.maxIterations : 9;\n    dest.isStatic = source.isStatic !== void 0 ? source.isStatic : false;\n    dest.ramification = source.ramification !== void 0 ? source.ramification : 5;\n    dest.maxSubrayRecursion = source.maxSubrayRecursion !== void 0 ? source.maxSubrayRecursion : 3;\n    dest.recursionProbability = source.recursionProbability !== void 0 ? source.recursionProbability : 0.6;\n    dest.generateUVs = source.generateUVs !== void 0 ? source.generateUVs : false;\n    dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;\n    return dest;\n  }\n  update(time) {\n    if (this.isStatic) return;\n    if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {\n      this.updateMesh(time);\n      if (time < this.subrays[0].endPropagationTime) {\n        this.state = _LightningStrike.RAY_PROPAGATING;\n      } else if (time > this.subrays[0].beginVanishingTime) {\n        this.state = _LightningStrike.RAY_VANISHING;\n      } else {\n        this.state = _LightningStrike.RAY_STEADY;\n      }\n      this.visible = true;\n    } else {\n      this.visible = false;\n      if (time < this.rayParameters.birthTime) {\n        this.state = _LightningStrike.RAY_UNBORN;\n      } else {\n        this.state = _LightningStrike.RAY_EXTINGUISHED;\n      }\n    }\n  }\n  init(rayParameters) {\n    this.rayParameters = rayParameters;\n    this.maxIterations = rayParameters.maxIterations !== void 0 ? Math.floor(rayParameters.maxIterations) : 9;\n    rayParameters.maxIterations = this.maxIterations;\n    this.isStatic = rayParameters.isStatic !== void 0 ? rayParameters.isStatic : false;\n    rayParameters.isStatic = this.isStatic;\n    this.ramification = rayParameters.ramification !== void 0 ? Math.floor(rayParameters.ramification) : 5;\n    rayParameters.ramification = this.ramification;\n    this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== void 0 ? Math.floor(rayParameters.maxSubrayRecursion) : 3;\n    rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;\n    this.recursionProbability = rayParameters.recursionProbability !== void 0 ? rayParameters.recursionProbability : 0.6;\n    rayParameters.recursionProbability = this.recursionProbability;\n    this.generateUVs = rayParameters.generateUVs !== void 0 ? rayParameters.generateUVs : false;\n    rayParameters.generateUVs = this.generateUVs;\n    if (rayParameters.randomGenerator !== void 0) {\n      this.randomGenerator = rayParameters.randomGenerator;\n      this.seedGenerator = rayParameters.randomGenerator;\n      if (rayParameters.noiseSeed !== void 0) {\n        this.seedGenerator.setSeed(rayParameters.noiseSeed);\n      }\n    } else {\n      this.randomGenerator = _LightningStrike.createRandomGenerator();\n      this.seedGenerator = Math;\n    }\n    if (rayParameters.onDecideSubrayCreation !== void 0) {\n      this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;\n    } else {\n      this.createDefaultSubrayCreationCallbacks();\n      if (rayParameters.onSubrayCreation !== void 0) {\n        this.onSubrayCreation = rayParameters.onSubrayCreation;\n      }\n    }\n    this.state = _LightningStrike.RAY_INITIALIZED;\n    this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));\n    rayParameters.maxSubrays = this.maxSubrays;\n    this.maxRaySegments = 2 * (1 << this.maxIterations);\n    this.subrays = [];\n    for (let i = 0; i < this.maxSubrays; i++) {\n      this.subrays.push(this.createSubray());\n    }\n    this.raySegments = [];\n    for (let i = 0; i < this.maxRaySegments; i++) {\n      this.raySegments.push(this.createSegment());\n    }\n    this.time = 0;\n    this.timeFraction = 0;\n    this.currentSegmentCallback = null;\n    this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;\n    this.numSubrays = 0;\n    this.currentSubray = null;\n    this.currentSegmentIndex = 0;\n    this.isInitialSegment = false;\n    this.subrayProbability = 0;\n    this.currentVertex = 0;\n    this.currentIndex = 0;\n    this.currentCoordinate = 0;\n    this.currentUVCoordinate = 0;\n    this.vertices = null;\n    this.uvs = null;\n    this.indices = null;\n    this.positionAttribute = null;\n    this.uvsAttribute = null;\n    this.simplexX = new SimplexNoise(this.seedGenerator);\n    this.simplexY = new SimplexNoise(this.seedGenerator);\n    this.simplexZ = new SimplexNoise(this.seedGenerator);\n    this.forwards = new Vector3();\n    this.forwardsFill = new Vector3();\n    this.side = new Vector3();\n    this.down = new Vector3();\n    this.middlePos = new Vector3();\n    this.middleLinPos = new Vector3();\n    this.newPos = new Vector3();\n    this.vPos = new Vector3();\n    this.cross1 = new Vector3();\n  }\n  createMesh() {\n    const maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;\n    const maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;\n    const maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;\n    this.vertices = new Float32Array(maxVerts * 3);\n    this.indices = new Uint32Array(maxIndices);\n    if (this.generateUVs) {\n      this.uvs = new Float32Array(maxVerts * 2);\n    }\n    this.fillMesh(0);\n    this.setIndex(new Uint32BufferAttribute(this.indices, 1));\n    this.positionAttribute = new Float32BufferAttribute(this.vertices, 3);\n    this.setAttribute(\"position\", this.positionAttribute);\n    if (this.generateUVs) {\n      this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2);\n      this.setAttribute(\"uv\", this.uvsAttribute);\n    }\n    if (!this.isStatic) {\n      this.index.usage = DynamicDrawUsage;\n      this.positionAttribute.usage = DynamicDrawUsage;\n      if (this.generateUVs) {\n        this.uvsAttribute.usage = DynamicDrawUsage;\n      }\n    }\n    this.vertices = this.positionAttribute.array;\n    this.indices = this.index.array;\n    if (this.generateUVs) {\n      this.uvs = this.uvsAttribute.array;\n    }\n  }\n  updateMesh(time) {\n    this.fillMesh(time);\n    this.drawRange.count = this.currentIndex;\n    this.index.needsUpdate = true;\n    this.positionAttribute.needsUpdate = true;\n    if (this.generateUVs) {\n      this.uvsAttribute.needsUpdate = true;\n    }\n  }\n  fillMesh(time) {\n    const scope = this;\n    this.currentVertex = 0;\n    this.currentIndex = 0;\n    this.currentCoordinate = 0;\n    this.currentUVCoordinate = 0;\n    this.fractalRay(time, function fillVertices(segment) {\n      const subray = scope.currentSubray;\n      if (time < subray.birthTime) {\n        return;\n      } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {\n        scope.createPrism(segment);\n        scope.onDecideSubrayCreation(segment, scope);\n      } else if (time < subray.endPropagationTime) {\n        if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {\n          scope.createPrism(segment);\n          scope.onDecideSubrayCreation(segment, scope);\n        }\n      } else if (time < subray.beginVanishingTime) {\n        scope.createPrism(segment);\n        scope.onDecideSubrayCreation(segment, scope);\n      } else {\n        if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {\n          scope.createPrism(segment);\n        }\n        scope.onDecideSubrayCreation(segment, scope);\n      }\n    });\n  }\n  addNewSubray() {\n    return this.subrays[this.numSubrays++];\n  }\n  initSubray(subray, rayParameters) {\n    subray.pos0.copy(rayParameters.sourceOffset);\n    subray.pos1.copy(rayParameters.destOffset);\n    subray.up0.copy(rayParameters.up0);\n    subray.up1.copy(rayParameters.up1);\n    subray.radius0 = rayParameters.radius0;\n    subray.radius1 = rayParameters.radius1;\n    subray.birthTime = rayParameters.birthTime;\n    subray.deathTime = rayParameters.deathTime;\n    subray.timeScale = rayParameters.timeScale;\n    subray.roughness = rayParameters.roughness;\n    subray.straightness = rayParameters.straightness;\n    subray.propagationTimeFactor = rayParameters.propagationTimeFactor;\n    subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;\n    subray.maxIterations = this.maxIterations;\n    subray.seed = rayParameters.noiseSeed !== void 0 ? rayParameters.noiseSeed : 0;\n    subray.recursion = 0;\n  }\n  fractalRay(time, segmentCallback) {\n    this.time = time;\n    this.currentSegmentCallback = segmentCallback;\n    this.numSubrays = 0;\n    this.initSubray(this.addNewSubray(), this.rayParameters);\n    for (let subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {\n      const subray = this.subrays[subrayIndex];\n      this.currentSubray = subray;\n      this.randomGenerator.setSeed(subray.seed);\n      subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);\n      subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);\n      const random1 = this.randomGenerator.random;\n      subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);\n      subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);\n      this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);\n      this.currentSegmentIndex = 0;\n      this.isInitialSegment = true;\n      const segment = this.getNewSegment();\n      segment.iteration = 0;\n      segment.pos0.copy(subray.pos0);\n      segment.pos1.copy(subray.pos1);\n      segment.linPos0.copy(subray.linPos0);\n      segment.linPos1.copy(subray.linPos1);\n      segment.up0.copy(subray.up0);\n      segment.up1.copy(subray.up1);\n      segment.radius0 = subray.radius0;\n      segment.radius1 = subray.radius1;\n      segment.fraction0 = 0;\n      segment.fraction1 = 1;\n      segment.positionVariationFactor = 1 - subray.straightness;\n      this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);\n      this.fractalRayRecursive(segment);\n    }\n    this.currentSegmentCallback = null;\n    this.currentSubray = null;\n  }\n  fractalRayRecursive(segment) {\n    if (segment.iteration >= this.currentSubray.maxIterations) {\n      this.currentSegmentCallback(segment);\n      return;\n    }\n    this.forwards.subVectors(segment.pos1, segment.pos0);\n    let lForwards = this.forwards.length();\n    if (lForwards < 1e-6) {\n      this.forwards.set(0, 0, 0.01);\n      lForwards = this.forwards.length();\n    }\n    const middleRadius = (segment.radius0 + segment.radius1) * 0.5;\n    const middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;\n    const timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);\n    this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);\n    this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);\n    const p = this.middleLinPos;\n    this.newPos.set(this.simplexX.noise4d(p.x, p.y, p.z, timeDimension), this.simplexY.noise4d(p.x, p.y, p.z, timeDimension), this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension));\n    this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);\n    this.newPos.add(this.middlePos);\n    const newSegment1 = this.getNewSegment();\n    newSegment1.pos0.copy(segment.pos0);\n    newSegment1.pos1.copy(this.newPos);\n    newSegment1.linPos0.copy(segment.linPos0);\n    newSegment1.linPos1.copy(this.middleLinPos);\n    newSegment1.up0.copy(segment.up0);\n    newSegment1.up1.copy(segment.up1);\n    newSegment1.radius0 = segment.radius0;\n    newSegment1.radius1 = middleRadius;\n    newSegment1.fraction0 = segment.fraction0;\n    newSegment1.fraction1 = middleFraction;\n    newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n    newSegment1.iteration = segment.iteration + 1;\n    const newSegment2 = this.getNewSegment();\n    newSegment2.pos0.copy(this.newPos);\n    newSegment2.pos1.copy(segment.pos1);\n    newSegment2.linPos0.copy(this.middleLinPos);\n    newSegment2.linPos1.copy(segment.linPos1);\n    this.cross1.crossVectors(segment.up0, this.forwards.normalize());\n    newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();\n    newSegment2.up1.copy(segment.up1);\n    newSegment2.radius0 = middleRadius;\n    newSegment2.radius1 = segment.radius1;\n    newSegment2.fraction0 = middleFraction;\n    newSegment2.fraction1 = segment.fraction1;\n    newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n    newSegment2.iteration = segment.iteration + 1;\n    this.fractalRayRecursive(newSegment1);\n    this.fractalRayRecursive(newSegment2);\n  }\n  createPrism(segment) {\n    this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();\n    if (this.isInitialSegment) {\n      this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);\n      this.isInitialSegment = false;\n    }\n    this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1);\n    this.createPrismFaces();\n  }\n  createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * _LightningStrike.COS30DEG);\n    this.down.copy(up).multiplyScalar(-radius * _LightningStrike.SIN30DEG);\n    const p = this.vPos;\n    const v = this.vertices;\n    p.copy(pos).sub(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    p.copy(pos).add(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    p.copy(up).multiplyScalar(radius).add(pos);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    this.currentVertex += 3;\n  }\n  createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * _LightningStrike.COS30DEG);\n    this.down.copy(up).multiplyScalar(-radius * _LightningStrike.SIN30DEG);\n    const p = this.vPos;\n    const v = this.vertices;\n    const uv = this.uvs;\n    p.copy(pos).sub(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    uv[this.currentUVCoordinate++] = u;\n    uv[this.currentUVCoordinate++] = 0;\n    p.copy(pos).add(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    uv[this.currentUVCoordinate++] = u;\n    uv[this.currentUVCoordinate++] = 0.5;\n    p.copy(up).multiplyScalar(radius).add(pos);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    uv[this.currentUVCoordinate++] = u;\n    uv[this.currentUVCoordinate++] = 1;\n    this.currentVertex += 3;\n  }\n  createPrismFaces(vertex) {\n    const indices = this.indices;\n    vertex = this.currentVertex - 6;\n    indices[this.currentIndex++] = vertex + 1;\n    indices[this.currentIndex++] = vertex + 2;\n    indices[this.currentIndex++] = vertex + 5;\n    indices[this.currentIndex++] = vertex + 1;\n    indices[this.currentIndex++] = vertex + 5;\n    indices[this.currentIndex++] = vertex + 4;\n    indices[this.currentIndex++] = vertex + 0;\n    indices[this.currentIndex++] = vertex + 1;\n    indices[this.currentIndex++] = vertex + 4;\n    indices[this.currentIndex++] = vertex + 0;\n    indices[this.currentIndex++] = vertex + 4;\n    indices[this.currentIndex++] = vertex + 3;\n    indices[this.currentIndex++] = vertex + 2;\n    indices[this.currentIndex++] = vertex + 0;\n    indices[this.currentIndex++] = vertex + 3;\n    indices[this.currentIndex++] = vertex + 2;\n    indices[this.currentIndex++] = vertex + 3;\n    indices[this.currentIndex++] = vertex + 5;\n  }\n  createDefaultSubrayCreationCallbacks() {\n    const random1 = this.randomGenerator.random;\n    this.onDecideSubrayCreation = function (segment, lightningStrike) {\n      const subray = lightningStrike.currentSubray;\n      const period = lightningStrike.rayParameters.subrayPeriod;\n      const dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;\n      const phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;\n      const phase = lightningStrike.time - phase0;\n      const currentCycle = Math.floor(phase / period);\n      const childSubraySeed = random1() * (currentCycle + 1);\n      const isActive = phase % period <= dutyCycle * period;\n      let probability = 0;\n      if (isActive) {\n        probability = lightningStrike.subrayProbability;\n      }\n      if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {\n        const childSubray = lightningStrike.addNewSubray();\n        const parentSeed = lightningStrike.randomGenerator.getSeed();\n        childSubray.seed = childSubraySeed;\n        lightningStrike.randomGenerator.setSeed(childSubraySeed);\n        childSubray.recursion = subray.recursion + 1;\n        childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);\n        childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);\n        childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);\n        childSubray.up0.copy(subray.up0);\n        childSubray.up1.copy(subray.up1);\n        childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;\n        childSubray.radius1 = Math.min(lightningStrike.rayParameters.minRadius, segment.radius1 * lightningStrike.rayParameters.radius1Factor);\n        childSubray.birthTime = phase0 + currentCycle * period;\n        childSubray.deathTime = childSubray.birthTime + period * dutyCycle;\n        if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {\n          childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);\n          childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);\n        }\n        childSubray.timeScale = subray.timeScale * 2;\n        childSubray.roughness = subray.roughness;\n        childSubray.straightness = subray.straightness;\n        childSubray.propagationTimeFactor = subray.propagationTimeFactor;\n        childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;\n        lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);\n        lightningStrike.randomGenerator.setSeed(parentSeed);\n      }\n    };\n    const vec1Pos = new Vector3();\n    const vec2Forward = new Vector3();\n    const vec3Side = new Vector3();\n    const vec4Up = new Vector3();\n    this.onSubrayCreation = function (segment, parentSubray, childSubray, lightningStrike) {\n      lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);\n    };\n    this.subrayConePosition = function (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n      childSubray.pos0.copy(segment.pos0);\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n      vec2Forward.copy(vec1Pos).normalize();\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));\n      const length = vec1Pos.length();\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n      const angle = 2 * Math.PI * random1();\n      vec3Side.multiplyScalar(Math.cos(angle));\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n    };\n    this.subrayCylinderPosition = function (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n      childSubray.pos0.copy(segment.pos0);\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n      vec2Forward.copy(vec1Pos).normalize();\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));\n      const length = vec1Pos.length();\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n      const angle = 2 * Math.PI * random1();\n      vec3Side.multiplyScalar(Math.cos(angle));\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n    };\n  }\n  createSubray() {\n    return {\n      seed: 0,\n      maxIterations: 0,\n      recursion: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      birthTime: 0,\n      deathTime: 0,\n      timeScale: 0,\n      roughness: 0,\n      straightness: 0,\n      propagationTimeFactor: 0,\n      vanishingTimeFactor: 0,\n      endPropagationTime: 0,\n      beginVanishingTime: 0\n    };\n  }\n  createSegment() {\n    return {\n      iteration: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      fraction0: 0,\n      fraction1: 0,\n      positionVariationFactor: 0\n    };\n  }\n  getNewSegment() {\n    return this.raySegments[this.currentSegmentIndex++];\n  }\n  copy(source) {\n    super.copy(source);\n    this.init(_LightningStrike.copyParameters({}, source.rayParameters));\n    return this;\n  }\n  clone() {\n    return new this.constructor(_LightningStrike.copyParameters({}, this.rayParameters));\n  }\n};\nlet LightningStrike = _LightningStrike;\n// Ray states\n__publicField(LightningStrike, \"RAY_INITIALIZED\", 0);\n__publicField(LightningStrike, \"RAY_UNBORN\", 1);\n__publicField(LightningStrike, \"RAY_PROPAGATING\", 2);\n__publicField(LightningStrike, \"RAY_STEADY\", 3);\n__publicField(LightningStrike, \"RAY_VANISHING\", 4);\n__publicField(LightningStrike, \"RAY_EXTINGUISHED\", 5);\n__publicField(LightningStrike, \"COS30DEG\", Math.cos(30 * Math.PI / 180));\n__publicField(LightningStrike, \"SIN30DEG\", Math.sin(30 * Math.PI / 180));\nexport { LightningStrike };\n//# sourceMappingURL=LightningStrike.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}