{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { FormatterError } from 'web3-errors';\nimport { FMT_BYTES, FMT_NUMBER, DEFAULT_RETURN_FORMAT } from 'web3-types';\nimport { isNullish, isObject, utils } from 'web3-validator';\nimport { bytesToUint8Array, bytesToHex, numberToHex, toBigInt } from './converters.js';\nimport { mergeDeep } from './objects.js';\nimport { padLeft } from './string_manipulation.js';\nimport { isUint8Array, uint8ArrayConcat } from './uint8array.js';\nconst {\n  parseBaseType\n} = utils;\nexport const isDataFormat = dataFormat => typeof dataFormat === 'object' && !isNullish(dataFormat) && 'number' in dataFormat && 'bytes' in dataFormat;\n/**\n * Finds the schema that corresponds to a specific data path within a larger JSON schema.\n * It works by iterating over the dataPath array and traversing the JSON schema one step at a time until it reaches the end of the path.\n *\n * @param schema - represents a JSON schema, which is an object that describes the structure of JSON data\n * @param dataPath - represents an array of strings that specifies the path to the data within the JSON schema\n * @param oneOfPath - represents an optional array of two-element tuples that specifies the \"oneOf\" option to choose, if the schema has oneOf and the data path can match multiple subschemas\n * @returns the JSON schema that matches the data path\n *\n */\nconst findSchemaByDataPath = (schema, dataPath, oneOfPath = []) => {\n  let result = Object.assign({}, schema);\n  let previousDataPath;\n  for (const dataPart of dataPath) {\n    if (result.oneOf && previousDataPath) {\n      const currentDataPath = previousDataPath;\n      const path = oneOfPath.find(([key]) => key === currentDataPath);\n      if (path && path[0] === previousDataPath) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        result = result.oneOf[path[1]];\n      }\n    }\n    if (!result.properties && !result.items) {\n      return undefined;\n    }\n    if (result.properties) {\n      result = result.properties[dataPart];\n    } else if (result.items && result.items.properties) {\n      const node = result.items.properties;\n      result = node[dataPart];\n    } else if (result.items && isObject(result.items)) {\n      result = result.items;\n    } else if (result.items && Array.isArray(result.items)) {\n      result = result.items[parseInt(dataPart, 10)];\n    }\n    if (result && dataPart) previousDataPath = dataPart;\n  }\n  return result;\n};\n/**\n * Converts a value depending on the format\n * @param value - value to convert\n * @param ethType - The type of the value to be parsed\n * @param format - The format to be converted to\n * @returns - The value converted to the specified format\n */\nexport const convertScalarValue = (value, ethType, format) => {\n  try {\n    const {\n      baseType,\n      baseTypeSize\n    } = parseBaseType(ethType);\n    if (baseType === 'int' || baseType === 'uint') {\n      switch (format.number) {\n        case FMT_NUMBER.NUMBER:\n          return Number(toBigInt(value));\n        case FMT_NUMBER.HEX:\n          return numberToHex(toBigInt(value));\n        case FMT_NUMBER.STR:\n          return toBigInt(value).toString();\n        case FMT_NUMBER.BIGINT:\n          return toBigInt(value);\n        default:\n          throw new FormatterError(`Invalid format: ${String(format.number)}`);\n      }\n    }\n    if (baseType === 'bytes') {\n      let paddedValue;\n      if (baseTypeSize) {\n        if (typeof value === 'string') paddedValue = padLeft(value, baseTypeSize * 2);else if (isUint8Array(value)) {\n          paddedValue = uint8ArrayConcat(new Uint8Array(baseTypeSize - value.length), value);\n        }\n      } else {\n        paddedValue = value;\n      }\n      switch (format.bytes) {\n        case FMT_BYTES.HEX:\n          return bytesToHex(bytesToUint8Array(paddedValue));\n        case FMT_BYTES.UINT8ARRAY:\n          return bytesToUint8Array(paddedValue);\n        default:\n          throw new FormatterError(`Invalid format: ${String(format.bytes)}`);\n      }\n    }\n    if (baseType === 'string') {\n      return String(value);\n    }\n  } catch (error) {\n    // If someone didn't use `eth` keyword we can return original value\n    // as the scope of this code is formatting not validation\n    return value;\n  }\n  return value;\n};\nconst convertArray = ({\n  value,\n  schemaProp,\n  schema,\n  object,\n  key,\n  dataPath,\n  format,\n  oneOfPath = []\n}) => {\n  var _a, _b;\n  // If value is an array\n  if (Array.isArray(value)) {\n    let _schemaProp = schemaProp;\n    // TODO This is a naive approach to solving the issue of\n    // a schema using oneOf. This chunk of code was intended to handle\n    // BlockSchema.transactions\n    // TODO BlockSchema.transactions are not being formatted\n    if ((schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.oneOf) !== undefined) {\n      // The following code is basically saying:\n      // if the schema specifies oneOf, then we are to loop\n      // over each possible schema and check if they type of the schema\n      // matches the type of value[0], and if so we use the oneOfSchemaProp\n      // as the schema for formatting\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n      schemaProp.oneOf.forEach((oneOfSchemaProp, index) => {\n        var _a, _b;\n        if (!Array.isArray(schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.items) && (typeof value[0] === 'object' && ((_a = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _a === void 0 ? void 0 : _a.type) === 'object' || typeof value[0] === 'string' && ((_b = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _b === void 0 ? void 0 : _b.type) !== 'object')) {\n          _schemaProp = oneOfSchemaProp;\n          oneOfPath.push([key, index]);\n        }\n      });\n    }\n    if (isNullish(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {\n      // Can not find schema for array item, delete that item\n      // eslint-disable-next-line no-param-reassign\n      delete object[key];\n      dataPath.pop();\n      return true;\n    }\n    // If schema for array items is a single type\n    if (isObject(_schemaProp.items) && !isNullish(_schemaProp.items.format)) {\n      for (let i = 0; i < value.length; i += 1) {\n        // eslint-disable-next-line no-param-reassign\n        object[key][i] = convertScalarValue(value[i],\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        (_a = _schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) === null || _a === void 0 ? void 0 : _a.format, format);\n      }\n      dataPath.pop();\n      return true;\n    }\n    // If schema for array items is an object\n    if (!Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) && ((_b = _schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) === null || _b === void 0 ? void 0 : _b.type) === 'object') {\n      for (const arrObject of value) {\n        // eslint-disable-next-line no-use-before-define\n        convert(arrObject, schema, dataPath, format, oneOfPath);\n      }\n      dataPath.pop();\n      return true;\n    }\n    // If schema for array is a tuple\n    if (Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {\n      for (let i = 0; i < value.length; i += 1) {\n        // eslint-disable-next-line no-param-reassign\n        object[key][i] = convertScalarValue(value[i], _schemaProp.items[i].format, format);\n      }\n      dataPath.pop();\n      return true;\n    }\n  }\n  return false;\n};\n/**\n * Converts the data to the specified format\n * @param data - data to convert\n * @param schema - The JSON schema that describes the structure of the data\n * @param dataPath - A string array that specifies the path to the data within the JSON schema\n * @param format  - The format to be converted to\n * @param oneOfPath - An optional array of two-element tuples that specifies the \"oneOf\" option to choose, if the schema has oneOf and the data path can match multiple subschemas\n * @returns - The data converted to the specified format\n */\nexport const convert = (data, schema, dataPath, format, oneOfPath = []) => {\n  var _a;\n  // If it's a scalar value\n  if (!isObject(data) && !Array.isArray(data)) {\n    return convertScalarValue(data, schema === null || schema === void 0 ? void 0 : schema.format, format);\n  }\n  const object = data;\n  // case when schema is array and `items` is object\n  if (Array.isArray(object) && (schema === null || schema === void 0 ? void 0 : schema.type) === 'array' && ((_a = schema === null || schema === void 0 ? void 0 : schema.items) === null || _a === void 0 ? void 0 : _a.type) === 'object') {\n    convertArray({\n      value: object,\n      schemaProp: schema,\n      schema,\n      object,\n      key: '',\n      dataPath,\n      format,\n      oneOfPath\n    });\n  } else {\n    for (const [key, value] of Object.entries(object)) {\n      dataPath.push(key);\n      let schemaProp = findSchemaByDataPath(schema, dataPath, oneOfPath);\n      // If value is a scaler value\n      if (isNullish(schemaProp)) {\n        delete object[key];\n        dataPath.pop();\n        continue;\n      }\n      // If value is an object, recurse into it\n      if (isObject(value)) {\n        convert(value, schema, dataPath, format, oneOfPath);\n        dataPath.pop();\n        continue;\n      }\n      // If value is an array\n      if (convertArray({\n        value,\n        schemaProp,\n        schema,\n        object,\n        key,\n        dataPath,\n        format,\n        oneOfPath\n      })) {\n        continue;\n      }\n      // The following code is basically saying:\n      // if the schema specifies oneOf, then we are to loop\n      // over each possible schema and check if they type of the schema specifies format\n      // and if so we use the oneOfSchemaProp as the schema for formatting\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n      if ((schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.format) === undefined && (schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.oneOf) !== undefined) {\n        for (const [_index, oneOfSchemaProp] of schemaProp.oneOf.entries()) {\n          if ((oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.format) !== undefined) {\n            schemaProp = oneOfSchemaProp;\n            break;\n          }\n        }\n      }\n      object[key] = convertScalarValue(value, schemaProp.format, format);\n      dataPath.pop();\n    }\n  }\n  return object;\n};\n/**\n * Given data that can be interpreted according to the provided schema, returns equivalent data that has been formatted\n * according to the provided return format.\n *\n * @param schema - how to interpret the data\n * @param data - data to be formatted\n * @param returnFormat - how to format the data\n * @returns - formatted data\n *\n * @example\n *\n * ```js\n * import { FMT_NUMBER, utils } from \"web3\";\n *\n * console.log(\n *   utils.format({ format: \"uint\" }, \"221\", { number: FMT_NUMBER.HEX }),\n * );\n * // 0xdd\n * ```\n *\n */\nexport const format = (schema, data, returnFormat = DEFAULT_RETURN_FORMAT) => {\n  let dataToParse;\n  if (isObject(data)) {\n    dataToParse = mergeDeep({}, data);\n  } else if (Array.isArray(data)) {\n    dataToParse = [...data];\n  } else {\n    dataToParse = data;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const jsonSchema = isObject(schema) ? schema : utils.ethAbiToJsonSchema(schema);\n  if (!jsonSchema.properties && !jsonSchema.items && !jsonSchema.format) {\n    throw new FormatterError('Invalid json schema for formatting');\n  }\n  return convert(dataToParse, jsonSchema, [], returnFormat);\n};\n//# sourceMappingURL=formatter.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}