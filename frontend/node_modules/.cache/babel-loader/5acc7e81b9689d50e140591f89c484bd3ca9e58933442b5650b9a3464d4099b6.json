{"ast":null,"code":"import { Scene, WebGLRenderTarget, FloatType, MeshPhongMaterial, MeshBasicMaterial, DoubleSide, PlaneGeometry, Mesh } from \"three\";\nimport potpack from \"potpack\";\nimport { UV1 } from \"../_polyfill/uv1.js\";\nclass ProgressiveLightMap {\n  constructor(renderer, res = 1024) {\n    this.renderer = renderer;\n    this.res = res;\n    this.lightMapContainers = [];\n    this.compiled = false;\n    this.scene = new Scene();\n    this.scene.background = null;\n    this.tinyTarget = new WebGLRenderTarget(1, 1);\n    this.buffer1Active = false;\n    this.firstUpdate = true;\n    this.warned = false;\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? alfFloatType : FloatType;\n    this.progressiveLightMap1 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.uvMat = new MeshPhongMaterial();\n    this.uvMat.uniforms = {};\n    this.uvMat.onBeforeCompile = shader => {\n      shader.vertexShader = \"#define USE_LIGHTMAP\\n\" + shader.vertexShader.slice(0, -1) + `\tgl_Position = vec4((${UV1} - 0.5) * 2.0, 1.0, 1.0); }`;\n      const bodyStart = shader.fragmentShader.indexOf(\"void main() {\");\n      shader.fragmentShader = `varying vec2 v${UV1 === \"uv1\" ? UV1 : \"Uv2\"};\n` + shader.fragmentShader.slice(0, bodyStart) + \"\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n\" + shader.fragmentShader.slice(bodyStart - 1, -1) + `\nvec3 texelOld = texture2D(previousShadowMap, v${UV1 === \"uv1\" ? UV1 : \"Uv2\"}).rgb;\n\t\t\t\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n\t\t\t}`;\n      shader.uniforms.previousShadowMap = {\n        value: this.progressiveLightMap1.texture\n      };\n      shader.uniforms.averagingWindow = {\n        value: 100\n      };\n      this.uvMat.uniforms = shader.uniforms;\n      this.uvMat.userData.shader = shader;\n      this.compiled = true;\n    };\n  }\n  /**\n   * Sets these objects' materials' lightmaps and modifies their uv1's.\n   * @param {Object3D} objects An array of objects and lights to set up your lightmap.\n   */\n  addObjectsToLightMap(objects) {\n    this.uv_boxes = [];\n    const padding = 3 / this.res;\n    for (let ob = 0; ob < objects.length; ob++) {\n      const object = objects[ob];\n      if (object.isLight) {\n        this.scene.attach(object);\n        continue;\n      }\n      if (!object.geometry.hasAttribute(\"uv\")) {\n        console.warn(\"All lightmap objects need UVs!\");\n        continue;\n      }\n      if (this.blurringPlane == null) {\n        this._initializeBlurPlane(this.res, this.progressiveLightMap1);\n      }\n      object.material.lightMap = this.progressiveLightMap2.texture;\n      object.material.dithering = true;\n      object.castShadow = true;\n      object.receiveShadow = true;\n      object.renderOrder = 1e3 + ob;\n      this.uv_boxes.push({\n        w: 1 + padding * 2,\n        h: 1 + padding * 2,\n        index: ob\n      });\n      this.lightMapContainers.push({\n        basicMat: object.material,\n        object\n      });\n      this.compiled = false;\n    }\n    const dimensions = potpack(this.uv_boxes);\n    this.uv_boxes.forEach(box => {\n      const uv1 = objects[box.index].geometry.getAttribute(\"uv\").clone();\n      for (let i = 0; i < uv1.array.length; i += uv1.itemSize) {\n        uv1.array[i] = (uv1.array[i] + box.x + padding) / dimensions.w;\n        uv1.array[i + 1] = (uv1.array[i + 1] + box.y + padding) / dimensions.h;\n      }\n      objects[box.index].geometry.setAttribute(UV1, uv1);\n      objects[box.index].geometry.getAttribute(UV1).needsUpdate = true;\n    });\n  }\n  /**\n   * This function renders each mesh one at a time into their respective surface maps\n   * @param {Camera} camera Standard Rendering Camera\n   * @param {number} blendWindow When >1, samples will accumulate over time.\n   * @param {boolean} blurEdges  Whether to fix UV Edges via blurring\n   */\n  update(camera, blendWindow = 100, blurEdges = true) {\n    if (this.blurringPlane == null) {\n      return;\n    }\n    const oldTarget = this.renderer.getRenderTarget();\n    this.blurringPlane.visible = blurEdges;\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent;\n      this.scene.attach(this.lightMapContainers[l].object);\n    }\n    if (this.firstUpdate) {\n      this.renderer.setRenderTarget(this.tinyTarget);\n      this.renderer.render(this.scene, camera);\n      this.firstUpdate = false;\n    }\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.uvMat.uniforms.averagingWindow = {\n        value: blendWindow\n      };\n      this.lightMapContainers[l].object.material = this.uvMat;\n      this.lightMapContainers[l].object.oldFrustumCulled = this.lightMapContainers[l].object.frustumCulled;\n      this.lightMapContainers[l].object.frustumCulled = false;\n    }\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;\n    this.renderer.setRenderTarget(activeMap);\n    this.uvMat.uniforms.previousShadowMap = {\n      value: inactiveMap.texture\n    };\n    this.blurringPlane.material.uniforms.previousShadowMap = {\n      value: inactiveMap.texture\n    };\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera);\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.frustumCulled = this.lightMapContainers[l].object.oldFrustumCulled;\n      this.lightMapContainers[l].object.material = this.lightMapContainers[l].basicMat;\n      this.lightMapContainers[l].object.oldScene.attach(this.lightMapContainers[l].object);\n    }\n    this.renderer.setRenderTarget(oldTarget);\n  }\n  /** DEBUG\n   * Draw the lightmap in the main scene.  Call this after adding the objects to it.\n   * @param {boolean} visible Whether the debug plane should be visible\n   * @param {Vector3} position Where the debug plane should be drawn\n   */\n  showDebugLightmap(visible, position = void 0) {\n    if (this.lightMapContainers.length == 0) {\n      if (!this.warned) {\n        console.warn(\"Call this after adding the objects!\");\n        this.warned = true;\n      }\n      return;\n    }\n    if (this.labelMesh == null) {\n      this.labelMaterial = new MeshBasicMaterial({\n        map: this.progressiveLightMap1.texture,\n        side: DoubleSide\n      });\n      this.labelPlane = new PlaneGeometry(100, 100);\n      this.labelMesh = new Mesh(this.labelPlane, this.labelMaterial);\n      this.labelMesh.position.y = 250;\n      this.lightMapContainers[0].object.parent.add(this.labelMesh);\n    }\n    if (position != void 0) {\n      this.labelMesh.position.copy(position);\n    }\n    this.labelMesh.visible = visible;\n  }\n  /**\n   * INTERNAL Creates the Blurring Plane\n   * @param {number} res The square resolution of this object's lightMap.\n   * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.\n   */\n  _initializeBlurPlane(res, lightMap = null) {\n    const blurMaterial = new MeshBasicMaterial();\n    blurMaterial.uniforms = {\n      previousShadowMap: {\n        value: null\n      },\n      pixelOffset: {\n        value: 1 / res\n      },\n      polygonOffset: true,\n      polygonOffsetFactor: -1,\n      polygonOffsetUnits: 3\n    };\n    blurMaterial.onBeforeCompile = shader => {\n      shader.vertexShader = \"#define USE_UV\\n\" + shader.vertexShader.slice(0, -1) + \"\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }\";\n      const bodyStart = shader.fragmentShader.indexOf(\"void main() {\");\n      shader.fragmentShader = \"#define USE_UV\\n\" + shader.fragmentShader.slice(0, bodyStart) + \"\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n\" + shader.fragmentShader.slice(bodyStart - 1, -1) + `\tgl_FragColor.rgb = (\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\n\t\t}`;\n      shader.uniforms.previousShadowMap = {\n        value: lightMap.texture\n      };\n      shader.uniforms.pixelOffset = {\n        value: 0.5 / res\n      };\n      blurMaterial.uniforms = shader.uniforms;\n      blurMaterial.userData.shader = shader;\n      this.compiled = true;\n    };\n    this.blurringPlane = new Mesh(new PlaneGeometry(1, 1), blurMaterial);\n    this.blurringPlane.name = \"Blurring Plane\";\n    this.blurringPlane.frustumCulled = false;\n    this.blurringPlane.renderOrder = 0;\n    this.blurringPlane.material.depthWrite = false;\n    this.scene.add(this.blurringPlane);\n  }\n}\nexport { ProgressiveLightMap };\n//# sourceMappingURL=ProgressiveLightmap.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}