{"ast":null,"code":"import { NFTStorage } from 'nft.storage';\nconst NFT_STORAGE_KEY = process.env.REACT_APP_NFT_STORAGE_KEY;\nconst COLLECTION_ID = process.env.REACT_APP_NFT_STORAGE_COLLECTION_ID;\nconsole.log('Starting NFT.Storage setup...');\nif (!NFT_STORAGE_KEY || !COLLECTION_ID) {\n  throw new Error('NFT Storage configuration missing');\n}\nexport const uploadToIPFS = async (glbUrl, originalNFT) => {\n  try {\n    console.log('Starting upload process...');\n\n    // Get the GLB file\n    console.log('Fetching GLB from:', glbUrl);\n    const response = await fetch(glbUrl);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch GLB: ${response.status}`);\n    }\n    const glbBlob = await response.blob();\n    console.log('GLB file fetched:', {\n      size: glbBlob.size,\n      type: glbBlob.type\n    });\n\n    // Create CSV content\n    const tokenID = Date.now().toString();\n    const csvContent = `tokenID,cid\\n${tokenID},${glbBlob.size}`; // Using size as temporary CID\n\n    // Create CSV file\n    const csvFile = new Blob([csvContent], {\n      type: 'text/csv'\n    });\n\n    // Upload using FormData\n    const formData = new FormData();\n    formData.append('collectionID', COLLECTION_ID);\n    formData.append('file', csvFile, 'tokens.csv');\n    console.log('Uploading with collection ID:', COLLECTION_ID);\n    const uploadResponse = await fetch('https://preserve.nft.storage/api/v1/collection/add_tokens', {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${NFT_STORAGE_KEY.trim()}`,\n        'Accept': 'application/json'\n      },\n      body: formData\n    });\n    if (!uploadResponse.ok) {\n      const error = await uploadResponse.json();\n      console.error('Upload response:', error);\n      throw new Error(`Upload failed: ${JSON.stringify(error)}`);\n    }\n    const uploadData = await uploadResponse.json();\n    console.log('Upload successful:', uploadData);\n\n    // Return IPFS URI using the token ID\n    return `ipfs://${tokenID}`;\n  } catch (error) {\n    console.error('Upload error:', {\n      message: error.message,\n      name: error.name,\n      response: error.response\n    });\n    throw error;\n  }\n};","map":{"version":3,"names":["NFTStorage","NFT_STORAGE_KEY","process","env","REACT_APP_NFT_STORAGE_KEY","COLLECTION_ID","REACT_APP_NFT_STORAGE_COLLECTION_ID","console","log","Error","uploadToIPFS","glbUrl","originalNFT","response","fetch","ok","status","glbBlob","blob","size","type","tokenID","Date","now","toString","csvContent","csvFile","Blob","formData","FormData","append","uploadResponse","method","headers","trim","body","error","json","JSON","stringify","uploadData","message","name"],"sources":["/Users/thomasheindl/Documents/beamitai01/beamitai/frontend/src/utils/ipfsHandler.js"],"sourcesContent":["import { NFTStorage } from 'nft.storage';\n\nconst NFT_STORAGE_KEY = process.env.REACT_APP_NFT_STORAGE_KEY;\nconst COLLECTION_ID = process.env.REACT_APP_NFT_STORAGE_COLLECTION_ID;\n\nconsole.log('Starting NFT.Storage setup...');\n\nif (!NFT_STORAGE_KEY || !COLLECTION_ID) {\n    throw new Error('NFT Storage configuration missing');\n}\n\nexport const uploadToIPFS = async (glbUrl, originalNFT) => {\n    try {\n        console.log('Starting upload process...');\n\n        // Get the GLB file\n        console.log('Fetching GLB from:', glbUrl);\n        const response = await fetch(glbUrl);\n        if (!response.ok) {\n            throw new Error(`Failed to fetch GLB: ${response.status}`);\n        }\n        const glbBlob = await response.blob();\n        console.log('GLB file fetched:', {\n            size: glbBlob.size,\n            type: glbBlob.type\n        });\n\n        // Create CSV content\n        const tokenID = Date.now().toString();\n        const csvContent = `tokenID,cid\\n${tokenID},${glbBlob.size}`; // Using size as temporary CID\n        \n        // Create CSV file\n        const csvFile = new Blob([csvContent], {\n            type: 'text/csv'\n        });\n\n        // Upload using FormData\n        const formData = new FormData();\n        formData.append('collectionID', COLLECTION_ID);\n        formData.append('file', csvFile, 'tokens.csv');\n\n        console.log('Uploading with collection ID:', COLLECTION_ID);\n\n        const uploadResponse = await fetch('https://preserve.nft.storage/api/v1/collection/add_tokens', {\n            method: 'POST',\n            headers: {\n                'Authorization': `Bearer ${NFT_STORAGE_KEY.trim()}`,\n                'Accept': 'application/json'\n            },\n            body: formData\n        });\n\n        if (!uploadResponse.ok) {\n            const error = await uploadResponse.json();\n            console.error('Upload response:', error);\n            throw new Error(`Upload failed: ${JSON.stringify(error)}`);\n        }\n\n        const uploadData = await uploadResponse.json();\n        console.log('Upload successful:', uploadData);\n\n        // Return IPFS URI using the token ID\n        return `ipfs://${tokenID}`;\n    } catch (error) {\n        console.error('Upload error:', {\n            message: error.message,\n            name: error.name,\n            response: error.response\n        });\n        throw error;\n    }\n};\n"],"mappings":"AAAA,SAASA,UAAU,QAAQ,aAAa;AAExC,MAAMC,eAAe,GAAGC,OAAO,CAACC,GAAG,CAACC,yBAAyB;AAC7D,MAAMC,aAAa,GAAGH,OAAO,CAACC,GAAG,CAACG,mCAAmC;AAErEC,OAAO,CAACC,GAAG,CAAC,+BAA+B,CAAC;AAE5C,IAAI,CAACP,eAAe,IAAI,CAACI,aAAa,EAAE;EACpC,MAAM,IAAII,KAAK,CAAC,mCAAmC,CAAC;AACxD;AAEA,OAAO,MAAMC,YAAY,GAAG,MAAAA,CAAOC,MAAM,EAAEC,WAAW,KAAK;EACvD,IAAI;IACAL,OAAO,CAACC,GAAG,CAAC,4BAA4B,CAAC;;IAEzC;IACAD,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAEG,MAAM,CAAC;IACzC,MAAME,QAAQ,GAAG,MAAMC,KAAK,CAACH,MAAM,CAAC;IACpC,IAAI,CAACE,QAAQ,CAACE,EAAE,EAAE;MACd,MAAM,IAAIN,KAAK,CAAC,wBAAwBI,QAAQ,CAACG,MAAM,EAAE,CAAC;IAC9D;IACA,MAAMC,OAAO,GAAG,MAAMJ,QAAQ,CAACK,IAAI,CAAC,CAAC;IACrCX,OAAO,CAACC,GAAG,CAAC,mBAAmB,EAAE;MAC7BW,IAAI,EAAEF,OAAO,CAACE,IAAI;MAClBC,IAAI,EAAEH,OAAO,CAACG;IAClB,CAAC,CAAC;;IAEF;IACA,MAAMC,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC;IACrC,MAAMC,UAAU,GAAG,gBAAgBJ,OAAO,IAAIJ,OAAO,CAACE,IAAI,EAAE,CAAC,CAAC;;IAE9D;IACA,MAAMO,OAAO,GAAG,IAAIC,IAAI,CAAC,CAACF,UAAU,CAAC,EAAE;MACnCL,IAAI,EAAE;IACV,CAAC,CAAC;;IAEF;IACA,MAAMQ,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;IAC/BD,QAAQ,CAACE,MAAM,CAAC,cAAc,EAAEzB,aAAa,CAAC;IAC9CuB,QAAQ,CAACE,MAAM,CAAC,MAAM,EAAEJ,OAAO,EAAE,YAAY,CAAC;IAE9CnB,OAAO,CAACC,GAAG,CAAC,+BAA+B,EAAEH,aAAa,CAAC;IAE3D,MAAM0B,cAAc,GAAG,MAAMjB,KAAK,CAAC,2DAA2D,EAAE;MAC5FkB,MAAM,EAAE,MAAM;MACdC,OAAO,EAAE;QACL,eAAe,EAAE,UAAUhC,eAAe,CAACiC,IAAI,CAAC,CAAC,EAAE;QACnD,QAAQ,EAAE;MACd,CAAC;MACDC,IAAI,EAAEP;IACV,CAAC,CAAC;IAEF,IAAI,CAACG,cAAc,CAAChB,EAAE,EAAE;MACpB,MAAMqB,KAAK,GAAG,MAAML,cAAc,CAACM,IAAI,CAAC,CAAC;MACzC9B,OAAO,CAAC6B,KAAK,CAAC,kBAAkB,EAAEA,KAAK,CAAC;MACxC,MAAM,IAAI3B,KAAK,CAAC,kBAAkB6B,IAAI,CAACC,SAAS,CAACH,KAAK,CAAC,EAAE,CAAC;IAC9D;IAEA,MAAMI,UAAU,GAAG,MAAMT,cAAc,CAACM,IAAI,CAAC,CAAC;IAC9C9B,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAEgC,UAAU,CAAC;;IAE7C;IACA,OAAO,UAAUnB,OAAO,EAAE;EAC9B,CAAC,CAAC,OAAOe,KAAK,EAAE;IACZ7B,OAAO,CAAC6B,KAAK,CAAC,eAAe,EAAE;MAC3BK,OAAO,EAAEL,KAAK,CAACK,OAAO;MACtBC,IAAI,EAAEN,KAAK,CAACM,IAAI;MAChB7B,QAAQ,EAAEuB,KAAK,CAACvB;IACpB,CAAC,CAAC;IACF,MAAMuB,KAAK;EACf;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}