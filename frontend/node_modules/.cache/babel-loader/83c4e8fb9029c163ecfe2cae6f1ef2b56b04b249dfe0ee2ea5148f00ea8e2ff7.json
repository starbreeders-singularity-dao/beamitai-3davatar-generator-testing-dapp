{"ast":null,"code":"function SDFGenerator() {\n  var exports = function (exports) {\n    /**\n     * Find the point on a quadratic bezier curve at t where t is in the range [0, 1]\n     */\n    function pointOnQuadraticBezier(x0, y0, x1, y1, x2, y2, t, pointOut) {\n      var t2 = 1 - t;\n      pointOut.x = t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2;\n      pointOut.y = t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2;\n    }\n\n    /**\n     * Find the point on a cubic bezier curve at t where t is in the range [0, 1]\n     */\n    function pointOnCubicBezier(x0, y0, x1, y1, x2, y2, x3, y3, t, pointOut) {\n      var t2 = 1 - t;\n      pointOut.x = t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3;\n      pointOut.y = t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3;\n    }\n\n    /**\n     * Parse a path string into its constituent line/curve commands, invoking a callback for each.\n     * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n     * @param {function(\n     *   command: 'L'|'Q'|'C',\n     *   startX: number,\n     *   startY: number,\n     *   endX: number,\n     *   endY: number,\n     *   ctrl1X?: number,\n     *   ctrl1Y?: number,\n     *   ctrl2X?: number,\n     *   ctrl2Y?: number\n     * )} commandCallback - A callback function that will be called once for each parsed path command, passing the\n     *                      command identifier (only L/Q/C commands) and its numeric arguments.\n     */\n    function forEachPathCommand(pathString, commandCallback) {\n      var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;\n      var match, firstX, firstY, prevX, prevY;\n      while (match = segmentRE.exec(pathString)) {\n        var args = match[2].replace(/^\\s*|\\s*$/g, '').split(/[,\\s]+/).map(function (v) {\n          return parseFloat(v);\n        });\n        switch (match[1]) {\n          case 'M':\n            prevX = firstX = args[0];\n            prevY = firstY = args[1];\n            break;\n          case 'L':\n            if (args[0] !== prevX || args[1] !== prevY) {\n              // yup, some fonts have zero-length line commands\n              commandCallback('L', prevX, prevY, prevX = args[0], prevY = args[1]);\n            }\n            break;\n          case 'Q':\n            {\n              commandCallback('Q', prevX, prevY, prevX = args[2], prevY = args[3], args[0], args[1]);\n              break;\n            }\n          case 'C':\n            {\n              commandCallback('C', prevX, prevY, prevX = args[4], prevY = args[5], args[0], args[1], args[2], args[3]);\n              break;\n            }\n          case 'Z':\n            if (prevX !== firstX || prevY !== firstY) {\n              commandCallback('L', prevX, prevY, firstX, firstY);\n            }\n            break;\n        }\n      }\n    }\n\n    /**\n     * Convert a path string to a series of straight line segments\n     * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n     * @param {function(x1:number, y1:number, x2:number, y2:number)} segmentCallback - A callback\n     *        function that will be called once for every line segment\n     * @param {number} [curvePoints] - How many straight line segments to use when approximating a\n     *        bezier curve in the path. Defaults to 16.\n     */\n    function pathToLineSegments(pathString, segmentCallback, curvePoints) {\n      if (curvePoints === void 0) curvePoints = 16;\n      var tempPoint = {\n        x: 0,\n        y: 0\n      };\n      forEachPathCommand(pathString, function (command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {\n        switch (command) {\n          case 'L':\n            segmentCallback(startX, startY, endX, endY);\n            break;\n          case 'Q':\n            {\n              var prevCurveX = startX;\n              var prevCurveY = startY;\n              for (var i = 1; i < curvePoints; i++) {\n                pointOnQuadraticBezier(startX, startY, ctrl1X, ctrl1Y, endX, endY, i / (curvePoints - 1), tempPoint);\n                segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);\n                prevCurveX = tempPoint.x;\n                prevCurveY = tempPoint.y;\n              }\n              break;\n            }\n          case 'C':\n            {\n              var prevCurveX$1 = startX;\n              var prevCurveY$1 = startY;\n              for (var i$1 = 1; i$1 < curvePoints; i$1++) {\n                pointOnCubicBezier(startX, startY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y, endX, endY, i$1 / (curvePoints - 1), tempPoint);\n                segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);\n                prevCurveX$1 = tempPoint.x;\n                prevCurveY$1 = tempPoint.y;\n              }\n              break;\n            }\n        }\n      });\n    }\n    var viewportQuadVertex = \"precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n    var copyTexFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}\";\n    var cache = new WeakMap();\n    var glContextParams = {\n      premultipliedAlpha: false,\n      preserveDrawingBuffer: true,\n      antialias: false,\n      depth: false\n    };\n\n    /**\n     * This is a little helper library for WebGL. It assists with state management for a GL context.\n     * It's pretty tightly wrapped to the needs of this package, not very general-purpose.\n     *\n     * @param { WebGLRenderingContext | HTMLCanvasElement | OffscreenCanvas } glOrCanvas - the GL context to wrap\n     * @param { ({gl, getExtension, withProgram, withTexture, withTextureFramebuffer, handleContextLoss}) => void } callback\n     */\n    function withWebGLContext(glOrCanvas, callback) {\n      var gl = glOrCanvas.getContext ? glOrCanvas.getContext('webgl', glContextParams) : glOrCanvas;\n      var wrapper = cache.get(gl);\n      if (!wrapper) {\n        var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n        var extensions = {};\n        var programs = {};\n        var textures = {};\n        var textureUnit = -1;\n        var framebufferStack = [];\n        gl.canvas.addEventListener('webglcontextlost', function (e) {\n          handleContextLoss();\n          e.preventDefault();\n        }, false);\n        function getExtension(name) {\n          var ext = extensions[name];\n          if (!ext) {\n            ext = extensions[name] = gl.getExtension(name);\n            if (!ext) {\n              throw new Error(name + \" not supported\");\n            }\n          }\n          return ext;\n        }\n        function compileShader(src, type) {\n          var shader = gl.createShader(type);\n          gl.shaderSource(shader, src);\n          gl.compileShader(shader);\n          // const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS)\n          // if (!status && !gl.isContextLost()) {\n          //   throw new Error(gl.getShaderInfoLog(shader).trim())\n          // }\n          return shader;\n        }\n        function withProgram(name, vert, frag, func) {\n          if (!programs[name]) {\n            var attributes = {};\n            var uniforms = {};\n            var program = gl.createProgram();\n            gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));\n            gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));\n            gl.linkProgram(program);\n            programs[name] = {\n              program: program,\n              transaction: function transaction(func) {\n                gl.useProgram(program);\n                func({\n                  setUniform: function setUniform(type, name) {\n                    var values = [],\n                      len = arguments.length - 2;\n                    while (len-- > 0) values[len] = arguments[len + 2];\n                    var uniformLoc = uniforms[name] || (uniforms[name] = gl.getUniformLocation(program, name));\n                    gl[\"uniform\" + type].apply(gl, [uniformLoc].concat(values));\n                  },\n                  setAttribute: function setAttribute(name, size, usage, instancingDivisor, data) {\n                    var attr = attributes[name];\n                    if (!attr) {\n                      attr = attributes[name] = {\n                        buf: gl.createBuffer(),\n                        // TODO should we destroy our buffers?\n                        loc: gl.getAttribLocation(program, name),\n                        data: null\n                      };\n                    }\n                    gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);\n                    gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);\n                    gl.enableVertexAttribArray(attr.loc);\n                    if (isWebGL2) {\n                      gl.vertexAttribDivisor(attr.loc, instancingDivisor);\n                    } else {\n                      getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(attr.loc, instancingDivisor);\n                    }\n                    if (data !== attr.data) {\n                      gl.bufferData(gl.ARRAY_BUFFER, data, usage);\n                      attr.data = data;\n                    }\n                  }\n                });\n              }\n            };\n          }\n          programs[name].transaction(func);\n        }\n        function withTexture(name, func) {\n          textureUnit++;\n          try {\n            gl.activeTexture(gl.TEXTURE0 + textureUnit);\n            var texture = textures[name];\n            if (!texture) {\n              texture = textures[name] = gl.createTexture();\n              gl.bindTexture(gl.TEXTURE_2D, texture);\n              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            }\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            func(texture, textureUnit);\n          } finally {\n            textureUnit--;\n          }\n        }\n        function withTextureFramebuffer(texture, textureUnit, func) {\n          var framebuffer = gl.createFramebuffer();\n          framebufferStack.push(framebuffer);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n          gl.activeTexture(gl.TEXTURE0 + textureUnit);\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n          try {\n            func(framebuffer);\n          } finally {\n            gl.deleteFramebuffer(framebuffer);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);\n          }\n        }\n        function handleContextLoss() {\n          extensions = {};\n          programs = {};\n          textures = {};\n          textureUnit = -1;\n          framebufferStack.length = 0;\n        }\n        cache.set(gl, wrapper = {\n          gl: gl,\n          isWebGL2: isWebGL2,\n          getExtension: getExtension,\n          withProgram: withProgram,\n          withTexture: withTexture,\n          withTextureFramebuffer: withTextureFramebuffer,\n          handleContextLoss: handleContextLoss\n        });\n      }\n      callback(wrapper);\n    }\n    function renderImageData(glOrCanvas, imageData, x, y, width, height, channels, framebuffer) {\n      if (channels === void 0) channels = 15;\n      if (framebuffer === void 0) framebuffer = null;\n      withWebGLContext(glOrCanvas, function (ref) {\n        var gl = ref.gl;\n        var withProgram = ref.withProgram;\n        var withTexture = ref.withTexture;\n        withTexture('copy', function (tex, texUnit) {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n          withProgram('copy', viewportQuadVertex, copyTexFragment, function (ref) {\n            var setUniform = ref.setUniform;\n            var setAttribute = ref.setAttribute;\n            setAttribute('aUV', 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));\n            setUniform('1i', 'image', texUnit);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);\n            gl.disable(gl.BLEND);\n            gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);\n            gl.viewport(x, y, width, height);\n            gl.scissor(x, y, width, height);\n            gl.drawArrays(gl.TRIANGLES, 0, 3);\n          });\n        });\n      });\n    }\n\n    /**\n     * Resizing a canvas clears its contents; this utility copies the previous contents over.\n     * @param canvas\n     * @param newWidth\n     * @param newHeight\n     */\n    function resizeWebGLCanvasWithoutClearing(canvas, newWidth, newHeight) {\n      var width = canvas.width;\n      var height = canvas.height;\n      withWebGLContext(canvas, function (ref) {\n        var gl = ref.gl;\n        var data = new Uint8Array(width * height * 4);\n        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n        canvas.width = newWidth;\n        canvas.height = newHeight;\n        renderImageData(gl, data, 0, 0, width, height);\n      });\n    }\n    var webglUtils = /*#__PURE__*/Object.freeze({\n      __proto__: null,\n      withWebGLContext: withWebGLContext,\n      renderImageData: renderImageData,\n      resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing\n    });\n    function generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {\n      if (sdfExponent === void 0) sdfExponent = 1;\n      var textureData = new Uint8Array(sdfWidth * sdfHeight);\n      var viewBoxWidth = viewBox[2] - viewBox[0];\n      var viewBoxHeight = viewBox[3] - viewBox[1];\n\n      // Decompose all paths into straight line segments and add them to an index\n      var segments = [];\n      pathToLineSegments(path, function (x1, y1, x2, y2) {\n        segments.push({\n          x1: x1,\n          y1: y1,\n          x2: x2,\n          y2: y2,\n          minX: Math.min(x1, x2),\n          minY: Math.min(y1, y2),\n          maxX: Math.max(x1, x2),\n          maxY: Math.max(y1, y2)\n        });\n      });\n\n      // Sort segments by maxX, this will let us short-circuit some loops below\n      segments.sort(function (a, b) {\n        return a.maxX - b.maxX;\n      });\n\n      // For each target SDF texel, find the distance from its center to its nearest line segment,\n      // map that distance to an alpha value, and write that alpha to the texel\n      for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {\n        for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {\n          var signedDist = findNearestSignedDistance(viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth, viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight);\n\n          // Use an exponential scale to ensure the texels very near the glyph path have adequate\n          // precision, while allowing the distance field to cover the entire texture, given that\n          // there are only 8 bits available. Formula visualized: https://www.desmos.com/calculator/uiaq5aqiam\n          var alpha = Math.pow(1 - Math.abs(signedDist) / maxDistance, sdfExponent) / 2;\n          if (signedDist < 0) {\n            alpha = 1 - alpha;\n          }\n          alpha = Math.max(0, Math.min(255, Math.round(alpha * 255))); //clamp\n          textureData[sdfY * sdfWidth + sdfX] = alpha;\n        }\n      }\n      return textureData;\n\n      /**\n       * For a given x/y, search the index for the closest line segment and return\n       * its signed distance. Negative = inside, positive = outside, zero = on edge\n       * @param x\n       * @param y\n       * @returns {number}\n       */\n      function findNearestSignedDistance(x, y) {\n        var closestDistSq = Infinity;\n        var closestDist = Infinity;\n        for (var i = segments.length; i--;) {\n          var seg = segments[i];\n          if (seg.maxX + closestDist <= x) {\n            break;\n          } //sorting by maxX means no more can be closer, so we can short-circuit\n          if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {\n            var distSq = absSquareDistanceToLineSegment(x, y, seg.x1, seg.y1, seg.x2, seg.y2);\n            if (distSq < closestDistSq) {\n              closestDistSq = distSq;\n              closestDist = Math.sqrt(closestDistSq);\n            }\n          }\n        }\n\n        // Flip to negative distance if inside the poly\n        if (isPointInPoly(x, y)) {\n          closestDist = -closestDist;\n        }\n        return closestDist;\n      }\n\n      /**\n       * Determine whether the given point lies inside or outside the glyph. Uses a simple\n       * winding-number ray casting algorithm using a ray pointing east from the point.\n       */\n      function isPointInPoly(x, y) {\n        var winding = 0;\n        for (var i = segments.length; i--;) {\n          var seg = segments[i];\n          if (seg.maxX <= x) {\n            break;\n          } //sorting by maxX means no more can cross, so we can short-circuit\n          var intersects = seg.y1 > y !== seg.y2 > y && x < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1;\n          if (intersects) {\n            winding += seg.y1 < seg.y2 ? 1 : -1;\n          }\n        }\n        return winding !== 0;\n      }\n    }\n    function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n      if (sdfExponent === void 0) sdfExponent = 1;\n      if (x === void 0) x = 0;\n      if (y === void 0) y = 0;\n      if (channel === void 0) channel = 0;\n      generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n    }\n    function generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n      if (sdfExponent === void 0) sdfExponent = 1;\n      if (x === void 0) x = 0;\n      if (y === void 0) y = 0;\n      if (channel === void 0) channel = 0;\n      var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);\n      // Expand single-channel data to rbga\n      var rgbaData = new Uint8Array(data.length * 4);\n      for (var i = 0; i < data.length; i++) {\n        rgbaData[i * 4 + channel] = data[i];\n      }\n      renderImageData(glOrCanvas, rgbaData, x, y, sdfWidth, sdfHeight, 1 << 3 - channel, framebuffer);\n    }\n\n    /**\n     * Find the absolute distance from a point to a line segment at closest approach\n     */\n    function absSquareDistanceToLineSegment(x, y, lineX0, lineY0, lineX1, lineY1) {\n      var ldx = lineX1 - lineX0;\n      var ldy = lineY1 - lineY0;\n      var lengthSq = ldx * ldx + ldy * ldy;\n      var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;\n      var dx = x - (lineX0 + t * ldx);\n      var dy = y - (lineY0 + t * ldy);\n      return dx * dx + dy * dy;\n    }\n    var javascript = /*#__PURE__*/Object.freeze({\n      __proto__: null,\n      generate: generate$2,\n      generateIntoCanvas: generateIntoCanvas$2,\n      generateIntoFramebuffer: generateIntoFramebuffer$1\n    });\n    var mainVertex = \"precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n    var mainFragment = \"precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}\";\n    var postFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}\";\n\n    // Single triangle covering viewport\n    var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);\n    var implicitContext = null;\n    var isTestingSupport = false;\n    var NULL_OBJECT = {};\n    var supportByCanvas = new WeakMap(); // canvas -> bool\n\n    function validateSupport(glOrCanvas) {\n      if (!isTestingSupport && !isSupported(glOrCanvas)) {\n        throw new Error('WebGL generation not supported');\n      }\n    }\n    function generate$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {\n      if (sdfExponent === void 0) sdfExponent = 1;\n      if (glOrCanvas === void 0) glOrCanvas = null;\n      if (!glOrCanvas) {\n        glOrCanvas = implicitContext;\n        if (!glOrCanvas) {\n          var canvas = typeof OffscreenCanvas === 'function' ? new OffscreenCanvas(1, 1) : typeof document !== 'undefined' ? document.createElement('canvas') : null;\n          if (!canvas) {\n            throw new Error('OffscreenCanvas or DOM canvas not supported');\n          }\n          glOrCanvas = implicitContext = canvas.getContext('webgl', {\n            depth: false\n          });\n        }\n      }\n      validateSupport(glOrCanvas);\n      var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4); //not Uint8ClampedArray, cuz Safari\n\n      // Render into a background texture framebuffer\n      withWebGLContext(glOrCanvas, function (ref) {\n        var gl = ref.gl;\n        var withTexture = ref.withTexture;\n        var withTextureFramebuffer = ref.withTextureFramebuffer;\n        withTexture('readable', function (texture, textureUnit) {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n          withTextureFramebuffer(texture, textureUnit, function (framebuffer) {\n            generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, gl, framebuffer, 0, 0, 0 // red channel\n            );\n            gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);\n          });\n        });\n      });\n\n      // Throw away all but the red channel\n      var data = new Uint8Array(sdfWidth * sdfHeight);\n      for (var i = 0, j = 0; i < rgbaData.length; i += 4) {\n        data[j++] = rgbaData[i];\n      }\n      return data;\n    }\n    function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n      if (sdfExponent === void 0) sdfExponent = 1;\n      if (x === void 0) x = 0;\n      if (y === void 0) y = 0;\n      if (channel === void 0) channel = 0;\n      generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n    }\n    function generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n      if (sdfExponent === void 0) sdfExponent = 1;\n      if (x === void 0) x = 0;\n      if (y === void 0) y = 0;\n      if (channel === void 0) channel = 0;\n\n      // Verify support\n      validateSupport(glOrCanvas);\n\n      // Compute path segments\n      var lineSegmentCoords = [];\n      pathToLineSegments(path, function (x1, y1, x2, y2) {\n        lineSegmentCoords.push(x1, y1, x2, y2);\n      });\n      lineSegmentCoords = new Float32Array(lineSegmentCoords);\n      withWebGLContext(glOrCanvas, function (ref) {\n        var gl = ref.gl;\n        var isWebGL2 = ref.isWebGL2;\n        var getExtension = ref.getExtension;\n        var withProgram = ref.withProgram;\n        var withTexture = ref.withTexture;\n        var withTextureFramebuffer = ref.withTextureFramebuffer;\n        var handleContextLoss = ref.handleContextLoss;\n        withTexture('rawDistances', function (intermediateTexture, intermediateTextureUnit) {\n          if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, intermediateTexture._lastWidth = sdfWidth, intermediateTexture._lastHeight = sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n          }\n\n          // Unsigned distance pass\n          withProgram('main', mainVertex, mainFragment, function (ref) {\n            var setAttribute = ref.setAttribute;\n            var setUniform = ref.setUniform;\n\n            // Init extensions\n            var instancingExtension = !isWebGL2 && getExtension('ANGLE_instanced_arrays');\n            var blendMinMaxExtension = !isWebGL2 && getExtension('EXT_blend_minmax');\n\n            // Init/update attributes\n            setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n            setAttribute('aLineSegment', 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);\n\n            // Init/update uniforms\n            setUniform.apply(void 0, ['4f', 'uGlyphBounds'].concat(viewBox));\n            setUniform('1f', 'uMaxDistance', maxDistance);\n            setUniform('1f', 'uExponent', sdfExponent);\n\n            // Render initial unsigned distance / winding number info to a texture\n            withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function (framebuffer) {\n              gl.enable(gl.BLEND);\n              gl.colorMask(true, true, true, true);\n              gl.viewport(0, 0, sdfWidth, sdfHeight);\n              gl.scissor(0, 0, sdfWidth, sdfHeight);\n              gl.blendFunc(gl.ONE, gl.ONE);\n              // Red+Green channels are incremented (FUNC_ADD) for segment-ray crossings to give a \"winding number\".\n              // Alpha holds the closest (MAX) unsigned distance.\n              gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);\n              gl.clear(gl.COLOR_BUFFER_BIT);\n              if (isWebGL2) {\n                gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n              } else {\n                instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n              }\n              // Debug\n              // const debug = new Uint8Array(sdfWidth * sdfHeight * 4)\n              // gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, debug)\n              // console.log('intermediate texture data: ', debug)\n            });\n          });\n\n          // Use the data stored in the texture to apply inside/outside and write to the output framebuffer rect+channel.\n          withProgram('post', viewportQuadVertex, postFragment, function (program) {\n            program.setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n            program.setUniform('1i', 'tex', intermediateTextureUnit);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n            gl.disable(gl.BLEND);\n            gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);\n            gl.viewport(x, y, sdfWidth, sdfHeight);\n            gl.scissor(x, y, sdfWidth, sdfHeight);\n            gl.drawArrays(gl.TRIANGLES, 0, 3);\n          });\n        });\n\n        // Handle context loss occurring during any of the above calls\n        if (gl.isContextLost()) {\n          handleContextLoss();\n          throw new Error('webgl context lost');\n        }\n      });\n    }\n    function isSupported(glOrCanvas) {\n      var key = !glOrCanvas || glOrCanvas === implicitContext ? NULL_OBJECT : glOrCanvas.canvas || glOrCanvas;\n      var supported = supportByCanvas.get(key);\n      if (supported === undefined) {\n        isTestingSupport = true;\n        var failReason = null;\n        try {\n          // Since we can't detect all failure modes up front, let's just do a trial run of a\n          // simple path and compare what we get back to the correct expected result. This will\n          // also serve to prime the shader compilation.\n          var expectedResult = [97, 106, 97, 61, 99, 137, 118, 80, 80, 118, 137, 99, 61, 97, 106, 97];\n          var testResult = generate$1(4, 4, 'M8,8L16,8L24,24L16,24Z', [0, 0, 32, 32], 24, 1, glOrCanvas);\n          supported = testResult && expectedResult.length === testResult.length && testResult.every(function (val, i) {\n            return val === expectedResult[i];\n          });\n          if (!supported) {\n            failReason = 'bad trial run results';\n            console.info(expectedResult, testResult);\n          }\n        } catch (err) {\n          // TODO if it threw due to webgl context loss, should we maybe leave isSupported as null and try again later?\n          supported = false;\n          failReason = err.message;\n        }\n        if (failReason) {\n          console.warn('WebGL SDF generation not supported:', failReason);\n        }\n        isTestingSupport = false;\n        supportByCanvas.set(key, supported);\n      }\n      return supported;\n    }\n    var webgl = /*#__PURE__*/Object.freeze({\n      __proto__: null,\n      generate: generate$1,\n      generateIntoCanvas: generateIntoCanvas$1,\n      generateIntoFramebuffer: generateIntoFramebuffer,\n      isSupported: isSupported\n    });\n\n    /**\n     * Generate an SDF texture image for a 2D path.\n     *\n     * @param {number} sdfWidth - width of the SDF output image in pixels.\n     * @param {number} sdfHeight - height of the SDF output image in pixels.\n     * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n     * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n     * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n     *        to half the maximum viewBox dimension.\n     * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n     *        will give greater precision nearer the glyph's path.\n     * @return {Uint8Array}\n     */\n    function generate(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {\n      if (maxDistance === void 0) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n      if (sdfExponent === void 0) sdfExponent = 1;\n      try {\n        return generate$1.apply(webgl, arguments);\n      } catch (e) {\n        console.info('WebGL SDF generation failed, falling back to JS', e);\n        return generate$2.apply(javascript, arguments);\n      }\n    }\n\n    /**\n     * Generate an SDF texture image for a 2D path, inserting the result into a WebGL `canvas` at a given x/y position\n     * and color channel. This is generally much faster than calling `generate` because it does not require reading pixels\n     * back from the GPU->CPU -- the `canvas` can be used directly as a WebGL texture image, so it all stays on the GPU.\n     *\n     * @param {number} sdfWidth - width of the SDF output image in pixels.\n     * @param {number} sdfHeight - height of the SDF output image in pixels.\n     * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n     * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n     * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n     *        to half the maximum viewBox dimension.\n     * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n     *        will give greater precision nearer the glyph's path.\n     * @param {HTMLCanvasElement|OffscreenCanvas} canvas - a WebGL-enabled canvas into which the SDF will be rendered.\n     *        Only the relevant rect/channel will be modified, the rest will be preserved. To avoid unpredictable results\n     *        due to shared GL context state, this canvas should be dedicated to use by this library alone.\n     * @param {number} x - the x position at which to render the SDF.\n     * @param {number} y - the y position at which to render the SDF.\n     * @param {number} channel - the color channel index (0-4) into which the SDF will be rendered.\n     * @return {Uint8Array}\n     */\n    function generateIntoCanvas(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n      if (maxDistance === void 0) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n      if (sdfExponent === void 0) sdfExponent = 1;\n      if (x === void 0) x = 0;\n      if (y === void 0) y = 0;\n      if (channel === void 0) channel = 0;\n      try {\n        return generateIntoCanvas$1.apply(webgl, arguments);\n      } catch (e) {\n        console.info('WebGL SDF generation failed, falling back to JS', e);\n        return generateIntoCanvas$2.apply(javascript, arguments);\n      }\n    }\n    exports.forEachPathCommand = forEachPathCommand;\n    exports.generate = generate;\n    exports.generateIntoCanvas = generateIntoCanvas;\n    exports.javascript = javascript;\n    exports.pathToLineSegments = pathToLineSegments;\n    exports.webgl = webgl;\n    exports.webglUtils = webglUtils;\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    return exports;\n  }({});\n  return exports;\n}\nexport { SDFGenerator as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}