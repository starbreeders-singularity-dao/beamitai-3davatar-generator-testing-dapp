{"ast":null,"code":"import { BufferAttribute, Box3, FrontSide } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG, SKIP_GENERATION } from './Constants.js';\nimport { buildPackedTree } from './build/buildTree.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\nimport { shapecast } from './cast/shapecast.js';\nimport { closestPointToPoint } from './cast/closestPointToPoint.js';\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\nimport { refit } from './cast/refit.generated.js';\nimport { raycast } from './cast/raycast.generated.js';\nimport { raycastFirst } from './cast/raycastFirst.generated.js';\nimport { intersectsGeometry } from './cast/intersectsGeometry.generated.js';\nimport { closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { bvhcast } from './cast/bvhcast.js';\nconst obb = /* @__PURE__ */new OrientedBox();\nconst tempBox = /* @__PURE__ */new Box3();\nexport const DEFAULT_OPTIONS = {\n  strategy: CENTER,\n  maxDepth: 40,\n  maxLeafTris: 10,\n  useSharedArrayBuffer: false,\n  setBoundingBox: true,\n  onProgress: null,\n  indirect: false,\n  verbose: true,\n  range: null\n};\nexport class MeshBVH {\n  static serialize(bvh, options = {}) {\n    options = {\n      cloneBuffers: true,\n      ...options\n    };\n    const geometry = bvh.geometry;\n    const rootData = bvh._roots;\n    const indirectBuffer = bvh._indirectBuffer;\n    const indexAttribute = geometry.getIndex();\n    let result;\n    if (options.cloneBuffers) {\n      result = {\n        roots: rootData.map(root => root.slice()),\n        index: indexAttribute ? indexAttribute.array.slice() : null,\n        indirectBuffer: indirectBuffer ? indirectBuffer.slice() : null\n      };\n    } else {\n      result = {\n        roots: rootData,\n        index: indexAttribute ? indexAttribute.array : null,\n        indirectBuffer: indirectBuffer\n      };\n    }\n    return result;\n  }\n  static deserialize(data, geometry, options = {}) {\n    options = {\n      setIndex: true,\n      indirect: Boolean(data.indirectBuffer),\n      ...options\n    };\n    const {\n      index,\n      roots,\n      indirectBuffer\n    } = data;\n    const bvh = new MeshBVH(geometry, {\n      ...options,\n      [SKIP_GENERATION]: true\n    });\n    bvh._roots = roots;\n    bvh._indirectBuffer = indirectBuffer || null;\n    if (options.setIndex) {\n      const indexAttribute = geometry.getIndex();\n      if (indexAttribute === null) {\n        const newIndex = new BufferAttribute(data.index, 1, false);\n        geometry.setIndex(newIndex);\n      } else if (indexAttribute.array !== index) {\n        indexAttribute.array.set(index);\n        indexAttribute.needsUpdate = true;\n      }\n    }\n    return bvh;\n  }\n  get indirect() {\n    return !!this._indirectBuffer;\n  }\n  constructor(geometry, options = {}) {\n    if (!geometry.isBufferGeometry) {\n      throw new Error('MeshBVH: Only BufferGeometries are supported.');\n    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {\n      throw new Error('MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.');\n    }\n\n    // default options\n    options = Object.assign({\n      ...DEFAULT_OPTIONS,\n      // undocumented options\n\n      // Whether to skip generating the tree. Used for deserialization.\n      [SKIP_GENERATION]: false\n    }, options);\n    if (options.useSharedArrayBuffer && !isSharedArrayBufferSupported()) {\n      throw new Error('MeshBVH: SharedArrayBuffer is not available.');\n    }\n\n    // retain references to the geometry so we can use them it without having to\n    // take a geometry reference in every function.\n    this.geometry = geometry;\n    this._roots = null;\n    this._indirectBuffer = null;\n    if (!options[SKIP_GENERATION]) {\n      buildPackedTree(this, options);\n      if (!geometry.boundingBox && options.setBoundingBox) {\n        geometry.boundingBox = this.getBoundingBox(new Box3());\n      }\n    }\n    this.resolveTriangleIndex = options.indirect ? i => this._indirectBuffer[i] : i => i;\n  }\n  refit(nodeIndices = null) {\n    const refitFunc = this.indirect ? refit_indirect : refit;\n    return refitFunc(this, nodeIndices);\n  }\n  traverse(callback, rootIndex = 0) {\n    const buffer = this._roots[rootIndex];\n    const uint32Array = new Uint32Array(buffer);\n    const uint16Array = new Uint16Array(buffer);\n    _traverse(0);\n    function _traverse(node32Index, depth = 0) {\n      const node16Index = node32Index * 2;\n      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n      if (isLeaf) {\n        const offset = uint32Array[node32Index + 6];\n        const count = uint16Array[node16Index + 14];\n        callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n      } else {\n        // TODO: use node functions here\n        const left = node32Index + BYTES_PER_NODE / 4;\n        const right = uint32Array[node32Index + 6];\n        const splitAxis = uint32Array[node32Index + 7];\n        const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n        if (!stopTraversal) {\n          _traverse(left, depth + 1);\n          _traverse(right, depth + 1);\n        }\n      }\n    }\n  }\n\n  /* Core Cast Functions */\n  raycast(ray, materialOrSide = FrontSide, near = 0, far = Infinity) {\n    const roots = this._roots;\n    const geometry = this.geometry;\n    const intersects = [];\n    const isMaterial = materialOrSide.isMaterial;\n    const isArrayMaterial = Array.isArray(materialOrSide);\n    const groups = geometry.groups;\n    const side = isMaterial ? materialOrSide.side : materialOrSide;\n    const raycastFunc = this.indirect ? raycast_indirect : raycast;\n    for (let i = 0, l = roots.length; i < l; i++) {\n      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n      const startCount = intersects.length;\n      raycastFunc(this, i, materialSide, ray, intersects, near, far);\n      if (isArrayMaterial) {\n        const materialIndex = groups[i].materialIndex;\n        for (let j = startCount, jl = intersects.length; j < jl; j++) {\n          intersects[j].face.materialIndex = materialIndex;\n        }\n      }\n    }\n    return intersects;\n  }\n  raycastFirst(ray, materialOrSide = FrontSide, near = 0, far = Infinity) {\n    const roots = this._roots;\n    const geometry = this.geometry;\n    const isMaterial = materialOrSide.isMaterial;\n    const isArrayMaterial = Array.isArray(materialOrSide);\n    let closestResult = null;\n    const groups = geometry.groups;\n    const side = isMaterial ? materialOrSide.side : materialOrSide;\n    const raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\n    for (let i = 0, l = roots.length; i < l; i++) {\n      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n      const result = raycastFirstFunc(this, i, materialSide, ray, near, far);\n      if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n        closestResult = result;\n        if (isArrayMaterial) {\n          result.face.materialIndex = groups[i].materialIndex;\n        }\n      }\n    }\n    return closestResult;\n  }\n  intersectsGeometry(otherGeometry, geomToMesh) {\n    let result = false;\n    const roots = this._roots;\n    const intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\n    for (let i = 0, l = roots.length; i < l; i++) {\n      result = intersectsGeometryFunc(this, i, otherGeometry, geomToMesh);\n      if (result) {\n        break;\n      }\n    }\n    return result;\n  }\n  shapecast(callbacks) {\n    const triangle = ExtendedTrianglePool.getPrimitive();\n    const iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\n    let {\n      boundsTraverseOrder,\n      intersectsBounds,\n      intersectsRange,\n      intersectsTriangle\n    } = callbacks;\n\n    // wrap the intersectsRange function\n    if (intersectsRange && intersectsTriangle) {\n      const originalIntersectsRange = intersectsRange;\n      intersectsRange = (offset, count, contained, depth, nodeIndex) => {\n        if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {\n          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle);\n        }\n        return true;\n      };\n    } else if (!intersectsRange) {\n      if (intersectsTriangle) {\n        intersectsRange = (offset, count, contained, depth) => {\n          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle);\n        };\n      } else {\n        intersectsRange = (offset, count, contained) => {\n          return contained;\n        };\n      }\n    }\n\n    // run shapecast\n    let result = false;\n    let byteOffset = 0;\n    const roots = this._roots;\n    for (let i = 0, l = roots.length; i < l; i++) {\n      const root = roots[i];\n      result = shapecast(this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n      if (result) {\n        break;\n      }\n      byteOffset += root.byteLength;\n    }\n    ExtendedTrianglePool.releasePrimitive(triangle);\n    return result;\n  }\n  bvhcast(otherBvh, matrixToLocal, callbacks) {\n    let {\n      intersectsRanges,\n      intersectsTriangles\n    } = callbacks;\n    const triangle1 = ExtendedTrianglePool.getPrimitive();\n    const indexAttr1 = this.geometry.index;\n    const positionAttr1 = this.geometry.attributes.position;\n    const assignTriangle1 = this.indirect ? i1 => {\n      const ti = this.resolveTriangleIndex(i1);\n      setTriangle(triangle1, ti * 3, indexAttr1, positionAttr1);\n    } : i1 => {\n      setTriangle(triangle1, i1 * 3, indexAttr1, positionAttr1);\n    };\n    const triangle2 = ExtendedTrianglePool.getPrimitive();\n    const indexAttr2 = otherBvh.geometry.index;\n    const positionAttr2 = otherBvh.geometry.attributes.position;\n    const assignTriangle2 = otherBvh.indirect ? i2 => {\n      const ti2 = otherBvh.resolveTriangleIndex(i2);\n      setTriangle(triangle2, ti2 * 3, indexAttr2, positionAttr2);\n    } : i2 => {\n      setTriangle(triangle2, i2 * 3, indexAttr2, positionAttr2);\n    };\n\n    // generate triangle callback if needed\n    if (intersectsTriangles) {\n      const iterateOverDoubleTriangles = (offset1, count1, offset2, count2, depth1, index1, depth2, index2) => {\n        for (let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {\n          assignTriangle2(i2);\n          triangle2.a.applyMatrix4(matrixToLocal);\n          triangle2.b.applyMatrix4(matrixToLocal);\n          triangle2.c.applyMatrix4(matrixToLocal);\n          triangle2.needsUpdate = true;\n          for (let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {\n            assignTriangle1(i1);\n            triangle1.needsUpdate = true;\n            if (intersectsTriangles(triangle1, triangle2, i1, i2, depth1, index1, depth2, index2)) {\n              return true;\n            }\n          }\n        }\n        return false;\n      };\n      if (intersectsRanges) {\n        const originalIntersectsRanges = intersectsRanges;\n        intersectsRanges = function (offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n          if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {\n            return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);\n          }\n          return true;\n        };\n      } else {\n        intersectsRanges = iterateOverDoubleTriangles;\n      }\n    }\n    return bvhcast(this, otherBvh, matrixToLocal, intersectsRanges);\n  }\n\n  /* Derived Cast Functions */\n  intersectsBox(box, boxToMesh) {\n    obb.set(box.min, box.max, boxToMesh);\n    obb.needsUpdate = true;\n    return this.shapecast({\n      intersectsBounds: box => obb.intersectsBox(box),\n      intersectsTriangle: tri => obb.intersectsTriangle(tri)\n    });\n  }\n  intersectsSphere(sphere) {\n    return this.shapecast({\n      intersectsBounds: box => sphere.intersectsBox(box),\n      intersectsTriangle: tri => tri.intersectsSphere(sphere)\n    });\n  }\n  closestPointToGeometry(otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {\n    const closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\n    return closestPointToGeometryFunc(this, otherGeometry, geometryToBvh, target1, target2, minThreshold, maxThreshold);\n  }\n  closestPointToPoint(point, target = {}, minThreshold = 0, maxThreshold = Infinity) {\n    return closestPointToPoint(this, point, target, minThreshold, maxThreshold);\n  }\n  getBoundingBox(target) {\n    target.makeEmpty();\n    const roots = this._roots;\n    roots.forEach(buffer => {\n      arrayToBox(0, new Float32Array(buffer), tempBox);\n      target.union(tempBox);\n    });\n    return target;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}