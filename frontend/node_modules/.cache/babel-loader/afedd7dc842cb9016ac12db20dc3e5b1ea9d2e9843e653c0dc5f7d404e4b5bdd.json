{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { RLP } from '@ethereumjs/rlp';\nimport { InvalidAddressError, InvalidMethodParamsError, InvalidNumberError, Web3ContractError } from 'web3-errors';\nimport { isNullish, mergeDeep, isContractInitOptions, keccak256, toChecksumAddress, hexToNumber } from 'web3-utils';\nimport { isAddress, isHexString } from 'web3-validator';\nimport { encodeMethodABI } from './encoding.js';\nconst dataInputEncodeMethodHelper = (txParams, abi, params, dataInputFill) => {\n  var _a, _b;\n  const tx = {};\n  if (!isNullish(txParams.data) || dataInputFill === 'both') {\n    tx.data = encodeMethodABI(abi, params, (_a = txParams.data) !== null && _a !== void 0 ? _a : txParams.input);\n  }\n  if (!isNullish(txParams.input) || dataInputFill === 'both') {\n    tx.input = encodeMethodABI(abi, params, (_b = txParams.input) !== null && _b !== void 0 ? _b : txParams.data);\n  }\n  // if input and data is empty, use web3config default\n  if (isNullish(tx.input) && isNullish(tx.data)) {\n    tx[dataInputFill] = encodeMethodABI(abi, params);\n  }\n  return {\n    data: tx.data,\n    input: tx.input\n  };\n};\nexport const getSendTxParams = ({\n  abi,\n  params,\n  options,\n  contractOptions\n}) => {\n  var _a, _b, _c;\n  const deploymentCall = (_c = (_b = (_a = options === null || options === void 0 ? void 0 : options.input) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : contractOptions.input) !== null && _c !== void 0 ? _c : contractOptions.data;\n  if (!deploymentCall && !(options === null || options === void 0 ? void 0 : options.to) && !contractOptions.address) {\n    throw new Web3ContractError('Contract address not specified');\n  }\n  if (!(options === null || options === void 0 ? void 0 : options.from) && !contractOptions.from) {\n    throw new Web3ContractError('Contract \"from\" address not specified');\n  }\n  let txParams = mergeDeep({\n    to: contractOptions.address,\n    gas: contractOptions.gas,\n    gasPrice: contractOptions.gasPrice,\n    from: contractOptions.from,\n    input: contractOptions.input,\n    maxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,\n    maxFeePerGas: contractOptions.maxFeePerGas,\n    data: contractOptions.data\n  }, options);\n  const dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options === null || options === void 0 ? void 0 : options.dataInputFill);\n  txParams = Object.assign(Object.assign({}, txParams), {\n    data: dataInput.data,\n    input: dataInput.input\n  });\n  return txParams;\n};\nexport const getEthTxCallParams = ({\n  abi,\n  params,\n  options,\n  contractOptions\n}) => {\n  if (!(options === null || options === void 0 ? void 0 : options.to) && !contractOptions.address) {\n    throw new Web3ContractError('Contract address not specified');\n  }\n  let txParams = mergeDeep({\n    to: contractOptions.address,\n    gas: contractOptions.gas,\n    gasPrice: contractOptions.gasPrice,\n    from: contractOptions.from,\n    input: contractOptions.input,\n    maxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,\n    maxFeePerGas: contractOptions.maxFeePerGas,\n    data: contractOptions.data\n  }, options);\n  const dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options === null || options === void 0 ? void 0 : options.dataInputFill);\n  txParams = Object.assign(Object.assign({}, txParams), {\n    data: dataInput.data,\n    input: dataInput.input\n  });\n  return txParams;\n};\nexport const getEstimateGasParams = ({\n  abi,\n  params,\n  options,\n  contractOptions\n}) => {\n  let txParams = mergeDeep({\n    to: contractOptions.address,\n    gas: contractOptions.gas,\n    gasPrice: contractOptions.gasPrice,\n    from: contractOptions.from,\n    input: contractOptions.input,\n    data: contractOptions.data\n  }, options);\n  const dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options === null || options === void 0 ? void 0 : options.dataInputFill);\n  txParams = Object.assign(Object.assign({}, txParams), {\n    data: dataInput.data,\n    input: dataInput.input\n  });\n  return txParams;\n};\nexport const isWeb3ContractContext = options => typeof options === 'object' && !isNullish(options) && Object.keys(options).length !== 0 && !isContractInitOptions(options);\nexport const getCreateAccessListParams = ({\n  abi,\n  params,\n  options,\n  contractOptions\n}) => {\n  if (!(options === null || options === void 0 ? void 0 : options.to) && !contractOptions.address) {\n    throw new Web3ContractError('Contract address not specified');\n  }\n  if (!(options === null || options === void 0 ? void 0 : options.from) && !contractOptions.from) {\n    throw new Web3ContractError('Contract \"from\" address not specified');\n  }\n  let txParams = mergeDeep({\n    to: contractOptions.address,\n    gas: contractOptions.gas,\n    gasPrice: contractOptions.gasPrice,\n    from: contractOptions.from,\n    input: contractOptions.input,\n    maxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,\n    maxFeePerGas: contractOptions.maxFeePerGas,\n    data: contractOptions.data\n  }, options);\n  const dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options === null || options === void 0 ? void 0 : options.dataInputFill);\n  txParams = Object.assign(Object.assign({}, txParams), {\n    data: dataInput.data,\n    input: dataInput.input\n  });\n  return txParams;\n};\nexport const createContractAddress = (from, nonce) => {\n  if (!isAddress(from)) throw new InvalidAddressError(`Invalid address given ${from}`);\n  let nonceValue = nonce;\n  if (typeof nonce === 'string' && isHexString(nonce)) nonceValue = hexToNumber(nonce);else if (typeof nonce === 'string' && !isHexString(nonce)) throw new InvalidNumberError('Invalid nonce value format');\n  const rlpEncoded = RLP.encode([from, nonceValue]);\n  const result = keccak256(rlpEncoded);\n  const contractAddress = '0x'.concat(result.substring(26));\n  return toChecksumAddress(contractAddress);\n};\nexport const create2ContractAddress = (from, salt, initCode) => {\n  if (!isAddress(from)) throw new InvalidAddressError(`Invalid address given ${from}`);\n  if (!isHexString(salt)) throw new InvalidMethodParamsError(`Invalid salt value ${salt}`);\n  if (!isHexString(initCode)) throw new InvalidMethodParamsError(`Invalid initCode value ${initCode}`);\n  const initCodeHash = keccak256(initCode);\n  const initCodeHashPadded = initCodeHash.padStart(64, '0'); // Pad to 32 bytes (64 hex characters)\n  const create2Params = ['0xff', from, salt, initCodeHashPadded].map(x => x.replace(/0x/, ''));\n  const create2Address = `0x${create2Params.join('')}`;\n  return toChecksumAddress(`0x${keccak256(create2Address).slice(26)}`); // Slice to get the last 20 bytes (40 hex characters) & checksum\n};\n//# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}