{"ast":null,"code":"/**\n * NFT.Storage Upload Handler\n * Using hardcoded collection ID for consistency\n */\n\nconst NFT_STORAGE_KEY = process.env.REACT_APP_NFT_STORAGE_KEY;\nconst API_BASE = 'https://preserve.nft.storage/api/v1';\nconst COLLECTION_ID = \"1\"; // Hardcoded collection ID\n\n// Debug API key\nconsole.log('API Key check:', {\n  exists: !!NFT_STORAGE_KEY,\n  length: NFT_STORAGE_KEY === null || NFT_STORAGE_KEY === void 0 ? void 0 : NFT_STORAGE_KEY.length,\n  firstChars: (NFT_STORAGE_KEY === null || NFT_STORAGE_KEY === void 0 ? void 0 : NFT_STORAGE_KEY.substring(0, 5)) + '...'\n});\n\n// Validate API key\nif (!(NFT_STORAGE_KEY !== null && NFT_STORAGE_KEY !== void 0 && NFT_STORAGE_KEY.trim())) {\n  throw new Error('NFT Storage API key is required');\n}\n\n/**\n * Validates API access\n */\nconst validateApiAccess = async () => {\n  try {\n    const response = await fetch(`${API_BASE}/collection/list_collections`, {\n      headers: {\n        'Authorization': `Bearer ${NFT_STORAGE_KEY.trim()}`\n      }\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      console.error('API validation failed:', error);\n      return false;\n    }\n    const data = await response.json();\n    console.log('Collections available:', data);\n    return true;\n  } catch (error) {\n    console.error('API validation error:', error);\n    return false;\n  }\n};\n\n/**\n * Uploads content to IPFS via NFT.Storage\n */\nexport const uploadToIPFS = async (glbUrl, originalNFT) => {\n  try {\n    console.log('Starting upload process...');\n\n    // Validate API access first\n    const isValid = await validateApiAccess();\n    if (!isValid) {\n      throw new Error('Failed to validate API access. Check your API key.');\n    }\n    console.log('Using collection ID:', COLLECTION_ID);\n\n    // Fetch GLB\n    const glbResponse = await fetch(glbUrl);\n    if (!glbResponse.ok) {\n      throw new Error(`Failed to fetch GLB: ${glbResponse.status}`);\n    }\n    const glbBlob = await glbResponse.blob();\n    console.log('GLB file fetched:', {\n      size: glbBlob.size,\n      type: glbBlob.type\n    });\n\n    // Create CSV content\n    const tokenId = Date.now().toString();\n    const csvContent = `tokenID,cid\\n${tokenId},pending_${tokenId}`;\n\n    // Prepare upload\n    const formData = new FormData();\n    formData.append('collectionID', COLLECTION_ID);\n    formData.append('file', new Blob([csvContent], {\n      type: 'text/csv'\n    }), 'token.csv');\n    console.log('Uploading to collection with:', {\n      collectionId: COLLECTION_ID,\n      tokenId: tokenId,\n      apiKeyLength: NFT_STORAGE_KEY.length\n    });\n\n    // Upload to NFT.Storage\n    const uploadResponse = await fetch(`${API_BASE}/collection/add_tokens`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${NFT_STORAGE_KEY.trim()}`,\n        'Accept': 'application/json'\n      },\n      body: formData\n    });\n    if (!uploadResponse.ok) {\n      const error = await uploadResponse.json();\n      console.error('Upload failed:', {\n        status: uploadResponse.status,\n        headers: Object.fromEntries(uploadResponse.headers),\n        error\n      });\n      throw new Error(`Upload failed: ${JSON.stringify(error)}`);\n    }\n    const result = await uploadResponse.json();\n    console.log('Upload successful:', result);\n    return `ipfs://${result.cid || tokenId}`;\n  } catch (error) {\n    console.error('Upload process failed:', {\n      name: error.name,\n      message: error.message,\n      stack: error.stack\n    });\n    throw error;\n  }\n};","map":{"version":3,"names":["NFT_STORAGE_KEY","process","env","REACT_APP_NFT_STORAGE_KEY","API_BASE","COLLECTION_ID","console","log","exists","length","firstChars","substring","trim","Error","validateApiAccess","response","fetch","headers","ok","error","json","data","uploadToIPFS","glbUrl","originalNFT","isValid","glbResponse","status","glbBlob","blob","size","type","tokenId","Date","now","toString","csvContent","formData","FormData","append","Blob","collectionId","apiKeyLength","uploadResponse","method","body","Object","fromEntries","JSON","stringify","result","cid","name","message","stack"],"sources":["/Users/thomasheindl/Documents/beamitai01/beamitai/frontend/src/utils/ipfsHandler.js"],"sourcesContent":["/**\n * NFT.Storage Upload Handler\n * Using hardcoded collection ID for consistency\n */\n\nconst NFT_STORAGE_KEY = process.env.REACT_APP_NFT_STORAGE_KEY;\nconst API_BASE = 'https://preserve.nft.storage/api/v1';\nconst COLLECTION_ID = \"1\";  // Hardcoded collection ID\n\n// Debug API key\nconsole.log('API Key check:', {\n    exists: !!NFT_STORAGE_KEY,\n    length: NFT_STORAGE_KEY?.length,\n    firstChars: NFT_STORAGE_KEY?.substring(0, 5) + '...'\n});\n\n// Validate API key\nif (!NFT_STORAGE_KEY?.trim()) {\n    throw new Error('NFT Storage API key is required');\n}\n\n/**\n * Validates API access\n */\nconst validateApiAccess = async () => {\n    try {\n        const response = await fetch(`${API_BASE}/collection/list_collections`, {\n            headers: {\n                'Authorization': `Bearer ${NFT_STORAGE_KEY.trim()}`\n            }\n        });\n        \n        if (!response.ok) {\n            const error = await response.json();\n            console.error('API validation failed:', error);\n            return false;\n        }\n        \n        const data = await response.json();\n        console.log('Collections available:', data);\n        return true;\n    } catch (error) {\n        console.error('API validation error:', error);\n        return false;\n    }\n};\n\n/**\n * Uploads content to IPFS via NFT.Storage\n */\nexport const uploadToIPFS = async (glbUrl, originalNFT) => {\n    try {\n        console.log('Starting upload process...');\n        \n        // Validate API access first\n        const isValid = await validateApiAccess();\n        if (!isValid) {\n            throw new Error('Failed to validate API access. Check your API key.');\n        }\n\n        console.log('Using collection ID:', COLLECTION_ID);\n\n        // Fetch GLB\n        const glbResponse = await fetch(glbUrl);\n        if (!glbResponse.ok) {\n            throw new Error(`Failed to fetch GLB: ${glbResponse.status}`);\n        }\n        \n        const glbBlob = await glbResponse.blob();\n        console.log('GLB file fetched:', {\n            size: glbBlob.size,\n            type: glbBlob.type\n        });\n\n        // Create CSV content\n        const tokenId = Date.now().toString();\n        const csvContent = `tokenID,cid\\n${tokenId},pending_${tokenId}`;\n        \n        // Prepare upload\n        const formData = new FormData();\n        formData.append('collectionID', COLLECTION_ID);\n        formData.append('file', new Blob([csvContent], { type: 'text/csv' }), 'token.csv');\n\n        console.log('Uploading to collection with:', {\n            collectionId: COLLECTION_ID,\n            tokenId: tokenId,\n            apiKeyLength: NFT_STORAGE_KEY.length\n        });\n\n        // Upload to NFT.Storage\n        const uploadResponse = await fetch(`${API_BASE}/collection/add_tokens`, {\n            method: 'POST',\n            headers: {\n                'Authorization': `Bearer ${NFT_STORAGE_KEY.trim()}`,\n                'Accept': 'application/json'\n            },\n            body: formData\n        });\n\n        if (!uploadResponse.ok) {\n            const error = await uploadResponse.json();\n            console.error('Upload failed:', {\n                status: uploadResponse.status,\n                headers: Object.fromEntries(uploadResponse.headers),\n                error\n            });\n            throw new Error(`Upload failed: ${JSON.stringify(error)}`);\n        }\n\n        const result = await uploadResponse.json();\n        console.log('Upload successful:', result);\n\n        return `ipfs://${result.cid || tokenId}`;\n\n    } catch (error) {\n        console.error('Upload process failed:', {\n            name: error.name,\n            message: error.message,\n            stack: error.stack\n        });\n        throw error;\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}