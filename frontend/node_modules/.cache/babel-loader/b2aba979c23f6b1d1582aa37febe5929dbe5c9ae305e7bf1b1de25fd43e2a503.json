{"ast":null,"code":"import { Loader, FileLoader, DataTexture, RGBAFormat, UnsignedByteType, LinearFilter, ClampToEdgeWrapping } from \"three\";\nimport { Data3DTexture } from \"../_polyfill/Data3DTexture.js\";\nclass LUT3dlLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"text\");\n    loader.load(url, text => {\n      try {\n        onLoad(this.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        this.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(str) {\n    str = str.replace(/^#.*?(\\n|\\r)/gm, \"\").replace(/^\\s*?(\\n|\\r)/gm, \"\").trim();\n    const lines = str.split(/[\\n\\r]+/g);\n    const gridLines = lines[0].trim().split(/\\s+/g).map(e => parseFloat(e));\n    const gridStep = gridLines[1] - gridLines[0];\n    const size = gridLines.length;\n    for (let i = 1, l = gridLines.length; i < l; i++) {\n      if (gridStep !== gridLines[i] - gridLines[i - 1]) {\n        throw new Error(\"LUT3dlLoader: Inconsistent grid size not supported.\");\n      }\n    }\n    const dataArray = new Array(size * size * size * 4);\n    let index = 0;\n    let maxOutputValue = 0;\n    for (let i = 1, l = lines.length; i < l; i++) {\n      const line = lines[i].trim();\n      const split = line.split(/\\s/g);\n      const r = parseFloat(split[0]);\n      const g = parseFloat(split[1]);\n      const b = parseFloat(split[2]);\n      maxOutputValue = Math.max(maxOutputValue, r, g, b);\n      const bLayer = index % size;\n      const gLayer = Math.floor(index / size) % size;\n      const rLayer = Math.floor(index / (size * size)) % size;\n      const pixelIndex = bLayer * size * size + gLayer * size + rLayer;\n      dataArray[4 * pixelIndex + 0] = r;\n      dataArray[4 * pixelIndex + 1] = g;\n      dataArray[4 * pixelIndex + 2] = b;\n      dataArray[4 * pixelIndex + 3] = 1;\n      index += 1;\n    }\n    const bits = Math.ceil(Math.log2(maxOutputValue));\n    const maxBitValue = Math.pow(2, bits);\n    for (let i = 0, l = dataArray.length; i < l; i += 4) {\n      const r = dataArray[i + 0];\n      const g = dataArray[i + 1];\n      const b = dataArray[i + 2];\n      dataArray[i + 0] = 255 * r / maxBitValue;\n      dataArray[i + 1] = 255 * g / maxBitValue;\n      dataArray[i + 2] = 255 * b / maxBitValue;\n    }\n    const data = new Uint8Array(dataArray);\n    const texture = new DataTexture();\n    texture.image.data = data;\n    texture.image.width = size;\n    texture.image.height = size * size;\n    texture.format = RGBAFormat;\n    texture.type = UnsignedByteType;\n    texture.magFilter = LinearFilter;\n    texture.minFilter = LinearFilter;\n    texture.wrapS = ClampToEdgeWrapping;\n    texture.wrapT = ClampToEdgeWrapping;\n    texture.generateMipmaps = false;\n    texture.needsUpdate = true;\n    const texture3D = new Data3DTexture();\n    texture3D.image.data = data;\n    texture3D.image.width = size;\n    texture3D.image.height = size;\n    texture3D.image.depth = size;\n    texture3D.format = RGBAFormat;\n    texture3D.type = UnsignedByteType;\n    texture3D.magFilter = LinearFilter;\n    texture3D.minFilter = LinearFilter;\n    texture3D.wrapS = ClampToEdgeWrapping;\n    texture3D.wrapT = ClampToEdgeWrapping;\n    texture3D.wrapR = ClampToEdgeWrapping;\n    texture3D.generateMipmaps = false;\n    texture3D.needsUpdate = true;\n    return {\n      size,\n      texture,\n      texture3D\n    };\n  }\n}\nexport { LUT3dlLoader };\n//# sourceMappingURL=LUT3dlLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}