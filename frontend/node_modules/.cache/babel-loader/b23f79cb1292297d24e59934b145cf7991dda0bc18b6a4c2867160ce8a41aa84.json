{"ast":null,"code":"import { BYTES_PER_NODE, IS_LEAFNODE_FLAG } from '../Constants.js';\nimport { IS_LEAF } from '../utils/nodeBufferUtils.js';\nlet float32Array, uint32Array, uint16Array, uint8Array;\nconst MAX_POINTER = Math.pow(2, 32);\nexport function countNodes(node) {\n  if ('count' in node) {\n    return 1;\n  } else {\n    return 1 + countNodes(node.left) + countNodes(node.right);\n  }\n}\nexport function populateBuffer(byteOffset, node, buffer) {\n  float32Array = new Float32Array(buffer);\n  uint32Array = new Uint32Array(buffer);\n  uint16Array = new Uint16Array(buffer);\n  uint8Array = new Uint8Array(buffer);\n  return _populateBuffer(byteOffset, node);\n}\n\n// pack structure\n// boundingData  \t\t\t\t: 6 float32\n// right / offset \t\t\t\t: 1 uint32\n// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\nfunction _populateBuffer(byteOffset, node) {\n  const stride4Offset = byteOffset / 4;\n  const stride2Offset = byteOffset / 2;\n  const isLeaf = 'count' in node;\n  const boundingData = node.boundingData;\n  for (let i = 0; i < 6; i++) {\n    float32Array[stride4Offset + i] = boundingData[i];\n  }\n  if (isLeaf) {\n    if (node.buffer) {\n      const buffer = node.buffer;\n      uint8Array.set(new Uint8Array(buffer), byteOffset);\n      for (let offset = byteOffset, l = byteOffset + buffer.byteLength; offset < l; offset += BYTES_PER_NODE) {\n        const offset2 = offset / 2;\n        if (!IS_LEAF(offset2, uint16Array)) {\n          uint32Array[offset / 4 + 6] += stride4Offset;\n        }\n      }\n      return byteOffset + buffer.byteLength;\n    } else {\n      const offset = node.offset;\n      const count = node.count;\n      uint32Array[stride4Offset + 6] = offset;\n      uint16Array[stride2Offset + 14] = count;\n      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG;\n      return byteOffset + BYTES_PER_NODE;\n    }\n  } else {\n    const left = node.left;\n    const right = node.right;\n    const splitAxis = node.splitAxis;\n    let nextUnusedPointer;\n    nextUnusedPointer = _populateBuffer(byteOffset + BYTES_PER_NODE, left);\n    if (nextUnusedPointer / 4 > MAX_POINTER) {\n      throw new Error('MeshBVH: Cannot store child pointer greater than 32 bits.');\n    }\n    uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;\n    nextUnusedPointer = _populateBuffer(nextUnusedPointer, right);\n    uint32Array[stride4Offset + 7] = splitAxis;\n    return nextUnusedPointer;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}