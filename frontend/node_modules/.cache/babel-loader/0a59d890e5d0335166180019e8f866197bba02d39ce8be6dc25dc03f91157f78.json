{"ast":null,"code":"import { Loader, FileLoader, LineBasicMaterial, Group, Euler, BufferGeometry, Float32BufferAttribute, LineSegments } from \"three\";\nclass GCodeLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.splitLayer = false;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(data) {\n    let state = {\n      x: 0,\n      y: 0,\n      z: 0,\n      e: 0,\n      f: 0,\n      extruding: false,\n      relative: false\n    };\n    let layers = [];\n    let currentLayer = void 0;\n    const pathMaterial = new LineBasicMaterial({\n      color: 16711680\n    });\n    pathMaterial.name = \"path\";\n    const extrudingMaterial = new LineBasicMaterial({\n      color: 65280\n    });\n    extrudingMaterial.name = \"extruded\";\n    function newLayer(line) {\n      currentLayer = {\n        vertex: [],\n        pathVertex: [],\n        z: line.z\n      };\n      layers.push(currentLayer);\n    }\n    function addSegment(p1, p2) {\n      if (currentLayer === void 0) {\n        newLayer(p1);\n      }\n      if (state.extruding) {\n        currentLayer.vertex.push(p1.x, p1.y, p1.z);\n        currentLayer.vertex.push(p2.x, p2.y, p2.z);\n      } else {\n        currentLayer.pathVertex.push(p1.x, p1.y, p1.z);\n        currentLayer.pathVertex.push(p2.x, p2.y, p2.z);\n      }\n    }\n    function delta(v1, v2) {\n      return state.relative ? v2 : v2 - v1;\n    }\n    function absolute(v1, v2) {\n      return state.relative ? v1 + v2 : v2;\n    }\n    let lines = data.replace(/;.+/g, \"\").split(\"\\n\");\n    for (let i = 0; i < lines.length; i++) {\n      let tokens = lines[i].split(\" \");\n      let cmd = tokens[0].toUpperCase();\n      let args = {};\n      tokens.splice(1).forEach(function (token) {\n        if (token[0] !== void 0) {\n          let key = token[0].toLowerCase();\n          let value = parseFloat(token.substring(1));\n          args[key] = value;\n        }\n      });\n      if (cmd === \"G0\" || cmd === \"G1\") {\n        let line = {\n          x: args.x !== void 0 ? absolute(state.x, args.x) : state.x,\n          y: args.y !== void 0 ? absolute(state.y, args.y) : state.y,\n          z: args.z !== void 0 ? absolute(state.z, args.z) : state.z,\n          e: args.e !== void 0 ? absolute(state.e, args.e) : state.e,\n          f: args.f !== void 0 ? absolute(state.f, args.f) : state.f\n        };\n        if (delta(state.e, line.e) > 0) {\n          line.extruding = delta(state.e, line.e) > 0;\n          if (currentLayer == void 0 || line.z != currentLayer.z) {\n            newLayer(line);\n          }\n        }\n        addSegment(state, line);\n        state = line;\n      } else if (cmd === \"G2\" || cmd === \"G3\") ;else if (cmd === \"G90\") {\n        state.relative = false;\n      } else if (cmd === \"G91\") {\n        state.relative = true;\n      } else if (cmd === \"G92\") {\n        let line = state;\n        line.x = args.x !== void 0 ? args.x : line.x;\n        line.y = args.y !== void 0 ? args.y : line.y;\n        line.z = args.z !== void 0 ? args.z : line.z;\n        line.e = args.e !== void 0 ? args.e : line.e;\n        state = line;\n      } else ;\n    }\n    function addObject(vertex, extruding, i) {\n      let geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(vertex, 3));\n      let segments = new LineSegments(geometry, extruding ? extrudingMaterial : pathMaterial);\n      segments.name = \"layer\" + i;\n      object.add(segments);\n    }\n    const object = new Group();\n    object.name = \"gcode\";\n    if (this.splitLayer) {\n      for (let i = 0; i < layers.length; i++) {\n        let layer = layers[i];\n        addObject(layer.vertex, true, i);\n        addObject(layer.pathVertex, false, i);\n      }\n    } else {\n      const vertex = [],\n        pathVertex = [];\n      for (let i = 0; i < layers.length; i++) {\n        let layer = layers[i];\n        let layerVertex = layer.vertex;\n        let layerPathVertex = layer.pathVertex;\n        for (let j = 0; j < layerVertex.length; j++) {\n          vertex.push(layerVertex[j]);\n        }\n        for (let j = 0; j < layerPathVertex.length; j++) {\n          pathVertex.push(layerPathVertex[j]);\n        }\n      }\n      addObject(vertex, true, layers.length);\n      addObject(pathVertex, false, layers.length);\n    }\n    object.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n    return object;\n  }\n}\nexport { GCodeLoader };\n//# sourceMappingURL=GCodeLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}