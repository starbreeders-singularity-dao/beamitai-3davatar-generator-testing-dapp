{"ast":null,"code":"/* @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BackSide, Box3, Mesh, MeshBasicMaterial, MeshDepthMaterial, Object3D, OrthographicCamera, PlaneGeometry, RGBAFormat, ShaderMaterial, Vector3, WebGLRenderTarget } from 'three';\nimport { HorizontalBlurShader } from 'three/examples/jsm/shaders/HorizontalBlurShader.js';\nimport { VerticalBlurShader } from 'three/examples/jsm/shaders/VerticalBlurShader.js';\nimport { lerp } from 'three/src/math/MathUtils.js';\n// The softness [0, 1] of the shadow is mapped to a resolution between\n// 2^LOG_MAX_RESOLUTION and 2^LOG_MIN_RESOLUTION.\nconst LOG_MAX_RESOLUTION = 9;\nconst LOG_MIN_RESOLUTION = 6;\n// Animated models are not in general contained in their bounding box, as this\n// is calculated only for their resting pose. We create a cubic shadow volume\n// for animated models sized to their largest bounding box dimension multiplied\n// by this scale factor.\nconst ANIMATION_SCALING = 2;\n// Since hard shadows are not lightened by blurring and depth, set a lower\n// default intensity to make them more perceptually similar to the intensity of\n// the soft shadows.\nconst DEFAULT_HARD_INTENSITY = 0.3;\n/**\n * The Shadow class creates a shadow that fits a given scene and follows a\n * target. This shadow will follow the scene without any updates needed so long\n * as the shadow and scene are both parented to the same object (call it the\n * scene) and this scene is passed as the target parameter to the shadow's\n * constructor. We also must constrain the scene to motion within the horizontal\n * plane and call the setRotation() method whenever the scene's Y-axis rotation\n * changes. For motion outside of the horizontal plane, this.needsUpdate must be\n * set to true.\n *\n * The softness of the shadow is controlled by changing its resolution, making\n * softer shadows faster, but less precise.\n */\nexport class Shadow extends Object3D {\n  constructor(scene, softness, side) {\n    super();\n    this.camera = new OrthographicCamera();\n    // private cameraHelper = new CameraHelper(this.camera);\n    this.renderTarget = null;\n    this.renderTargetBlur = null;\n    this.depthMaterial = new MeshDepthMaterial();\n    this.horizontalBlurMaterial = new ShaderMaterial(HorizontalBlurShader);\n    this.verticalBlurMaterial = new ShaderMaterial(VerticalBlurShader);\n    this.intensity = 0;\n    this.softness = 1;\n    this.boundingBox = new Box3();\n    this.size = new Vector3();\n    this.maxDimension = 0;\n    this.isAnimated = false;\n    this.needsUpdate = false;\n    const {\n      camera\n    } = this;\n    camera.rotation.x = Math.PI / 2;\n    camera.left = -0.5;\n    camera.right = 0.5;\n    camera.bottom = -0.5;\n    camera.top = 0.5;\n    this.add(camera);\n    // this.add(this.cameraHelper);\n    // this.cameraHelper.updateMatrixWorld = function() {\n    //   this.matrixWorld = this.camera.matrixWorld;\n    // };\n    const plane = new PlaneGeometry();\n    const shadowMaterial = new MeshBasicMaterial({\n      // color: new Color(1, 0, 0),\n      opacity: 1,\n      transparent: true,\n      side: BackSide\n    });\n    this.floor = new Mesh(plane, shadowMaterial);\n    this.floor.userData.noHit = true;\n    camera.add(this.floor);\n    // the plane onto which to blur the texture\n    this.blurPlane = new Mesh(plane);\n    this.blurPlane.visible = false;\n    camera.add(this.blurPlane);\n    scene.target.add(this);\n    // like MeshDepthMaterial, but goes from black to transparent\n    this.depthMaterial.onBeforeCompile = function (shader) {\n      shader.fragmentShader = shader.fragmentShader.replace('gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );', 'gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * opacity );');\n    };\n    this.horizontalBlurMaterial.depthTest = false;\n    this.verticalBlurMaterial.depthTest = false;\n    this.setScene(scene, softness, side);\n  }\n  /**\n   * Update the shadow's size and position for a new scene. Softness is also\n   * needed, as this controls the shadow's resolution.\n   */\n  setScene(scene, softness, side) {\n    const {\n      boundingBox,\n      size,\n      rotation,\n      position\n    } = this;\n    this.isAnimated = scene.animationNames.length > 0;\n    this.boundingBox.copy(scene.boundingBox);\n    this.size.copy(scene.size);\n    this.maxDimension = Math.max(size.x, size.y, size.z) * (this.isAnimated ? ANIMATION_SCALING : 1);\n    this.boundingBox.getCenter(position);\n    if (side === 'back') {\n      const {\n        min,\n        max\n      } = boundingBox;\n      [min.y, min.z] = [min.z, min.y];\n      [max.y, max.z] = [max.z, max.y];\n      [size.y, size.z] = [size.z, size.y];\n      rotation.x = Math.PI / 2;\n      rotation.y = Math.PI;\n    } else {\n      rotation.x = 0;\n      rotation.y = 0;\n    }\n    if (this.isAnimated) {\n      const minY = boundingBox.min.y;\n      const maxY = boundingBox.max.y;\n      size.y = this.maxDimension;\n      boundingBox.expandByVector(size.subScalar(this.maxDimension).multiplyScalar(-0.5));\n      boundingBox.min.y = minY;\n      boundingBox.max.y = maxY;\n      size.set(this.maxDimension, maxY - minY, this.maxDimension);\n    }\n    if (side === 'bottom') {\n      position.y = boundingBox.min.y;\n    } else {\n      position.z = boundingBox.min.y;\n    }\n    this.setSoftness(softness);\n  }\n  /**\n   * Update the shadow's resolution based on softness (between 0 and 1). Should\n   * not be called frequently, as this results in reallocation.\n   */\n  setSoftness(softness) {\n    this.softness = softness;\n    const {\n      size,\n      camera\n    } = this;\n    const scaleY = this.isAnimated ? ANIMATION_SCALING : 1;\n    const resolution = scaleY * Math.pow(2, LOG_MAX_RESOLUTION - softness * (LOG_MAX_RESOLUTION - LOG_MIN_RESOLUTION));\n    this.setMapSize(resolution);\n    const softFar = size.y / 2;\n    const hardFar = size.y * scaleY;\n    camera.near = 0;\n    camera.far = lerp(hardFar, softFar, softness);\n    // we have co-opted opacity to scale the depth to clip\n    this.depthMaterial.opacity = 1.0 / softness;\n    camera.updateProjectionMatrix();\n    // this.cameraHelper.update();\n    this.setIntensity(this.intensity);\n    this.setOffset(0);\n  }\n  /**\n   * Lower-level version of the above function.\n   */\n  setMapSize(maxMapSize) {\n    const {\n      size\n    } = this;\n    if (this.isAnimated) {\n      maxMapSize *= ANIMATION_SCALING;\n    }\n    const baseWidth = Math.floor(size.x > size.z ? maxMapSize : maxMapSize * size.x / size.z);\n    const baseHeight = Math.floor(size.x > size.z ? maxMapSize * size.z / size.x : maxMapSize);\n    // width of blur filter in pixels (not adjustable)\n    const TAP_WIDTH = 10;\n    const width = TAP_WIDTH + baseWidth;\n    const height = TAP_WIDTH + baseHeight;\n    if (this.renderTarget != null && (this.renderTarget.width !== width || this.renderTarget.height !== height)) {\n      this.renderTarget.dispose();\n      this.renderTarget = null;\n      this.renderTargetBlur.dispose();\n      this.renderTargetBlur = null;\n    }\n    if (this.renderTarget == null) {\n      const params = {\n        format: RGBAFormat\n      };\n      this.renderTarget = new WebGLRenderTarget(width, height, params);\n      this.renderTargetBlur = new WebGLRenderTarget(width, height, params);\n      this.floor.material.map = this.renderTarget.texture;\n    }\n    // These pads account for the softening radius around the shadow.\n    this.camera.scale.set(size.x * (1 + TAP_WIDTH / baseWidth), size.z * (1 + TAP_WIDTH / baseHeight), 1);\n    this.needsUpdate = true;\n  }\n  /**\n   * Set the shadow's intensity (0 to 1), which is just its opacity. Turns off\n   * shadow rendering if zero.\n   */\n  setIntensity(intensity) {\n    this.intensity = intensity;\n    if (intensity > 0) {\n      this.visible = true;\n      this.floor.visible = true;\n      this.floor.material.opacity = intensity * lerp(DEFAULT_HARD_INTENSITY, 1, this.softness * this.softness);\n    } else {\n      this.visible = false;\n      this.floor.visible = false;\n    }\n  }\n  getIntensity() {\n    return this.intensity;\n  }\n  /**\n   * An offset can be specified to move the\n   * shadow vertically relative to the bottom of the scene. Positive is up, so\n   * values are generally negative. A small offset keeps our shadow from\n   * z-fighting with any baked-in shadow plane.\n   */\n  setOffset(offset) {\n    this.floor.position.z = -offset + this.gap();\n  }\n  gap() {\n    return 0.001 * this.maxDimension;\n  }\n  render(renderer, scene) {\n    // this.cameraHelper.visible = false;\n    // force the depthMaterial to everything\n    scene.overrideMaterial = this.depthMaterial;\n    // set renderer clear alpha\n    const initialClearAlpha = renderer.getClearAlpha();\n    renderer.setClearAlpha(0);\n    this.floor.visible = false;\n    // disable XR for offscreen rendering\n    const xrEnabled = renderer.xr.enabled;\n    renderer.xr.enabled = false;\n    // render to the render target to get the depths\n    const oldRenderTarget = renderer.getRenderTarget();\n    renderer.setRenderTarget(this.renderTarget);\n    renderer.render(scene, this.camera);\n    // and reset the override material\n    scene.overrideMaterial = null;\n    this.floor.visible = true;\n    this.blurShadow(renderer);\n    // reset and render the normal scene\n    renderer.xr.enabled = xrEnabled;\n    renderer.setRenderTarget(oldRenderTarget);\n    renderer.setClearAlpha(initialClearAlpha);\n    // this.cameraHelper.visible = true;\n  }\n  blurShadow(renderer) {\n    const {\n      camera,\n      horizontalBlurMaterial,\n      verticalBlurMaterial,\n      renderTarget,\n      renderTargetBlur,\n      blurPlane\n    } = this;\n    blurPlane.visible = true;\n    // blur horizontally and draw in the renderTargetBlur\n    blurPlane.material = horizontalBlurMaterial;\n    horizontalBlurMaterial.uniforms.h.value = 1 / this.renderTarget.width;\n    horizontalBlurMaterial.uniforms.tDiffuse.value = this.renderTarget.texture;\n    renderer.setRenderTarget(renderTargetBlur);\n    renderer.render(blurPlane, camera);\n    // blur vertically and draw in the main renderTarget\n    blurPlane.material = verticalBlurMaterial;\n    verticalBlurMaterial.uniforms.v.value = 1 / this.renderTarget.height;\n    verticalBlurMaterial.uniforms.tDiffuse.value = this.renderTargetBlur.texture;\n    renderer.setRenderTarget(renderTarget);\n    renderer.render(blurPlane, camera);\n    blurPlane.visible = false;\n  }\n  dispose() {\n    if (this.renderTarget != null) {\n      this.renderTarget.dispose();\n    }\n    if (this.renderTargetBlur != null) {\n      this.renderTargetBlur.dispose();\n    }\n    this.depthMaterial.dispose();\n    this.horizontalBlurMaterial.dispose();\n    this.verticalBlurMaterial.dispose();\n    this.floor.material.dispose();\n    this.floor.geometry.dispose();\n    this.blurPlane.geometry.dispose();\n    this.removeFromParent();\n  }\n}\n//# sourceMappingURL=Shadow.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}