{"ast":null,"code":"import { Color, MathUtils } from \"three\";\nclass Lut {\n  constructor(colormap, count = 32) {\n    this.isLut = true;\n    this.lut = [];\n    this.map = [];\n    this.n = 0;\n    this.minV = 0;\n    this.maxV = 1;\n    this.setColorMap(colormap, count);\n  }\n  set(value) {\n    if (value.isLut === true) {\n      this.copy(value);\n    }\n    return this;\n  }\n  setMin(min) {\n    this.minV = min;\n    return this;\n  }\n  setMax(max) {\n    this.maxV = max;\n    return this;\n  }\n  setColorMap(colormap, count = 32) {\n    this.map = ColorMapKeywords[colormap] || ColorMapKeywords.rainbow;\n    this.n = count;\n    const step = 1 / this.n;\n    const minColor = new Color();\n    const maxColor = new Color();\n    this.lut.length = 0;\n    this.lut.push(new Color(this.map[0][1]));\n    for (let i = 1; i < count; i++) {\n      const alpha = i * step;\n      for (let j = 0; j < this.map.length - 1; j++) {\n        if (alpha > this.map[j][0] && alpha <= this.map[j + 1][0]) {\n          const min = this.map[j][0];\n          const max = this.map[j + 1][0];\n          minColor.setHex(this.map[j][1], \"srgb-linear\");\n          maxColor.setHex(this.map[j + 1][1], \"srgb-linear\");\n          const color = new Color().lerpColors(minColor, maxColor, (alpha - min) / (max - min));\n          this.lut.push(color);\n        }\n      }\n    }\n    this.lut.push(new Color(this.map[this.map.length - 1][1]));\n    return this;\n  }\n  copy(lut) {\n    this.lut = lut.lut;\n    this.map = lut.map;\n    this.n = lut.n;\n    this.minV = lut.minV;\n    this.maxV = lut.maxV;\n    return this;\n  }\n  getColor(alpha) {\n    alpha = MathUtils.clamp(alpha, this.minV, this.maxV);\n    alpha = (alpha - this.minV) / (this.maxV - this.minV);\n    const colorPosition = Math.round(alpha * this.n);\n    return this.lut[colorPosition];\n  }\n  addColorMap(name, arrayOfColors) {\n    ColorMapKeywords[name] = arrayOfColors;\n    return this;\n  }\n  createCanvas() {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = 1;\n    canvas.height = this.n;\n    this.updateCanvas(canvas);\n    return canvas;\n  }\n  updateCanvas(canvas) {\n    const ctx = canvas.getContext(\"2d\", {\n      alpha: false\n    });\n    const imageData = ctx.getImageData(0, 0, 1, this.n);\n    const data = imageData.data;\n    let k = 0;\n    const step = 1 / this.n;\n    const minColor = new Color();\n    const maxColor = new Color();\n    const finalColor = new Color();\n    for (let i = 1; i >= 0; i -= step) {\n      for (let j = this.map.length - 1; j >= 0; j--) {\n        if (i < this.map[j][0] && i >= this.map[j - 1][0]) {\n          const min = this.map[j - 1][0];\n          const max = this.map[j][0];\n          minColor.setHex(this.map[j - 1][1], \"srgb-linear\");\n          maxColor.setHex(this.map[j][1], \"srgb-linear\");\n          finalColor.lerpColors(minColor, maxColor, (i - min) / (max - min));\n          data[k * 4] = Math.round(finalColor.r * 255);\n          data[k * 4 + 1] = Math.round(finalColor.g * 255);\n          data[k * 4 + 2] = Math.round(finalColor.b * 255);\n          data[k * 4 + 3] = 255;\n          k += 1;\n        }\n      }\n    }\n    ctx.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n}\nconst ColorMapKeywords = {\n  rainbow: [[0, 255], [0.2, 65535], [0.5, 65280], [0.8, 16776960], [1, 16711680]],\n  cooltowarm: [[0, 3952322], [0.2, 10206463], [0.5, 14474460], [0.8, 16163717], [1, 11797542]],\n  blackbody: [[0, 0], [0.2, 7864320], [0.5, 15086080], [0.8, 16776960], [1, 16777215]],\n  grayscale: [[0, 0], [0.2, 4210752], [0.5, 8355712], [0.8, 12566463], [1, 16777215]]\n};\nexport { ColorMapKeywords, Lut };\n//# sourceMappingURL=Lut.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}