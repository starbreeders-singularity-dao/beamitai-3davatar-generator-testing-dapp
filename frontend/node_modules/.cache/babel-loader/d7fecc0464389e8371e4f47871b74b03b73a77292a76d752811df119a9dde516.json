{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Loader, RGBAFormat, RGBA_ASTC_4x4_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, FileLoader, UnsignedByteType, CompressedTexture, LinearFilter, LinearMipmapLinearFilter, FloatType, HalfFloatType, DataTexture, RGFormat, RedFormat, RGBA_ASTC_6x6_Format } from \"three\";\nimport { WorkerPool } from \"../utils/WorkerPool.js\";\nimport { KHR_DF_FLAG_ALPHA_PREMULTIPLIED, read, VK_FORMAT_UNDEFINED, KHR_SUPERCOMPRESSION_ZSTD, KHR_SUPERCOMPRESSION_NONE, KHR_DF_PRIMARIES_BT709, KHR_DF_TRANSFER_SRGB, KHR_DF_PRIMARIES_DISPLAYP3, KHR_DF_PRIMARIES_UNSPECIFIED, VK_FORMAT_R32G32B32A32_SFLOAT, VK_FORMAT_R16G16B16A16_SFLOAT, VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_R8G8B8A8_SRGB, VK_FORMAT_R32G32_SFLOAT, VK_FORMAT_R16G16_SFLOAT, VK_FORMAT_R8G8_UNORM, VK_FORMAT_R8G8_SRGB, VK_FORMAT_R32_SFLOAT, VK_FORMAT_R16_SFLOAT, VK_FORMAT_R8_SRGB, VK_FORMAT_R8_UNORM, VK_FORMAT_ASTC_6x6_SRGB_BLOCK, VK_FORMAT_ASTC_6x6_UNORM_BLOCK } from \"../libs/ktx-parse.js\";\nimport { ZSTDDecoder } from \"../libs/zstddec.js\";\nimport { CompressedCubeTexture } from \"../_polyfill/CompressedCubeTexture.js\";\nimport { CompressedArrayTexture } from \"../_polyfill/CompressedArrayTexture.js\";\nimport { Data3DTexture } from \"../_polyfill/Data3DTexture.js\";\nconst LinearEncoding = 3e3;\nconst sRGBEncoding = 3001;\nconst NoColorSpace = \"\";\nconst DisplayP3ColorSpace = \"display-p3\";\nconst LinearDisplayP3ColorSpace = \"display-p3-linear\";\nconst LinearSRGBColorSpace = \"srgb-linear\";\nconst SRGBColorSpace = \"srgb\";\nconst _taskCache = /* @__PURE__ */new WeakMap();\nlet _activeLoaders = 0;\nlet _zstd;\nconst _KTX2Loader = class extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.transcoderPath = \"\";\n    this.transcoderBinary = null;\n    this.transcoderPending = null;\n    this.workerPool = new WorkerPool();\n    this.workerSourceURL = \"\";\n    this.workerConfig = null;\n    if (typeof MSC_TRANSCODER !== \"undefined\") {\n      console.warn('THREE.KTX2Loader: Please update to latest \"basis_transcoder\". \"msc_basis_transcoder\" is no longer supported in three.js r125+.');\n    }\n  }\n  setTranscoderPath(path) {\n    this.transcoderPath = path;\n    return this;\n  }\n  setWorkerLimit(num) {\n    this.workerPool.setWorkerLimit(num);\n    return this;\n  }\n  detectSupport(renderer) {\n    this.workerConfig = {\n      astcSupported: renderer.extensions.has(\"WEBGL_compressed_texture_astc\"),\n      etc1Supported: renderer.extensions.has(\"WEBGL_compressed_texture_etc1\"),\n      etc2Supported: renderer.extensions.has(\"WEBGL_compressed_texture_etc\"),\n      dxtSupported: renderer.extensions.has(\"WEBGL_compressed_texture_s3tc\"),\n      bptcSupported: renderer.extensions.has(\"EXT_texture_compression_bptc\"),\n      pvrtcSupported: renderer.extensions.has(\"WEBGL_compressed_texture_pvrtc\") || renderer.extensions.has(\"WEBKIT_WEBGL_compressed_texture_pvrtc\")\n    };\n    if (renderer.capabilities.isWebGL2) {\n      this.workerConfig.etc1Supported = false;\n    }\n    return this;\n  }\n  init() {\n    if (!this.transcoderPending) {\n      const jsLoader = new FileLoader(this.manager);\n      jsLoader.setPath(this.transcoderPath);\n      jsLoader.setWithCredentials(this.withCredentials);\n      const jsContent = jsLoader.loadAsync(\"basis_transcoder.js\");\n      const binaryLoader = new FileLoader(this.manager);\n      binaryLoader.setPath(this.transcoderPath);\n      binaryLoader.setResponseType(\"arraybuffer\");\n      binaryLoader.setWithCredentials(this.withCredentials);\n      const binaryContent = binaryLoader.loadAsync(\"basis_transcoder.wasm\");\n      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {\n        const fn = _KTX2Loader.BasisWorker.toString();\n        const body = [\"/* constants */\", \"let _EngineFormat = \" + JSON.stringify(_KTX2Loader.EngineFormat), \"let _TranscoderFormat = \" + JSON.stringify(_KTX2Loader.TranscoderFormat), \"let _BasisFormat = \" + JSON.stringify(_KTX2Loader.BasisFormat), \"/* basis_transcoder.js */\", jsContent2, \"/* worker */\", fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))].join(\"\\n\");\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n        this.transcoderBinary = binaryContent2;\n        this.workerPool.setWorkerCreator(() => {\n          const worker = new Worker(this.workerSourceURL);\n          const transcoderBinary = this.transcoderBinary.slice(0);\n          worker.postMessage({\n            type: \"init\",\n            config: this.workerConfig,\n            transcoderBinary\n          }, [transcoderBinary]);\n          return worker;\n        });\n      });\n      if (_activeLoaders > 0) {\n        console.warn(\"THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances.\");\n      }\n      _activeLoaders++;\n    }\n    return this.transcoderPending;\n  }\n  load(url, onLoad, onProgress, onError) {\n    if (this.workerConfig === null) {\n      throw new Error(\"THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.\");\n    }\n    const loader = new FileLoader(this.manager);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, buffer => {\n      if (_taskCache.has(buffer)) {\n        const cachedTask = _taskCache.get(buffer);\n        return cachedTask.promise.then(onLoad).catch(onError);\n      }\n      this._createTexture(buffer).then(texture => onLoad ? onLoad(texture) : null).catch(onError);\n    }, onProgress, onError);\n  }\n  _createTextureFrom(transcodeResult, container) {\n    const {\n      faces,\n      width,\n      height,\n      format,\n      type,\n      error,\n      dfdFlags\n    } = transcodeResult;\n    if (type === \"error\") return Promise.reject(error);\n    let texture;\n    if (container.faceCount === 6) {\n      texture = new CompressedCubeTexture(faces, format, UnsignedByteType);\n    } else {\n      const mipmaps = faces[0].mipmaps;\n      texture = container.layerCount > 1 ? new CompressedArrayTexture(mipmaps, width, height, container.layerCount, format, UnsignedByteType) : new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);\n    }\n    texture.minFilter = faces[0].mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;\n    texture.magFilter = LinearFilter;\n    texture.generateMipmaps = false;\n    texture.needsUpdate = true;\n    const colorSpace = parseColorSpace(container);\n    if (\"colorSpace\" in texture) texture.colorSpace = colorSpace;else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n    texture.premultiplyAlpha = !!(dfdFlags & KHR_DF_FLAG_ALPHA_PREMULTIPLIED);\n    return texture;\n  }\n  /**\n   * @param {ArrayBuffer} buffer\n   * @param {object?} config\n   * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}\n   */\n  async _createTexture(buffer, config = {}) {\n    const container = read(new Uint8Array(buffer));\n    if (container.vkFormat !== VK_FORMAT_UNDEFINED) {\n      return createRawTexture(container);\n    }\n    const taskConfig = config;\n    const texturePending = this.init().then(() => {\n      return this.workerPool.postMessage({\n        type: \"transcode\",\n        buffer,\n        taskConfig\n      }, [buffer]);\n    }).then(e => this._createTextureFrom(e.data, container));\n    _taskCache.set(buffer, {\n      promise: texturePending\n    });\n    return texturePending;\n  }\n  dispose() {\n    this.workerPool.dispose();\n    if (this.workerSourceURL) URL.revokeObjectURL(this.workerSourceURL);\n    _activeLoaders--;\n    return this;\n  }\n};\nlet KTX2Loader = _KTX2Loader;\n/* CONSTANTS */\n__publicField(KTX2Loader, \"BasisFormat\", {\n  ETC1S: 0,\n  UASTC_4x4: 1\n});\n__publicField(KTX2Loader, \"TranscoderFormat\", {\n  ETC1: 0,\n  ETC2: 1,\n  BC1: 2,\n  BC3: 3,\n  BC4: 4,\n  BC5: 5,\n  BC7_M6_OPAQUE_ONLY: 6,\n  BC7_M5: 7,\n  PVRTC1_4_RGB: 8,\n  PVRTC1_4_RGBA: 9,\n  ASTC_4x4: 10,\n  ATC_RGB: 11,\n  ATC_RGBA_INTERPOLATED_ALPHA: 12,\n  RGBA32: 13,\n  RGB565: 14,\n  BGR565: 15,\n  RGBA4444: 16\n});\n__publicField(KTX2Loader, \"EngineFormat\", {\n  RGBAFormat,\n  RGBA_ASTC_4x4_Format,\n  RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format,\n  RGB_ETC1_Format,\n  RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format\n});\n/* WEB WORKER */\n__publicField(KTX2Loader, \"BasisWorker\", function () {\n  let config;\n  let transcoderPending;\n  let BasisModule;\n  const EngineFormat = _EngineFormat;\n  const TranscoderFormat = _TranscoderFormat;\n  const BasisFormat = _BasisFormat;\n  self.addEventListener(\"message\", function (e) {\n    const message = e.data;\n    switch (message.type) {\n      case \"init\":\n        config = message.config;\n        init(message.transcoderBinary);\n        break;\n      case \"transcode\":\n        transcoderPending.then(() => {\n          try {\n            const {\n              faces,\n              buffers,\n              width,\n              height,\n              hasAlpha,\n              format,\n              dfdFlags\n            } = transcode(message.buffer);\n            self.postMessage({\n              type: \"transcode\",\n              id: message.id,\n              faces,\n              width,\n              height,\n              hasAlpha,\n              format,\n              dfdFlags\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: \"error\",\n              id: message.id,\n              error: error.message\n            });\n          }\n        });\n        break;\n    }\n  });\n  function init(wasmBinary) {\n    transcoderPending = new Promise(resolve => {\n      BasisModule = {\n        wasmBinary,\n        onRuntimeInitialized: resolve\n      };\n      BASIS(BasisModule);\n    }).then(() => {\n      BasisModule.initializeBasis();\n      if (BasisModule.KTX2File === void 0) {\n        console.warn(\"THREE.KTX2Loader: Please update Basis Universal transcoder.\");\n      }\n    });\n  }\n  function transcode(buffer) {\n    const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));\n    function cleanup() {\n      ktx2File.close();\n      ktx2File.delete();\n    }\n    if (!ktx2File.isValid()) {\n      cleanup();\n      throw new Error(\"THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file\");\n    }\n    const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;\n    const width = ktx2File.getWidth();\n    const height = ktx2File.getHeight();\n    const layerCount = ktx2File.getLayers() || 1;\n    const levelCount = ktx2File.getLevels();\n    const faceCount = ktx2File.getFaces();\n    const hasAlpha = ktx2File.getHasAlpha();\n    const dfdFlags = ktx2File.getDFDFlags();\n    const {\n      transcoderFormat,\n      engineFormat\n    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);\n    if (!width || !height || !levelCount) {\n      cleanup();\n      throw new Error(\"THREE.KTX2Loader:\tInvalid texture\");\n    }\n    if (!ktx2File.startTranscoding()) {\n      cleanup();\n      throw new Error(\"THREE.KTX2Loader: .startTranscoding failed\");\n    }\n    const faces = [];\n    const buffers = [];\n    for (let face = 0; face < faceCount; face++) {\n      const mipmaps = [];\n      for (let mip = 0; mip < levelCount; mip++) {\n        const layerMips = [];\n        let mipWidth, mipHeight;\n        for (let layer = 0; layer < layerCount; layer++) {\n          const levelInfo = ktx2File.getImageLevelInfo(mip, layer, face);\n          if (face === 0 && mip === 0 && layer === 0 && (levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0)) {\n            console.warn(\"THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.\");\n          }\n          if (levelCount > 1) {\n            mipWidth = levelInfo.origWidth;\n            mipHeight = levelInfo.origHeight;\n          } else {\n            mipWidth = levelInfo.width;\n            mipHeight = levelInfo.height;\n          }\n          const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, transcoderFormat));\n          const status = ktx2File.transcodeImage(dst, mip, layer, face, transcoderFormat, 0, -1, -1);\n          if (!status) {\n            cleanup();\n            throw new Error(\"THREE.KTX2Loader: .transcodeImage failed.\");\n          }\n          layerMips.push(dst);\n        }\n        const mipData = concat(layerMips);\n        mipmaps.push({\n          data: mipData,\n          width: mipWidth,\n          height: mipHeight\n        });\n        buffers.push(mipData.buffer);\n      }\n      faces.push({\n        mipmaps,\n        width,\n        height,\n        format: engineFormat\n      });\n    }\n    cleanup();\n    return {\n      faces,\n      buffers,\n      width,\n      height,\n      hasAlpha,\n      format: engineFormat,\n      dfdFlags\n    };\n  }\n  const FORMAT_OPTIONS = [{\n    if: \"astcSupported\",\n    basisFormat: [BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n    engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n    priorityETC1S: Infinity,\n    priorityUASTC: 1,\n    needsPowerOfTwo: false\n  }, {\n    if: \"bptcSupported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n    engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n    priorityETC1S: 3,\n    priorityUASTC: 2,\n    needsPowerOfTwo: false\n  }, {\n    if: \"dxtSupported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n    engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n    priorityETC1S: 4,\n    priorityUASTC: 5,\n    needsPowerOfTwo: false\n  }, {\n    if: \"etc2Supported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n    engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n    priorityETC1S: 1,\n    priorityUASTC: 3,\n    needsPowerOfTwo: false\n  }, {\n    if: \"etc1Supported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1],\n    engineFormat: [EngineFormat.RGB_ETC1_Format],\n    priorityETC1S: 2,\n    priorityUASTC: 4,\n    needsPowerOfTwo: false\n  }, {\n    if: \"pvrtcSupported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n    engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n    priorityETC1S: 5,\n    priorityUASTC: 6,\n    needsPowerOfTwo: true\n  }];\n  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityETC1S - b.priorityETC1S;\n  });\n  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityUASTC - b.priorityUASTC;\n  });\n  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n    let transcoderFormat;\n    let engineFormat;\n    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;\n    for (let i = 0; i < options.length; i++) {\n      const opt = options[i];\n      if (!config[opt.if]) continue;\n      if (!opt.basisFormat.includes(basisFormat)) continue;\n      if (hasAlpha && opt.transcoderFormat.length < 2) continue;\n      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;\n      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];\n      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];\n      return {\n        transcoderFormat,\n        engineFormat\n      };\n    }\n    console.warn(\"THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.\");\n    transcoderFormat = TranscoderFormat.RGBA32;\n    engineFormat = EngineFormat.RGBAFormat;\n    return {\n      transcoderFormat,\n      engineFormat\n    };\n  }\n  function isPowerOfTwo(value) {\n    if (value <= 2) return true;\n    return (value & value - 1) === 0 && value !== 0;\n  }\n  function concat(arrays) {\n    if (arrays.length === 1) return arrays[0];\n    let totalByteLength = 0;\n    for (let i = 0; i < arrays.length; i++) {\n      const array = arrays[i];\n      totalByteLength += array.byteLength;\n    }\n    const result = new Uint8Array(totalByteLength);\n    let byteOffset = 0;\n    for (let i = 0; i < arrays.length; i++) {\n      const array = arrays[i];\n      result.set(array, byteOffset);\n      byteOffset += array.byteLength;\n    }\n    return result;\n  }\n});\nconst UNCOMPRESSED_FORMATS = /* @__PURE__ */new Set([RGBAFormat, RGFormat, RedFormat]);\nconst FORMAT_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_UNORM]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_SRGB]: RGBAFormat,\n  [VK_FORMAT_R32G32_SFLOAT]: RGFormat,\n  [VK_FORMAT_R16G16_SFLOAT]: RGFormat,\n  [VK_FORMAT_R8G8_UNORM]: RGFormat,\n  [VK_FORMAT_R8G8_SRGB]: RGFormat,\n  [VK_FORMAT_R32_SFLOAT]: RedFormat,\n  [VK_FORMAT_R16_SFLOAT]: RedFormat,\n  [VK_FORMAT_R8_SRGB]: RedFormat,\n  [VK_FORMAT_R8_UNORM]: RedFormat,\n  [VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: RGBA_ASTC_6x6_Format,\n  [VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: RGBA_ASTC_6x6_Format\n};\nconst TYPE_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8B8A8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8B8A8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R32G32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: UnsignedByteType,\n  [VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: UnsignedByteType\n};\nasync function createRawTexture(container) {\n  const {\n    vkFormat\n  } = container;\n  if (FORMAT_MAP[vkFormat] === void 0) {\n    throw new Error(\"THREE.KTX2Loader: Unsupported vkFormat.\");\n  }\n  let zstd;\n  if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {\n    if (!_zstd) {\n      _zstd = new Promise(async resolve => {\n        const zstd2 = new ZSTDDecoder();\n        await zstd2.init();\n        resolve(zstd2);\n      });\n    }\n    zstd = await _zstd;\n  }\n  const mipmaps = [];\n  for (let levelIndex = 0; levelIndex < container.levels.length; levelIndex++) {\n    const levelWidth = Math.max(1, container.pixelWidth >> levelIndex);\n    const levelHeight = Math.max(1, container.pixelHeight >> levelIndex);\n    const levelDepth = container.pixelDepth ? Math.max(1, container.pixelDepth >> levelIndex) : 0;\n    const level = container.levels[levelIndex];\n    let levelData;\n    if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_NONE) {\n      levelData = level.levelData;\n    } else if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {\n      levelData = zstd.decode(level.levelData, level.uncompressedByteLength);\n    } else {\n      throw new Error(\"THREE.KTX2Loader: Unsupported supercompressionScheme.\");\n    }\n    let data;\n    if (TYPE_MAP[vkFormat] === FloatType) {\n      data = new Float32Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Float32Array.BYTES_PER_ELEMENT);\n    } else if (TYPE_MAP[vkFormat] === HalfFloatType) {\n      data = new Uint16Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT);\n    } else {\n      data = levelData;\n    }\n    mipmaps.push({\n      data,\n      width: levelWidth,\n      height: levelHeight,\n      depth: levelDepth\n    });\n  }\n  let texture;\n  if (UNCOMPRESSED_FORMATS.has(FORMAT_MAP[vkFormat])) {\n    texture = container.pixelDepth === 0 ? new DataTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight) : new Data3DTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight, container.pixelDepth);\n  } else {\n    if (container.pixelDepth > 0) throw new Error(\"THREE.KTX2Loader: Unsupported pixelDepth.\");\n    texture = new CompressedTexture(mipmaps, container.pixelWidth, container.pixelHeight);\n  }\n  texture.mipmaps = mipmaps;\n  texture.type = TYPE_MAP[vkFormat];\n  texture.format = FORMAT_MAP[vkFormat];\n  texture.needsUpdate = true;\n  const colorSpace = parseColorSpace(container);\n  if (\"colorSpace\" in texture) texture.colorSpace = colorSpace;else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n  return Promise.resolve(texture);\n}\nfunction parseColorSpace(container) {\n  const dfd = container.dataFormatDescriptor[0];\n  if (dfd.colorPrimaries === KHR_DF_PRIMARIES_BT709) {\n    return dfd.transferFunction === KHR_DF_TRANSFER_SRGB ? SRGBColorSpace : LinearSRGBColorSpace;\n  } else if (dfd.colorPrimaries === KHR_DF_PRIMARIES_DISPLAYP3) {\n    return dfd.transferFunction === KHR_DF_TRANSFER_SRGB ? DisplayP3ColorSpace : LinearDisplayP3ColorSpace;\n  } else if (dfd.colorPrimaries === KHR_DF_PRIMARIES_UNSPECIFIED) {\n    return NoColorSpace;\n  } else {\n    console.warn(`THREE.KTX2Loader: Unsupported color primaries, \"${dfd.colorPrimaries}\"`);\n    return NoColorSpace;\n  }\n}\nexport { KTX2Loader };\n//# sourceMappingURL=KTX2Loader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}