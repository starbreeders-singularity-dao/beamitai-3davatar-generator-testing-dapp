{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { FormatterError } from 'web3-errors';\nimport { Iban } from 'web3-eth-iban';\nimport { BlockTags } from 'web3-types';\nimport { fromUtf8, hexToNumber, hexToNumberString, isAddress, isHexStrict, mergeDeep, numberToHex, sha3Raw, toChecksumAddress, toNumber, toUtf8, utf8ToHex } from 'web3-utils';\nimport { isBlockTag, isHex, isNullish } from 'web3-validator';\n/* eslint-disable deprecation/deprecation */\n/**\n * @deprecated Use format function from web3-utils package instead\n * Will format the given storage key array values to hex strings.\n */\nexport const inputStorageKeysFormatter = keys => keys.map(num => numberToHex(num));\n/**\n * @deprecated Use format function from web3-utils package instead\n * Will format the given proof response from the node.\n */\nexport const outputProofFormatter = proof => ({\n  address: toChecksumAddress(proof.address),\n  nonce: hexToNumberString(proof.nonce),\n  balance: hexToNumberString(proof.balance)\n});\n/**\n * @deprecated Use format function from web3-utils package instead\n * Should the format output to a big number\n */\nexport const outputBigIntegerFormatter = number => toNumber(number);\n/**\n * @deprecated Use format function from web3-utils package instead\n * Returns the given block number as hex string or the predefined block number 'latest', 'pending', 'earliest', 'genesis'\n */\nexport const inputBlockNumberFormatter = blockNumber => {\n  if (isNullish(blockNumber)) {\n    return undefined;\n  }\n  if (typeof blockNumber === 'string' && isBlockTag(blockNumber)) {\n    return blockNumber;\n  }\n  if (blockNumber === 'genesis') {\n    return '0x0';\n  }\n  if (typeof blockNumber === 'string' && isHexStrict(blockNumber)) {\n    return blockNumber.toLowerCase();\n  }\n  return numberToHex(blockNumber);\n};\n/**\n * @deprecated Use format function from web3-utils package instead\n * Returns the given block number as hex string or does return the defaultBlock property of the current module\n */\nexport const inputDefaultBlockNumberFormatter = (blockNumber, defaultBlock) => {\n  if (!blockNumber) {\n    return inputBlockNumberFormatter(defaultBlock);\n  }\n  return inputBlockNumberFormatter(blockNumber);\n};\n/**\n * @deprecated Use format function from web3-utils package instead\n * @param address\n */\nexport const inputAddressFormatter = address => {\n  if (Iban.isValid(address) && Iban.isDirect(address)) {\n    const iban = new Iban(address);\n    return iban.toAddress().toLowerCase();\n  }\n  if (isAddress(address)) {\n    return `0x${address.toLowerCase().replace('0x', '')}`;\n  }\n  throw new FormatterError(`Provided address ${address} is invalid, the capitalization checksum test failed, or it's an indirect IBAN address which can't be converted.`);\n};\n/**\n * @deprecated Use format function from web3-utils package instead\n * Formats the input of a transaction and converts all values to HEX\n */\nexport const txInputOptionsFormatter = options => {\n  var _a;\n  const modifiedOptions = Object.assign({}, options);\n  if (options.to) {\n    // it might be contract creation\n    modifiedOptions.to = inputAddressFormatter(options.to);\n  }\n  if (options.data && options.input) {\n    throw new FormatterError('You can\\'t have \"data\" and \"input\" as properties of transactions at the same time, please use either \"data\" or \"input\" instead.');\n  }\n  if (!options.input && options.data) {\n    modifiedOptions.input = options.data;\n    delete modifiedOptions.data;\n  }\n  if (options.input && !options.input.startsWith('0x')) {\n    modifiedOptions.input = `0x${options.input}`;\n  }\n  if (modifiedOptions.input && !isHexStrict(modifiedOptions.input)) {\n    throw new FormatterError('The input field must be HEX encoded data.');\n  }\n  // allow both\n  if (options.gas || options.gasLimit) {\n    modifiedOptions.gas = toNumber((_a = options.gas) !== null && _a !== void 0 ? _a : options.gasLimit);\n  }\n  if (options.maxPriorityFeePerGas || options.maxFeePerGas) {\n    delete modifiedOptions.gasPrice;\n  }\n  ['gasPrice', 'gas', 'value', 'maxPriorityFeePerGas', 'maxFeePerGas', 'nonce', 'chainId'].filter(key => !isNullish(modifiedOptions[key])).forEach(key => {\n    modifiedOptions[key] = numberToHex(modifiedOptions[key]);\n  });\n  return modifiedOptions;\n};\n/**\n * @deprecated Use format function from web3-utils package instead\n * Formats the input of a transaction and converts all values to HEX\n */\nexport const inputCallFormatter = (options, defaultAccount) => {\n  var _a;\n  const opts = txInputOptionsFormatter(options);\n  const from = (_a = opts.from) !== null && _a !== void 0 ? _a : defaultAccount;\n  if (from) {\n    opts.from = inputAddressFormatter(from);\n  }\n  return opts;\n};\n/**\n * @deprecated Use format function from web3-utils package instead\n * Formats the input of a transaction and converts all values to HEX\n */\nexport const inputTransactionFormatter = (options, defaultAccount) => {\n  var _a;\n  const opts = txInputOptionsFormatter(options);\n  // check from, only if not number, or object\n  if (!(typeof opts.from === 'number') && !(!!opts.from && typeof opts.from === 'object')) {\n    opts.from = (_a = opts.from) !== null && _a !== void 0 ? _a : defaultAccount;\n    if (!options.from && !(typeof options.from === 'number')) {\n      throw new FormatterError('The send transactions \"from\" field must be defined!');\n    }\n    opts.from = inputAddressFormatter(options.from);\n  }\n  return opts;\n};\n/**\n * @deprecated Use format function from web3-utils package instead\n * Hex encodes the data passed to eth_sign and personal_sign\n */\nexport const inputSignFormatter = data => isHexStrict(data) ? data : utf8ToHex(data);\n/**\n * @deprecated Use format function from web3-utils package instead\n * Formats the output of a transaction to its proper values\n * @function outputTransactionFormatter\n */\nexport const outputTransactionFormatter = tx => {\n  const modifiedTx = Object.assign({}, tx);\n  if (tx.blockNumber) {\n    modifiedTx.blockNumber = hexToNumber(tx.blockNumber);\n  }\n  if (tx.transactionIndex) {\n    modifiedTx.transactionIndex = hexToNumber(tx.transactionIndex);\n  }\n  modifiedTx.nonce = hexToNumber(tx.nonce);\n  modifiedTx.gas = hexToNumber(tx.gas);\n  if (tx.gasPrice) {\n    modifiedTx.gasPrice = outputBigIntegerFormatter(tx.gasPrice);\n  }\n  if (tx.maxFeePerGas) {\n    modifiedTx.maxFeePerGas = outputBigIntegerFormatter(tx.maxFeePerGas);\n  }\n  if (tx.maxPriorityFeePerGas) {\n    modifiedTx.maxPriorityFeePerGas = outputBigIntegerFormatter(tx.maxPriorityFeePerGas);\n  }\n  if (tx.type) {\n    modifiedTx.type = hexToNumber(tx.type);\n  }\n  modifiedTx.value = outputBigIntegerFormatter(tx.value);\n  if (tx.to && isAddress(tx.to)) {\n    // tx.to could be `0x0` or `null` while contract creation\n    modifiedTx.to = toChecksumAddress(tx.to);\n  } else {\n    modifiedTx.to = undefined; // set to `null` if invalid address\n  }\n  if (tx.from) {\n    modifiedTx.from = toChecksumAddress(tx.from);\n  }\n  return modifiedTx;\n};\n/**\n * @deprecated Use format function from web3-utils package instead\n * @param topic\n */\n// To align with specification we use the type \"null\" here\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const inputTopicFormatter = topic => {\n  // Using \"null\" value intentionally for validation\n  // eslint-disable-next-line no-null/no-null\n  if (isNullish(topic)) return null;\n  const value = String(topic);\n  return isHex(value) ? value : fromUtf8(value);\n};\n/**\n * @deprecated Use format function from web3-utils package instead\n * @param filter\n */\nexport const inputLogFormatter = filter => {\n  var _a;\n  const val = isNullish(filter) ? {} : mergeDeep({}, filter);\n  // If options !== undefined, don't blow out existing data\n  if (isNullish(val.fromBlock)) {\n    val.fromBlock = BlockTags.LATEST;\n  }\n  val.fromBlock = inputBlockNumberFormatter(val.fromBlock);\n  if (!isNullish(val.toBlock)) {\n    val.toBlock = inputBlockNumberFormatter(val.toBlock);\n  }\n  // make sure topics, get converted to hex\n  val.topics = (_a = val.topics) !== null && _a !== void 0 ? _a : [];\n  val.topics = val.topics.map(topic => Array.isArray(topic) ? topic.map(inputTopicFormatter) : inputTopicFormatter(topic));\n  if (val.address) {\n    val.address = Array.isArray(val.address) ? val.address.map(addr => inputAddressFormatter(addr)) : inputAddressFormatter(val.address);\n  }\n  return val;\n};\n/**\n * @deprecated Use format function from web3-utils package instead\n * Formats the output of a log\n * @function outputLogFormatter\n */\nexport const outputLogFormatter = log => {\n  const modifiedLog = Object.assign({}, log);\n  const logIndex = typeof log.logIndex === 'string' ? log.logIndex : numberToHex(log.logIndex);\n  // generate a custom log id\n  if (typeof log.blockHash === 'string' && typeof log.transactionHash === 'string') {\n    const shaId = sha3Raw(`${log.blockHash.replace('0x', '')}${log.transactionHash.replace('0x', '')}${logIndex.replace('0x', '')}`);\n    modifiedLog.id = `log_${shaId.replace('0x', '').slice(0, 8)}`;\n  } else if (!log.id) {\n    modifiedLog.id = undefined;\n  }\n  if (log.blockNumber && isHexStrict(log.blockNumber)) {\n    modifiedLog.blockNumber = hexToNumber(log.blockNumber);\n  }\n  if (log.transactionIndex && isHexStrict(log.transactionIndex)) {\n    modifiedLog.transactionIndex = hexToNumber(log.transactionIndex);\n  }\n  if (log.logIndex && isHexStrict(log.logIndex)) {\n    modifiedLog.logIndex = hexToNumber(log.logIndex);\n  }\n  if (log.address) {\n    modifiedLog.address = toChecksumAddress(log.address);\n  }\n  return modifiedLog;\n};\n/**\n * @deprecated Use format function from web3-utils package instead\n * Formats the output of a transaction receipt to its proper values\n */\nexport const outputTransactionReceiptFormatter = receipt => {\n  if (typeof receipt !== 'object') {\n    throw new FormatterError(`Received receipt is invalid: ${String(receipt)}`);\n  }\n  const modifiedReceipt = Object.assign({}, receipt);\n  if (receipt.blockNumber) {\n    modifiedReceipt.blockNumber = hexToNumber(receipt.blockNumber);\n  }\n  if (receipt.transactionIndex) {\n    modifiedReceipt.transactionIndex = hexToNumber(receipt.transactionIndex);\n  }\n  modifiedReceipt.cumulativeGasUsed = hexToNumber(receipt.cumulativeGasUsed);\n  modifiedReceipt.gasUsed = hexToNumber(receipt.gasUsed);\n  if (receipt.logs && Array.isArray(receipt.logs)) {\n    modifiedReceipt.logs = receipt.logs.map(outputLogFormatter);\n  }\n  if (receipt.effectiveGasPrice) {\n    modifiedReceipt.effectiveGasPrice = hexToNumber(receipt.effectiveGasPrice);\n  }\n  if (receipt.contractAddress) {\n    modifiedReceipt.contractAddress = toChecksumAddress(receipt.contractAddress);\n  }\n  if (receipt.status) {\n    modifiedReceipt.status = Boolean(parseInt(receipt.status, 10));\n  }\n  return modifiedReceipt;\n};\n/**\n * @deprecated Use format function from web3-utils package instead\n * Formats the output of a block to its proper values\n * @function outputBlockFormatter\n */\nexport const outputBlockFormatter = block => {\n  const modifiedBlock = Object.assign({}, block);\n  // transform to number\n  modifiedBlock.gasLimit = hexToNumber(block.gasLimit);\n  modifiedBlock.gasUsed = hexToNumber(block.gasUsed);\n  modifiedBlock.size = hexToNumber(block.size);\n  modifiedBlock.timestamp = hexToNumber(block.timestamp);\n  if (block.number) {\n    modifiedBlock.number = hexToNumber(block.number);\n  }\n  if (block.difficulty) {\n    modifiedBlock.difficulty = outputBigIntegerFormatter(block.difficulty);\n  }\n  if (block.totalDifficulty) {\n    modifiedBlock.totalDifficulty = outputBigIntegerFormatter(block.totalDifficulty);\n  }\n  if (block.transactions && Array.isArray(block.transactions)) {\n    modifiedBlock.transactions = block.transactions.map(outputTransactionFormatter);\n  }\n  if (block.miner) {\n    modifiedBlock.miner = toChecksumAddress(block.miner);\n  }\n  if (block.baseFeePerGas) {\n    modifiedBlock.baseFeePerGas = outputBigIntegerFormatter(block.baseFeePerGas);\n  }\n  return modifiedBlock;\n};\n/**\n * @deprecated Use format function from web3-utils package instead\n * Formats the input of a whisper post and converts all values to HEX\n */\nexport const inputPostFormatter = post => {\n  var _a;\n  const modifiedPost = Object.assign({}, post);\n  if (post.ttl) {\n    modifiedPost.ttl = numberToHex(post.ttl);\n  }\n  if (post.workToProve) {\n    modifiedPost.workToProve = numberToHex(post.workToProve);\n  }\n  if (post.priority) {\n    modifiedPost.priority = numberToHex(post.priority);\n  }\n  // fallback\n  if (post.topics && !Array.isArray(post.topics)) {\n    modifiedPost.topics = post.topics ? [post.topics] : [];\n  }\n  // format the following options\n  modifiedPost.topics = (_a = modifiedPost.topics) === null || _a === void 0 ? void 0 : _a.map(topic => topic.startsWith('0x') ? topic : fromUtf8(topic));\n  return modifiedPost;\n};\n/**\n * @deprecated Use format function from web3-utils package instead\n * Formats the output of a received post message\n * @function outputPostFormatter\n */\nexport const outputPostFormatter = post => {\n  var _a;\n  const modifiedPost = Object.assign({}, post);\n  if (post.expiry) {\n    modifiedPost.expiry = hexToNumber(post.expiry);\n  }\n  if (post.sent) {\n    modifiedPost.sent = hexToNumber(post.sent);\n  }\n  if (post.ttl) {\n    modifiedPost.ttl = hexToNumber(post.ttl);\n  }\n  if (post.workProved) {\n    modifiedPost.workProved = hexToNumber(post.workProved);\n  }\n  // post.payloadRaw = post.payload;\n  // post.payload = utils.hexToAscii(post.payload);\n  // if (utils.isJson(post.payload)) {\n  //     post.payload = JSON.parse(post.payload);\n  // }\n  // format the following options\n  if (!post.topics) {\n    modifiedPost.topics = [];\n  }\n  modifiedPost.topics = (_a = modifiedPost.topics) === null || _a === void 0 ? void 0 : _a.map(toUtf8);\n  return modifiedPost;\n};\n/**\n * @deprecated Use format function from web3-utils package instead\n */\nexport const outputSyncingFormatter = result => {\n  const modifiedResult = Object.assign({}, result);\n  modifiedResult.startingBlock = hexToNumber(result.startingBlock);\n  modifiedResult.currentBlock = hexToNumber(result.currentBlock);\n  modifiedResult.highestBlock = hexToNumber(result.highestBlock);\n  if (result.knownStates) {\n    modifiedResult.knownStates = hexToNumber(result.knownStates);\n  }\n  if (result.pulledStates) {\n    modifiedResult.pulledStates = hexToNumber(result.pulledStates);\n  }\n  return modifiedResult;\n};\n//# sourceMappingURL=formatters.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}