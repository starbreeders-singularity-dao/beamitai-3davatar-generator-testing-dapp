{"ast":null,"code":"import { Loader, FileLoader, TextureLoader, Points, LineSegments, Mesh, PointsMaterial, LineBasicMaterial, BufferAttribute, MeshPhongMaterial, BackSide, DoubleSide, FrontSide, Vector2, Color, AddOperation, EquirectangularRefractionMapping, EquirectangularReflectionMapping, ClampToEdgeWrapping, MirroredRepeatWrapping, RepeatWrapping, MeshPhysicalMaterial, MeshStandardMaterial, BufferGeometry, Float32BufferAttribute } from \"three\";\nimport { IFFParser } from \"./lwo/IFFParser.js\";\nimport { UV1 } from \"../_polyfill/uv1.js\";\nlet _lwoTree;\nclass LWOLoader extends Loader {\n  constructor(manager, parameters = {}) {\n    super(manager);\n    this.resourcePath = parameters.resourcePath !== void 0 ? parameters.resourcePath : \"\";\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === \"\" ? extractParentUrl(url, \"Objects\") : scope.path;\n    const modelName = url.split(path).pop().split(\".\")[0];\n    const loader = new FileLoader(this.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.load(url, function (buffer) {\n      try {\n        onLoad(scope.parse(buffer, path, modelName));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(iffBuffer, path, modelName) {\n    _lwoTree = new IFFParser().parse(iffBuffer);\n    const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    return new LWOTreeParser(textureLoader).parse(modelName);\n  }\n}\nclass LWOTreeParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader;\n  }\n  parse(modelName) {\n    this.materials = new MaterialParser(this.textureLoader).parse();\n    this.defaultLayerName = modelName;\n    this.meshes = this.parseLayers();\n    return {\n      materials: this.materials,\n      meshes: this.meshes\n    };\n  }\n  parseLayers() {\n    const meshes = [];\n    const finalMeshes = [];\n    const geometryParser = new GeometryParser();\n    const scope = this;\n    _lwoTree.layers.forEach(function (layer) {\n      const geometry = geometryParser.parse(layer.geometry, layer);\n      const mesh = scope.parseMesh(geometry, layer);\n      meshes[layer.number] = mesh;\n      if (layer.parent === -1) finalMeshes.push(mesh);else meshes[layer.parent].add(mesh);\n    });\n    this.applyPivots(finalMeshes);\n    return finalMeshes;\n  }\n  parseMesh(geometry, layer) {\n    let mesh;\n    const materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);\n    if (UV1 === \"uv2\") this.duplicateUVs(geometry, materials);\n    if (layer.geometry.type === \"points\") mesh = new Points(geometry, materials);else if (layer.geometry.type === \"lines\") mesh = new LineSegments(geometry, materials);else mesh = new Mesh(geometry, materials);\n    if (layer.name) mesh.name = layer.name;else mesh.name = this.defaultLayerName + \"_layer_\" + layer.number;\n    mesh.userData.pivot = layer.pivot;\n    return mesh;\n  }\n  // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n  applyPivots(meshes) {\n    meshes.forEach(function (mesh) {\n      mesh.traverse(function (child) {\n        const pivot = child.userData.pivot;\n        child.position.x += pivot[0];\n        child.position.y += pivot[1];\n        child.position.z += pivot[2];\n        if (child.parent) {\n          const parentPivot = child.parent.userData.pivot;\n          child.position.x -= parentPivot[0];\n          child.position.y -= parentPivot[1];\n          child.position.z -= parentPivot[2];\n        }\n      });\n    });\n  }\n  getMaterials(namesArray, type) {\n    const materials = [];\n    const scope = this;\n    namesArray.forEach(function (name, i) {\n      materials[i] = scope.getMaterialByName(name);\n    });\n    if (type === \"points\" || type === \"lines\") {\n      materials.forEach(function (mat, i) {\n        const spec = {\n          color: mat.color\n        };\n        if (type === \"points\") {\n          spec.size = 0.1;\n          spec.map = mat.map;\n          spec.morphTargets = mat.morphTargets;\n          materials[i] = new PointsMaterial(spec);\n        } else if (type === \"lines\") {\n          materials[i] = new LineBasicMaterial(spec);\n        }\n      });\n    }\n    const filtered = materials.filter(Boolean);\n    if (filtered.length === 1) return filtered[0];\n    return materials;\n  }\n  getMaterialByName(name) {\n    return this.materials.filter(function (m) {\n      return m.name === name;\n    })[0];\n  }\n  // If the material has an aoMap, duplicate UVs\n  duplicateUVs(geometry, materials) {\n    let duplicateUVs = false;\n    if (!Array.isArray(materials)) {\n      if (materials.aoMap) duplicateUVs = true;\n    } else {\n      materials.forEach(function (material) {\n        if (material.aoMap) duplicateUVs = true;\n      });\n    }\n    if (!duplicateUVs) return;\n    geometry.setAttribute(\"uv2\", new BufferAttribute(geometry.attributes.uv.array, 2));\n  }\n}\nclass MaterialParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader;\n  }\n  parse() {\n    const materials = [];\n    this.textures = {};\n    for (const name in _lwoTree.materials) {\n      if (_lwoTree.format === \"LWO3\") {\n        materials.push(this.parseMaterial(_lwoTree.materials[name], name, _lwoTree.textures));\n      } else if (_lwoTree.format === \"LWO2\") {\n        materials.push(this.parseMaterialLwo2(_lwoTree.materials[name], name, _lwoTree.textures));\n      }\n    }\n    return materials;\n  }\n  parseMaterial(materialData, name, textures) {\n    let params = {\n      name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    const connections = this.parseConnections(materialData.connections, materialData.nodes);\n    const maps = this.parseTextureNodes(connections.maps);\n    this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps);\n    const attributes = this.parseAttributes(connections.attributes, maps);\n    this.parseEnvMap(connections, maps, attributes);\n    params = Object.assign(maps, params);\n    params = Object.assign(params, attributes);\n    const materialType = this.getMaterialType(connections.attributes);\n    return new materialType(params);\n  }\n  parseMaterialLwo2(materialData, name) {\n    let params = {\n      name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    const attributes = this.parseAttributes(materialData.attributes, {});\n    params = Object.assign(params, attributes);\n    return new MeshPhongMaterial(params);\n  }\n  // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n  // then switching mat FrontSide -> BackSide\n  // NB: this means that FrontSide and BackSide have been switched!\n  getSide(attributes) {\n    if (!attributes.side) return BackSide;\n    switch (attributes.side) {\n      case 0:\n      case 1:\n        return BackSide;\n      case 2:\n        return FrontSide;\n      case 3:\n        return DoubleSide;\n    }\n  }\n  getSmooth(attributes) {\n    if (!attributes.smooth) return true;\n    return !attributes.smooth;\n  }\n  parseConnections(connections, nodes) {\n    const materialConnections = {\n      maps: {}\n    };\n    const inputName = connections.inputName;\n    const inputNodeName = connections.inputNodeName;\n    const nodeName = connections.nodeName;\n    const scope = this;\n    inputName.forEach(function (name, index) {\n      if (name === \"Material\") {\n        const matNode = scope.getNodeByRefName(inputNodeName[index], nodes);\n        materialConnections.attributes = matNode.attributes;\n        materialConnections.envMap = matNode.fileName;\n        materialConnections.name = inputNodeName[index];\n      }\n    });\n    nodeName.forEach(function (name, index) {\n      if (name === materialConnections.name) {\n        materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes);\n      }\n    });\n    return materialConnections;\n  }\n  getNodeByRefName(refName, nodes) {\n    for (const name in nodes) {\n      if (nodes[name].refName === refName) return nodes[name];\n    }\n  }\n  parseTextureNodes(textureNodes) {\n    const maps = {};\n    for (const name in textureNodes) {\n      const node = textureNodes[name];\n      const path = node.fileName;\n      if (!path) return;\n      const texture = this.loadTexture(path);\n      if (node.widthWrappingMode !== void 0) texture.wrapS = this.getWrappingType(node.widthWrappingMode);\n      if (node.heightWrappingMode !== void 0) texture.wrapT = this.getWrappingType(node.heightWrappingMode);\n      switch (name) {\n        case \"Color\":\n          maps.map = texture;\n          break;\n        case \"Roughness\":\n          maps.roughnessMap = texture;\n          maps.roughness = 0.5;\n          break;\n        case \"Specular\":\n          maps.specularMap = texture;\n          maps.specular = 16777215;\n          break;\n        case \"Luminous\":\n          maps.emissiveMap = texture;\n          maps.emissive = 8421504;\n          break;\n        case \"Luminous Color\":\n          maps.emissive = 8421504;\n          break;\n        case \"Metallic\":\n          maps.metalnessMap = texture;\n          maps.metalness = 0.5;\n          break;\n        case \"Transparency\":\n        case \"Alpha\":\n          maps.alphaMap = texture;\n          maps.transparent = true;\n          break;\n        case \"Normal\":\n          maps.normalMap = texture;\n          if (node.amplitude !== void 0) maps.normalScale = new Vector2(node.amplitude, node.amplitude);\n          break;\n        case \"Bump\":\n          maps.bumpMap = texture;\n          break;\n      }\n    }\n    if (maps.roughnessMap && maps.specularMap) delete maps.specularMap;\n    return maps;\n  }\n  // maps can also be defined on individual material attributes, parse those here\n  // This occurs on Standard (Phong) surfaces\n  parseAttributeImageMaps(attributes, textures, maps) {\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      if (attribute.maps) {\n        const mapData = attribute.maps[0];\n        const path = this.getTexturePathByIndex(mapData.imageIndex, textures);\n        if (!path) return;\n        const texture = this.loadTexture(path);\n        if (mapData.wrap !== void 0) texture.wrapS = this.getWrappingType(mapData.wrap.w);\n        if (mapData.wrap !== void 0) texture.wrapT = this.getWrappingType(mapData.wrap.h);\n        switch (name) {\n          case \"Color\":\n            maps.map = texture;\n            break;\n          case \"Diffuse\":\n            maps.aoMap = texture;\n            break;\n          case \"Roughness\":\n            maps.roughnessMap = texture;\n            maps.roughness = 1;\n            break;\n          case \"Specular\":\n            maps.specularMap = texture;\n            maps.specular = 16777215;\n            break;\n          case \"Luminosity\":\n            maps.emissiveMap = texture;\n            maps.emissive = 8421504;\n            break;\n          case \"Metallic\":\n            maps.metalnessMap = texture;\n            maps.metalness = 1;\n            break;\n          case \"Transparency\":\n          case \"Alpha\":\n            maps.alphaMap = texture;\n            maps.transparent = true;\n            break;\n          case \"Normal\":\n            maps.normalMap = texture;\n            break;\n          case \"Bump\":\n            maps.bumpMap = texture;\n            break;\n        }\n      }\n    }\n  }\n  parseAttributes(attributes, maps) {\n    const params = {};\n    if (attributes.Color && !maps.map) {\n      params.color = new Color().fromArray(attributes.Color.value);\n    } else {\n      params.color = new Color();\n    }\n    if (attributes.Transparency && attributes.Transparency.value !== 0) {\n      params.opacity = 1 - attributes.Transparency.value;\n      params.transparent = true;\n    }\n    if (attributes[\"Bump Height\"]) params.bumpScale = attributes[\"Bump Height\"].value * 0.1;\n    if (attributes[\"Refraction Index\"]) params.refractionRatio = 1 / attributes[\"Refraction Index\"].value;\n    this.parsePhysicalAttributes(params, attributes, maps);\n    this.parseStandardAttributes(params, attributes, maps);\n    this.parsePhongAttributes(params, attributes, maps);\n    return params;\n  }\n  parsePhysicalAttributes(params, attributes) {\n    if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n      params.clearcoat = attributes.Clearcoat.value;\n      if (attributes[\"Clearcoat Gloss\"]) {\n        params.clearcoatRoughness = 0.5 * (1 - attributes[\"Clearcoat Gloss\"].value);\n      }\n    }\n  }\n  parseStandardAttributes(params, attributes, maps) {\n    if (attributes.Luminous) {\n      params.emissiveIntensity = attributes.Luminous.value;\n      if (attributes[\"Luminous Color\"] && !maps.emissive) {\n        params.emissive = new Color().fromArray(attributes[\"Luminous Color\"].value);\n      } else {\n        params.emissive = new Color(8421504);\n      }\n    }\n    if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value;\n    if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value;\n  }\n  parsePhongAttributes(params, attributes, maps) {\n    if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value);\n    if (attributes.Reflection) {\n      params.reflectivity = attributes.Reflection.value;\n      params.combine = AddOperation;\n    }\n    if (attributes.Luminosity) {\n      params.emissiveIntensity = attributes.Luminosity.value;\n      if (!maps.emissiveMap && !maps.map) {\n        params.emissive = params.color;\n      } else {\n        params.emissive = new Color(8421504);\n      }\n    }\n    if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n      if (attributes[\"Color Highlight\"]) {\n        params.specular = new Color().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes[\"Color Highlight\"].value);\n      } else {\n        params.specular = new Color().setScalar(attributes.Specular.value);\n      }\n    }\n    if (params.specular && attributes.Glossiness) {\n      params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);\n    }\n  }\n  parseEnvMap(connections, maps, attributes) {\n    if (connections.envMap) {\n      const envMap = this.loadTexture(connections.envMap);\n      if (attributes.transparent && attributes.opacity < 0.999) {\n        envMap.mapping = EquirectangularRefractionMapping;\n        if (attributes.reflectivity !== void 0) {\n          delete attributes.reflectivity;\n          delete attributes.combine;\n        }\n        if (attributes.metalness !== void 0) {\n          delete attributes.metalness;\n        }\n      } else {\n        envMap.mapping = EquirectangularReflectionMapping;\n      }\n      maps.envMap = envMap;\n    }\n  }\n  // get texture defined at top level by its index\n  getTexturePathByIndex(index) {\n    let fileName = \"\";\n    if (!_lwoTree.textures) return fileName;\n    _lwoTree.textures.forEach(function (texture) {\n      if (texture.index === index) fileName = texture.fileName;\n    });\n    return fileName;\n  }\n  loadTexture(path) {\n    if (!path) return null;\n    const texture = this.textureLoader.load(path, void 0, void 0, function () {\n      console.warn(\"LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.\");\n    });\n    return texture;\n  }\n  // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n  getWrappingType(num) {\n    switch (num) {\n      case 0:\n        console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three.js');\n        return ClampToEdgeWrapping;\n      case 1:\n        return RepeatWrapping;\n      case 2:\n        return MirroredRepeatWrapping;\n      case 3:\n        return ClampToEdgeWrapping;\n    }\n  }\n  getMaterialType(nodeData) {\n    if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return MeshPhysicalMaterial;\n    if (nodeData.Roughness) return MeshStandardMaterial;\n    return MeshPhongMaterial;\n  }\n}\nclass GeometryParser {\n  parse(geoData, layer) {\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(geoData.points, 3));\n    const indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);\n    geometry.setIndex(indices);\n    this.parseGroups(geometry, geoData);\n    geometry.computeVertexNormals();\n    this.parseUVs(geometry, layer, indices);\n    this.parseMorphTargets(geometry, layer, indices);\n    geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]);\n    return geometry;\n  }\n  // split quads into tris\n  splitIndices(indices, polygonDimensions) {\n    const remappedIndices = [];\n    let i = 0;\n    polygonDimensions.forEach(function (dim) {\n      if (dim < 4) {\n        for (let k = 0; k < dim; k++) remappedIndices.push(indices[i + k]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i], indices[i + 1], indices[i + 2], indices[i], indices[i + 2], indices[i + 3]);\n      } else if (dim > 4) {\n        for (let k = 1; k < dim - 1; k++) {\n          remappedIndices.push(indices[i], indices[i + k], indices[i + k + 1]);\n        }\n        console.warn(\"LWOLoader: polygons with greater than 4 sides are not supported\");\n      }\n      i += dim;\n    });\n    return remappedIndices;\n  }\n  // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n  parseGroups(geometry, geoData) {\n    const tags = _lwoTree.tags;\n    const matNames = [];\n    let elemSize = 3;\n    if (geoData.type === \"lines\") elemSize = 2;\n    if (geoData.type === \"points\") elemSize = 1;\n    const remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);\n    let indexNum = 0;\n    const indexPairs = {};\n    let prevMaterialIndex;\n    let materialIndex;\n    let prevStart = 0;\n    let currentCount = 0;\n    for (let i = 0; i < remappedIndices.length; i += 2) {\n      materialIndex = remappedIndices[i + 1];\n      if (i === 0) matNames[indexNum] = tags[materialIndex];\n      if (prevMaterialIndex === void 0) prevMaterialIndex = materialIndex;\n      if (materialIndex !== prevMaterialIndex) {\n        let currentIndex;\n        if (indexPairs[tags[prevMaterialIndex]]) {\n          currentIndex = indexPairs[tags[prevMaterialIndex]];\n        } else {\n          currentIndex = indexNum;\n          indexPairs[tags[prevMaterialIndex]] = indexNum;\n          matNames[indexNum] = tags[prevMaterialIndex];\n          indexNum++;\n        }\n        geometry.addGroup(prevStart, currentCount, currentIndex);\n        prevStart += currentCount;\n        prevMaterialIndex = materialIndex;\n        currentCount = 0;\n      }\n      currentCount += elemSize;\n    }\n    if (geometry.groups.length > 0) {\n      let currentIndex;\n      if (indexPairs[tags[materialIndex]]) {\n        currentIndex = indexPairs[tags[materialIndex]];\n      } else {\n        currentIndex = indexNum;\n        indexPairs[tags[materialIndex]] = indexNum;\n        matNames[indexNum] = tags[materialIndex];\n      }\n      geometry.addGroup(prevStart, currentCount, currentIndex);\n    }\n    geometry.userData.matNames = matNames;\n  }\n  splitMaterialIndices(polygonDimensions, indices) {\n    const remappedIndices = [];\n    polygonDimensions.forEach(function (dim, i) {\n      if (dim <= 3) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1]);\n      } else {\n        for (let k = 0; k < dim - 2; k++) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n        }\n      }\n    });\n    return remappedIndices;\n  }\n  // UV maps:\n  // 1: are defined via index into an array of points, not into a geometry\n  // - the geometry is also defined by an index into this array, but the indexes may not match\n  // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n  // \twith preference given to the first map encountered\n  // 3: UV maps can be partial - that is, defined for only a part of the geometry\n  // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n  // UV maps are defined as partially VMAP and partially VMAD\n  // VMADs are currently not supported\n  parseUVs(geometry, layer) {\n    const remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function () {\n      return 0;\n    });\n    for (const name in layer.uvs) {\n      const uvs = layer.uvs[name].uvs;\n      const uvIndices = layer.uvs[name].uvIndices;\n      uvIndices.forEach(function (i, j) {\n        remappedUVs[i * 2] = uvs[j * 2];\n        remappedUVs[i * 2 + 1] = uvs[j * 2 + 1];\n      });\n    }\n    geometry.setAttribute(\"uv\", new Float32BufferAttribute(remappedUVs, 2));\n  }\n  parseMorphTargets(geometry, layer) {\n    let num = 0;\n    for (const name in layer.morphTargets) {\n      const remappedPoints = geometry.attributes.position.array.slice();\n      if (!geometry.morphAttributes.position) geometry.morphAttributes.position = [];\n      const morphPoints = layer.morphTargets[name].points;\n      const morphIndices = layer.morphTargets[name].indices;\n      const type = layer.morphTargets[name].type;\n      morphIndices.forEach(function (i, j) {\n        if (type === \"relative\") {\n          remappedPoints[i * 3] += morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2];\n        } else {\n          remappedPoints[i * 3] = morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2];\n        }\n      });\n      geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3);\n      geometry.morphAttributes.position[num].name = name;\n      num++;\n    }\n    geometry.morphTargetsRelative = false;\n  }\n}\nfunction extractParentUrl(url, dir) {\n  const index = url.indexOf(dir);\n  if (index === -1) return \"./\";\n  return url.substr(0, index);\n}\nexport { LWOLoader };\n//# sourceMappingURL=LWOLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}