{"ast":null,"code":"import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry, Mesh, Matrix4 } from 'three';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\nconst boundingBox = /* @__PURE__ */new Box3();\nconst matrix = /* @__PURE__ */new Matrix4();\nclass MeshBVHRootHelper extends Object3D {\n  get isMesh() {\n    return !this.displayEdges;\n  }\n  get isLineSegments() {\n    return this.displayEdges;\n  }\n  get isLine() {\n    return this.displayEdges;\n  }\n  getVertexPosition(...args) {\n    // implement this function so it works with Box3.setFromObject\n    return Mesh.prototype.getVertexPosition.call(this, ...args);\n  }\n  constructor(bvh, material, depth = 10, group = 0) {\n    super();\n    this.material = material;\n    this.geometry = new BufferGeometry();\n    this.name = 'MeshBVHRootHelper';\n    this.depth = depth;\n    this.displayParents = false;\n    this.bvh = bvh;\n    this.displayEdges = true;\n    this._group = group;\n  }\n  raycast() {}\n  update() {\n    const geometry = this.geometry;\n    const boundsTree = this.bvh;\n    const group = this._group;\n    geometry.dispose();\n    this.visible = false;\n    if (boundsTree) {\n      // count the number of bounds required\n      const targetDepth = this.depth - 1;\n      const displayParents = this.displayParents;\n      let boundsCount = 0;\n      boundsTree.traverse((depth, isLeaf) => {\n        if (depth >= targetDepth || isLeaf) {\n          boundsCount++;\n          return true;\n        } else if (displayParents) {\n          boundsCount++;\n        }\n      }, group);\n\n      // fill in the position buffer with the bounds corners\n      let posIndex = 0;\n      const positionArray = new Float32Array(8 * 3 * boundsCount);\n      boundsTree.traverse((depth, isLeaf, boundingData) => {\n        const terminate = depth >= targetDepth || isLeaf;\n        if (terminate || displayParents) {\n          arrayToBox(0, boundingData, boundingBox);\n          const {\n            min,\n            max\n          } = boundingBox;\n          for (let x = -1; x <= 1; x += 2) {\n            const xVal = x < 0 ? min.x : max.x;\n            for (let y = -1; y <= 1; y += 2) {\n              const yVal = y < 0 ? min.y : max.y;\n              for (let z = -1; z <= 1; z += 2) {\n                const zVal = z < 0 ? min.z : max.z;\n                positionArray[posIndex + 0] = xVal;\n                positionArray[posIndex + 1] = yVal;\n                positionArray[posIndex + 2] = zVal;\n                posIndex += 3;\n              }\n            }\n          }\n          return terminate;\n        }\n      }, group);\n      let indexArray;\n      let indices;\n      if (this.displayEdges) {\n        // fill in the index buffer to point to the corner points\n        indices = new Uint8Array([\n        // x axis\n        0, 4, 1, 5, 2, 6, 3, 7,\n        // y axis\n        0, 2, 1, 3, 4, 6, 5, 7,\n        // z axis\n        0, 1, 2, 3, 4, 5, 6, 7]);\n      } else {\n        indices = new Uint8Array([\n        // X-, X+\n        0, 1, 2, 2, 1, 3, 4, 6, 5, 6, 7, 5,\n        // Y-, Y+\n        1, 4, 5, 0, 4, 1, 2, 3, 6, 3, 7, 6,\n        // Z-, Z+\n        0, 2, 4, 2, 6, 4, 1, 5, 3, 3, 5, 7]);\n      }\n      if (positionArray.length > 65535) {\n        indexArray = new Uint32Array(indices.length * boundsCount);\n      } else {\n        indexArray = new Uint16Array(indices.length * boundsCount);\n      }\n      const indexLength = indices.length;\n      for (let i = 0; i < boundsCount; i++) {\n        const posOffset = i * 8;\n        const indexOffset = i * indexLength;\n        for (let j = 0; j < indexLength; j++) {\n          indexArray[indexOffset + j] = posOffset + indices[j];\n        }\n      }\n\n      // update the geometry\n      geometry.setIndex(new BufferAttribute(indexArray, 1, false));\n      geometry.setAttribute('position', new BufferAttribute(positionArray, 3, false));\n      this.visible = true;\n    }\n  }\n}\nclass MeshBVHHelper extends Group {\n  get color() {\n    return this.edgeMaterial.color;\n  }\n  get opacity() {\n    return this.edgeMaterial.opacity;\n  }\n  set opacity(v) {\n    this.edgeMaterial.opacity = v;\n    this.meshMaterial.opacity = v;\n  }\n  constructor(mesh = null, bvh = null, depth = 10) {\n    // handle bvh, depth signature\n    if (mesh instanceof MeshBVH) {\n      depth = bvh || 10;\n      bvh = mesh;\n      mesh = null;\n    }\n\n    // handle mesh, depth signature\n    if (typeof bvh === 'number') {\n      depth = bvh;\n      bvh = null;\n    }\n    super();\n    this.name = 'MeshBVHHelper';\n    this.depth = depth;\n    this.mesh = mesh;\n    this.bvh = bvh;\n    this.displayParents = false;\n    this.displayEdges = true;\n    this.objectIndex = 0;\n    this._roots = [];\n    const edgeMaterial = new LineBasicMaterial({\n      color: 0x00FF88,\n      transparent: true,\n      opacity: 0.3,\n      depthWrite: false\n    });\n    const meshMaterial = new MeshBasicMaterial({\n      color: 0x00FF88,\n      transparent: true,\n      opacity: 0.3,\n      depthWrite: false\n    });\n    meshMaterial.color = edgeMaterial.color;\n    this.edgeMaterial = edgeMaterial;\n    this.meshMaterial = meshMaterial;\n    this.update();\n  }\n  update() {\n    const mesh = this.mesh;\n    let bvh = this.bvh || mesh.geometry.boundsTree || null;\n    if (mesh.isBatchedMesh && mesh.boundsTrees && !bvh) {\n      // get the bvh from a batchedMesh if not provided\n      // TODO: we should have an official way to get the geometry index cleanly\n      const drawInfo = mesh._drawInfo[this.objectIndex];\n      if (drawInfo) {\n        bvh = mesh.boundsTrees[drawInfo.geometryIndex] || bvh;\n      }\n    }\n    const totalRoots = bvh ? bvh._roots.length : 0;\n    while (this._roots.length > totalRoots) {\n      const root = this._roots.pop();\n      root.geometry.dispose();\n      this.remove(root);\n    }\n    for (let i = 0; i < totalRoots; i++) {\n      const {\n        depth,\n        edgeMaterial,\n        meshMaterial,\n        displayParents,\n        displayEdges\n      } = this;\n      if (i >= this._roots.length) {\n        const root = new MeshBVHRootHelper(bvh, edgeMaterial, depth, i);\n        this.add(root);\n        this._roots.push(root);\n      }\n      const root = this._roots[i];\n      root.bvh = bvh;\n      root.depth = depth;\n      root.displayParents = displayParents;\n      root.displayEdges = displayEdges;\n      root.material = displayEdges ? edgeMaterial : meshMaterial;\n      root.update();\n    }\n  }\n  updateMatrixWorld(...args) {\n    const mesh = this.mesh;\n    const parent = this.parent;\n    if (mesh !== null) {\n      mesh.updateWorldMatrix(true, false);\n      if (parent) {\n        this.matrix.copy(parent.matrixWorld).invert().multiply(mesh.matrixWorld);\n      } else {\n        this.matrix.copy(mesh.matrixWorld);\n      }\n\n      // handle batched and instanced mesh bvhs\n      if (mesh.isInstancedMesh || mesh.isBatchedMesh) {\n        mesh.getMatrixAt(this.objectIndex, matrix);\n        this.matrix.multiply(matrix);\n      }\n      this.matrix.decompose(this.position, this.quaternion, this.scale);\n    }\n    super.updateMatrixWorld(...args);\n  }\n  copy(source) {\n    this.depth = source.depth;\n    this.mesh = source.mesh;\n    this.bvh = source.bvh;\n    this.opacity = source.opacity;\n    this.color.copy(source.color);\n  }\n  clone() {\n    return new MeshBVHHelper(this.mesh, this.bvh, this.depth);\n  }\n  dispose() {\n    this.edgeMaterial.dispose();\n    this.meshMaterial.dispose();\n    const children = this.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].geometry.dispose();\n    }\n  }\n}\nexport class MeshBVHVisualizer extends MeshBVHHelper {\n  constructor(...args) {\n    super(...args);\n    console.warn('MeshBVHVisualizer: MeshBVHVisualizer has been deprecated. Use MeshBVHHelper, instead.');\n  }\n}\nexport { MeshBVHHelper };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}