{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { forwardRef, useRef, useState, useCallback, useMemo, useImperativeHandle, useEffect, Suspense, useContext, createContext } from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport { easing } from 'maath';\nimport { VideoTexture } from '../core/VideoTexture.js';\nimport { WebcamVideoTexture } from './WebcamVideoTexture.js';\nimport { Facemesh } from './Facemesh.js';\nimport { useFaceLandmarker } from './FaceLandmarker.js';\nfunction mean(v1, v2) {\n  return v1.clone().add(v2).multiplyScalar(0.5);\n}\nfunction localToLocal(objSrc, v, objDst) {\n  // see: https://discourse.threejs.org/t/object3d-localtolocal/51564\n  const v_world = objSrc.localToWorld(v);\n  return objDst.worldToLocal(v_world);\n}\n\n//\n//\n//\n\nconst FaceControlsContext = /* @__PURE__ */createContext({});\n\n/**\n * The camera follows your face.\n *\n * Pre-requisite: wrap into a `FaceLandmarker` provider:\n *\n * ```jsx\n * <FaceLandmarker>...</FaceLandmarker>\n * ```\n */\n\nconst FaceControls = /* @__PURE__ */forwardRef(({\n  camera,\n  videoTexture = {\n    start: true\n  },\n  manualDetect = false,\n  faceLandmarkerResult,\n  manualUpdate = false,\n  makeDefault,\n  smoothTime = 0.25,\n  offset = true,\n  offsetScalar = 80,\n  eyes = false,\n  eyesAsOrigin = true,\n  depth = 0.15,\n  debug = false,\n  facemesh\n}, fref) => {\n  var _result$facialTransfo, _result$faceBlendshap;\n  const scene = useThree(state => state.scene);\n  const defaultCamera = useThree(state => state.camera);\n  const set = useThree(state => state.set);\n  const get = useThree(state => state.get);\n  const explCamera = camera || defaultCamera;\n  const facemeshApiRef = useRef(null);\n\n  //\n  // computeTarget()\n  //\n  // Compute `target` position and rotation for the camera (according to <Facemesh>)\n  //\n  //  1. ðŸ‘€ either following the 2 eyes\n  //  2. ðŸ‘¤ or just the head mesh\n  //\n\n  const [target] = useState(() => new THREE.Object3D());\n  const [irisRightDirPos] = useState(() => new THREE.Vector3());\n  const [irisLeftDirPos] = useState(() => new THREE.Vector3());\n  const [irisRightLookAt] = useState(() => new THREE.Vector3());\n  const [irisLeftLookAt] = useState(() => new THREE.Vector3());\n  const computeTarget = useCallback(() => {\n    // same parent as the camera\n    target.parent = explCamera.parent;\n    const facemeshApi = facemeshApiRef.current;\n    if (facemeshApi) {\n      const {\n        outerRef,\n        eyeRightRef,\n        eyeLeftRef\n      } = facemeshApi;\n      if (eyeRightRef.current && eyeLeftRef.current) {\n        // 1. ðŸ‘€\n\n        const {\n          irisDirRef: irisRightDirRef\n        } = eyeRightRef.current;\n        const {\n          irisDirRef: irisLeftDirRef\n        } = eyeLeftRef.current;\n        if (irisRightDirRef.current && irisLeftDirRef.current && outerRef.current) {\n          //\n          // position: mean of irisRightDirPos,irisLeftDirPos\n          //\n          irisRightDirPos.copy(localToLocal(irisRightDirRef.current, new THREE.Vector3(0, 0, 0), outerRef.current));\n          irisLeftDirPos.copy(localToLocal(irisLeftDirRef.current, new THREE.Vector3(0, 0, 0), outerRef.current));\n          target.position.copy(localToLocal(outerRef.current, mean(irisRightDirPos, irisLeftDirPos), explCamera.parent || scene));\n\n          //\n          // lookAt: mean of irisRightLookAt,irisLeftLookAt\n          //\n          irisRightLookAt.copy(localToLocal(irisRightDirRef.current, new THREE.Vector3(0, 0, 1), outerRef.current));\n          irisLeftLookAt.copy(localToLocal(irisLeftDirRef.current, new THREE.Vector3(0, 0, 1), outerRef.current));\n          target.lookAt(outerRef.current.localToWorld(mean(irisRightLookAt, irisLeftLookAt)));\n        }\n      } else {\n        // 2. ðŸ‘¤\n\n        if (outerRef.current) {\n          target.position.copy(localToLocal(outerRef.current, new THREE.Vector3(0, 0, 0), explCamera.parent || scene));\n          target.lookAt(outerRef.current.localToWorld(new THREE.Vector3(0, 0, 1)));\n        }\n      }\n    }\n    return target;\n  }, [explCamera, irisLeftDirPos, irisLeftLookAt, irisRightDirPos, irisRightLookAt, scene, target]);\n\n  //\n  // update()\n  //\n  // Updating the camera `current` position and rotation, following `target`\n  //\n\n  const [current] = useState(() => new THREE.Object3D());\n  const update = useCallback(function (delta, target) {\n    if (explCamera) {\n      var _target;\n      (_target = target) !== null && _target !== void 0 ? _target : target = computeTarget();\n      if (smoothTime > 0) {\n        // damping current\n        const eps = 1e-9;\n        easing.damp3(current.position, target.position, smoothTime, delta, undefined, undefined, eps);\n        easing.dampE(current.rotation, target.rotation, smoothTime, delta, undefined, undefined, eps);\n      } else {\n        // instant\n        current.position.copy(target.position);\n        current.rotation.copy(target.rotation);\n      }\n      explCamera.position.copy(current.position);\n      explCamera.rotation.copy(current.rotation);\n    }\n  }, [explCamera, computeTarget, smoothTime, current.position, current.rotation]);\n  useFrame((_, delta) => {\n    if (manualUpdate) return;\n    update(delta);\n  });\n\n  //\n  // onVideoFrame (only used if !manualDetect)\n  //\n\n  const videoTextureRef = useRef(null);\n  const [_faceLandmarkerResult, setFaceLandmarkerResult] = useState();\n  const faceLandmarker = useFaceLandmarker();\n  const onVideoFrame = useCallback((now, metadata) => {\n    const texture = videoTextureRef.current;\n    if (!texture) return;\n    const videoFrame = texture.source.data;\n    const result = faceLandmarker == null ? void 0 : faceLandmarker.detectForVideo(videoFrame, now);\n    setFaceLandmarkerResult(result);\n  }, [faceLandmarker]);\n\n  //\n  // Ref API\n  //\n\n  const api = useMemo(() => Object.assign(Object.create(THREE.EventDispatcher.prototype), {\n    computeTarget,\n    update,\n    facemeshApiRef\n  }), [computeTarget, update]);\n  useImperativeHandle(fref, () => api, [api]);\n\n  //\n  // makeDefault (`controls` global state)\n  //\n\n  useEffect(() => {\n    if (makeDefault) {\n      const old = get().controls;\n      set({\n        controls: api\n      });\n      return () => set({\n        controls: old\n      });\n    }\n  }, [makeDefault, api, get, set]);\n\n  //\n  //\n  //\n\n  const result = faceLandmarkerResult !== null && faceLandmarkerResult !== void 0 ? faceLandmarkerResult : _faceLandmarkerResult;\n  const points = result == null ? void 0 : result.faceLandmarks[0];\n  const facialTransformationMatrix = result == null || (_result$facialTransfo = result.facialTransformationMatrixes) == null ? void 0 : _result$facialTransfo[0];\n  const faceBlendshapes = result == null || (_result$faceBlendshap = result.faceBlendshapes) == null ? void 0 : _result$faceBlendshap[0];\n  const videoTextureProps = {\n    onVideoFrame,\n    ...videoTexture\n  };\n  return /*#__PURE__*/React.createElement(FaceControlsContext.Provider, {\n    value: api\n  }, !manualDetect && /*#__PURE__*/React.createElement(Suspense, {\n    fallback: null\n  }, 'src' in videoTextureProps ? /*#__PURE__*/React.createElement(VideoTexture, _extends({\n    ref: videoTextureRef\n  }, videoTextureProps)) : /*#__PURE__*/React.createElement(WebcamVideoTexture, _extends({\n    ref: videoTextureRef\n  }, videoTextureProps))), /*#__PURE__*/React.createElement(Facemesh, _extends({\n    ref: facemeshApiRef,\n    children: /*#__PURE__*/React.createElement(\"meshNormalMaterial\", {\n      side: THREE.DoubleSide\n    })\n  }, facemesh, {\n    points: points,\n    depth: depth,\n    facialTransformationMatrix: facialTransformationMatrix,\n    faceBlendshapes: faceBlendshapes,\n    eyes: eyes,\n    eyesAsOrigin: eyesAsOrigin,\n    offset: offset,\n    offsetScalar: offsetScalar,\n    debug: debug,\n    \"rotation-z\": Math.PI,\n    visible: debug\n  })));\n});\nconst useFaceControls = () => useContext(FaceControlsContext);\nexport { FaceControls, useFaceControls };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}