{"ast":null,"code":"import { NoColorSpace, DoubleSide, Color } from 'three';\nimport { strToU8, zipSync } from '../libs/fflate.module.js';\nclass USDZExporter {\n  constructor() {\n    this.textureUtils = null;\n  }\n  setTextureUtils(utils) {\n    this.textureUtils = utils;\n  }\n  parse(scene, onDone, onError, options) {\n    this.parseAsync(scene, options).then(onDone).catch(onError);\n  }\n  async parseAsync(scene, options = {}) {\n    options = Object.assign({\n      ar: {\n        anchoring: {\n          type: 'plane'\n        },\n        planeAnchoring: {\n          alignment: 'horizontal'\n        }\n      },\n      includeAnchoringProperties: true,\n      quickLookCompatible: false,\n      maxTextureSize: 1024\n    }, options);\n    const files = {};\n    const modelFileName = 'model.usda';\n\n    // model file should be first in USDZ archive so we init it here\n    files[modelFileName] = null;\n    let output = buildHeader();\n    output += buildSceneStart(options);\n    const materials = {};\n    const textures = {};\n    scene.traverseVisible(object => {\n      if (object.isMesh) {\n        const geometry = object.geometry;\n        const material = object.material;\n        if (material.isMeshStandardMaterial) {\n          const geometryFileName = 'geometries/Geometry_' + geometry.id + '.usda';\n          if (!(geometryFileName in files)) {\n            const meshObject = buildMeshObject(geometry);\n            files[geometryFileName] = buildUSDFileAsString(meshObject);\n          }\n          if (!(material.uuid in materials)) {\n            materials[material.uuid] = material;\n          }\n          output += buildXform(object, geometry, material);\n        } else {\n          console.warn('THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)', object);\n        }\n      } else if (object.isCamera) {\n        output += buildCamera(object);\n      }\n    });\n    output += buildSceneEnd();\n    output += buildMaterials(materials, textures, options.quickLookCompatible);\n    files[modelFileName] = strToU8(output);\n    output = null;\n    for (const id in textures) {\n      let texture = textures[id];\n      if (texture.isCompressedTexture === true) {\n        if (this.textureUtils === null) {\n          throw new Error('THREE.USDZExporter: setTextureUtils() must be called to process compressed textures.');\n        } else {\n          texture = await this.textureUtils.decompress(texture);\n        }\n      }\n      const canvas = imageToCanvas(texture.image, texture.flipY, options.maxTextureSize);\n      const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png', 1));\n      files[`textures/Texture_${id}.png`] = new Uint8Array(await blob.arrayBuffer());\n    }\n\n    // 64 byte alignment\n    // https://github.com/101arrowz/fflate/issues/39#issuecomment-777263109\n\n    let offset = 0;\n    for (const filename in files) {\n      const file = files[filename];\n      const headerSize = 34 + filename.length;\n      offset += headerSize;\n      const offsetMod64 = offset & 63;\n      if (offsetMod64 !== 4) {\n        const padLength = 64 - offsetMod64;\n        const padding = new Uint8Array(padLength);\n        files[filename] = [file, {\n          extra: {\n            12345: padding\n          }\n        }];\n      }\n      offset = file.length;\n    }\n    return zipSync(files, {\n      level: 0\n    });\n  }\n}\nfunction imageToCanvas(image, flipY, maxTextureSize) {\n  if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    const scale = maxTextureSize / Math.max(image.width, image.height);\n    const canvas = document.createElement('canvas');\n    canvas.width = image.width * Math.min(1, scale);\n    canvas.height = image.height * Math.min(1, scale);\n    const context = canvas.getContext('2d');\n\n    // TODO: We should be able to do this in the UsdTransform2d?\n\n    if (flipY === true) {\n      context.translate(0, canvas.height);\n      context.scale(1, -1);\n    }\n    context.drawImage(image, 0, 0, canvas.width, canvas.height);\n    return canvas;\n  } else {\n    throw new Error('THREE.USDZExporter: No valid image data found. Unable to process texture.');\n  }\n}\n\n//\n\nconst PRECISION = 7;\nfunction buildHeader() {\n  return `#usda 1.0\n(\n\tcustomLayerData = {\n\t\tstring creator = \"Three.js USDZExporter\"\n\t}\n\tdefaultPrim = \"Root\"\n\tmetersPerUnit = 1\n\tupAxis = \"Y\"\n)\n\n`;\n}\nfunction buildSceneStart(options) {\n  const alignment = options.includeAnchoringProperties === true ? `\n\t\ttoken preliminary:anchoring:type = \"${options.ar.anchoring.type}\"\n\t\ttoken preliminary:planeAnchoring:alignment = \"${options.ar.planeAnchoring.alignment}\"\n\t` : '';\n  return `def Xform \"Root\"\n{\n\tdef Scope \"Scenes\" (\n\t\tkind = \"sceneLibrary\"\n\t)\n\t{\n\t\tdef Xform \"Scene\" (\n\t\t\tcustomData = {\n\t\t\t\tbool preliminary_collidesWithEnvironment = 0\n\t\t\t\tstring sceneName = \"Scene\"\n\t\t\t}\n\t\t\tsceneName = \"Scene\"\n\t\t)\n\t\t{${alignment}\n`;\n}\nfunction buildSceneEnd() {\n  return `\n\t\t}\n\t}\n}\n\n`;\n}\nfunction buildUSDFileAsString(dataToInsert) {\n  let output = buildHeader();\n  output += dataToInsert;\n  return strToU8(output);\n}\n\n// Xform\n\nfunction buildXform(object, geometry, material) {\n  const name = 'Object_' + object.id;\n  const transform = buildMatrix(object.matrixWorld);\n  if (object.matrixWorld.determinant() < 0) {\n    console.warn('THREE.USDZExporter: USDZ does not support negative scales', object);\n  }\n  return `def Xform \"${name}\" (\n\tprepend references = @./geometries/Geometry_${geometry.id}.usda@</Geometry>\n\tprepend apiSchemas = [\"MaterialBindingAPI\"]\n)\n{\n\tmatrix4d xformOp:transform = ${transform}\n\tuniform token[] xformOpOrder = [\"xformOp:transform\"]\n\n\trel material:binding = </Materials/Material_${material.id}>\n}\n\n`;\n}\nfunction buildMatrix(matrix) {\n  const array = matrix.elements;\n  return `( ${buildMatrixRow(array, 0)}, ${buildMatrixRow(array, 4)}, ${buildMatrixRow(array, 8)}, ${buildMatrixRow(array, 12)} )`;\n}\nfunction buildMatrixRow(array, offset) {\n  return `(${array[offset + 0]}, ${array[offset + 1]}, ${array[offset + 2]}, ${array[offset + 3]})`;\n}\n\n// Mesh\n\nfunction buildMeshObject(geometry) {\n  const mesh = buildMesh(geometry);\n  return `\ndef \"Geometry\"\n{\n${mesh}\n}\n`;\n}\nfunction buildMesh(geometry) {\n  const name = 'Geometry';\n  const attributes = geometry.attributes;\n  const count = attributes.position.count;\n  return `\n\tdef Mesh \"${name}\"\n\t{\n\t\tint[] faceVertexCounts = [${buildMeshVertexCount(geometry)}]\n\t\tint[] faceVertexIndices = [${buildMeshVertexIndices(geometry)}]\n\t\tnormal3f[] normals = [${buildVector3Array(attributes.normal, count)}] (\n\t\t\tinterpolation = \"vertex\"\n\t\t)\n\t\tpoint3f[] points = [${buildVector3Array(attributes.position, count)}]\n${buildPrimvars(attributes)}\n\t\tuniform token subdivisionScheme = \"none\"\n\t}\n`;\n}\nfunction buildMeshVertexCount(geometry) {\n  const count = geometry.index !== null ? geometry.index.count : geometry.attributes.position.count;\n  return Array(count / 3).fill(3).join(', ');\n}\nfunction buildMeshVertexIndices(geometry) {\n  const index = geometry.index;\n  const array = [];\n  if (index !== null) {\n    for (let i = 0; i < index.count; i++) {\n      array.push(index.getX(i));\n    }\n  } else {\n    const length = geometry.attributes.position.count;\n    for (let i = 0; i < length; i++) {\n      array.push(i);\n    }\n  }\n  return array.join(', ');\n}\nfunction buildVector3Array(attribute, count) {\n  if (attribute === undefined) {\n    console.warn('USDZExporter: Normals missing.');\n    return Array(count).fill('(0, 0, 0)').join(', ');\n  }\n  const array = [];\n  for (let i = 0; i < attribute.count; i++) {\n    const x = attribute.getX(i);\n    const y = attribute.getY(i);\n    const z = attribute.getZ(i);\n    array.push(`(${x.toPrecision(PRECISION)}, ${y.toPrecision(PRECISION)}, ${z.toPrecision(PRECISION)})`);\n  }\n  return array.join(', ');\n}\nfunction buildVector2Array(attribute) {\n  const array = [];\n  for (let i = 0; i < attribute.count; i++) {\n    const x = attribute.getX(i);\n    const y = attribute.getY(i);\n    array.push(`(${x.toPrecision(PRECISION)}, ${1 - y.toPrecision(PRECISION)})`);\n  }\n  return array.join(', ');\n}\nfunction buildPrimvars(attributes) {\n  let string = '';\n  for (let i = 0; i < 4; i++) {\n    const id = i > 0 ? i : '';\n    const attribute = attributes['uv' + id];\n    if (attribute !== undefined) {\n      string += `\n\t\ttexCoord2f[] primvars:st${id} = [${buildVector2Array(attribute)}] (\n\t\t\tinterpolation = \"vertex\"\n\t\t)`;\n    }\n  }\n\n  // vertex colors\n\n  const colorAttribute = attributes.color;\n  if (colorAttribute !== undefined) {\n    const count = colorAttribute.count;\n    string += `\n\tcolor3f[] primvars:displayColor = [${buildVector3Array(colorAttribute, count)}] (\n\t\tinterpolation = \"vertex\"\n\t\t)`;\n  }\n  return string;\n}\n\n// Materials\n\nfunction buildMaterials(materials, textures, quickLookCompatible = false) {\n  const array = [];\n  for (const uuid in materials) {\n    const material = materials[uuid];\n    array.push(buildMaterial(material, textures, quickLookCompatible));\n  }\n  return `def \"Materials\"\n{\n${array.join('')}\n}\n\n`;\n}\nfunction buildMaterial(material, textures, quickLookCompatible = false) {\n  // https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html\n\n  const pad = '\t\t\t';\n  const inputs = [];\n  const samplers = [];\n  function buildTexture(texture, mapType, color) {\n    const id = texture.source.id + '_' + texture.flipY;\n    textures[id] = texture;\n    const uv = texture.channel > 0 ? 'st' + texture.channel : 'st';\n    const WRAPPINGS = {\n      1000: 'repeat',\n      // RepeatWrapping\n      1001: 'clamp',\n      // ClampToEdgeWrapping\n      1002: 'mirror' // MirroredRepeatWrapping\n    };\n    const repeat = texture.repeat.clone();\n    const offset = texture.offset.clone();\n    const rotation = texture.rotation;\n\n    // rotation is around the wrong point. after rotation we need to shift offset again so that we're rotating around the right spot\n    const xRotationOffset = Math.sin(rotation);\n    const yRotationOffset = Math.cos(rotation);\n\n    // texture coordinates start in the opposite corner, need to correct\n    offset.y = 1 - offset.y - repeat.y;\n\n    // turns out QuickLook is buggy and interprets texture repeat inverted/applies operations in a different order.\n    // Apple Feedback: \tFB10036297 and FB11442287\n    if (quickLookCompatible) {\n      // This is NOT correct yet in QuickLook, but comes close for a range of models.\n      // It becomes more incorrect the bigger the offset is\n\n      offset.x = offset.x / repeat.x;\n      offset.y = offset.y / repeat.y;\n      offset.x += xRotationOffset / repeat.x;\n      offset.y += yRotationOffset - 1;\n    } else {\n      // results match glTF results exactly. verified correct in usdview.\n      offset.x += xRotationOffset * repeat.x;\n      offset.y += (1 - yRotationOffset) * repeat.y;\n    }\n    return `\n\t\tdef Shader \"PrimvarReader_${mapType}\"\n\t\t{\n\t\t\tuniform token info:id = \"UsdPrimvarReader_float2\"\n\t\t\tfloat2 inputs:fallback = (0.0, 0.0)\n\t\t\ttoken inputs:varname = \"${uv}\"\n\t\t\tfloat2 outputs:result\n\t\t}\n\n\t\tdef Shader \"Transform2d_${mapType}\"\n\t\t{\n\t\t\tuniform token info:id = \"UsdTransform2d\"\n\t\t\ttoken inputs:in.connect = </Materials/Material_${material.id}/PrimvarReader_${mapType}.outputs:result>\n\t\t\tfloat inputs:rotation = ${(rotation * (180 / Math.PI)).toFixed(PRECISION)}\n\t\t\tfloat2 inputs:scale = ${buildVector2(repeat)}\n\t\t\tfloat2 inputs:translation = ${buildVector2(offset)}\n\t\t\tfloat2 outputs:result\n\t\t}\n\n\t\tdef Shader \"Texture_${texture.id}_${mapType}\"\n\t\t{\n\t\t\tuniform token info:id = \"UsdUVTexture\"\n\t\t\tasset inputs:file = @textures/Texture_${id}.png@\n\t\t\tfloat2 inputs:st.connect = </Materials/Material_${material.id}/Transform2d_${mapType}.outputs:result>\n\t\t\t${color !== undefined ? 'float4 inputs:scale = ' + buildColor4(color) : ''}\n\t\t\ttoken inputs:sourceColorSpace = \"${texture.colorSpace === NoColorSpace ? 'raw' : 'sRGB'}\"\n\t\t\ttoken inputs:wrapS = \"${WRAPPINGS[texture.wrapS]}\"\n\t\t\ttoken inputs:wrapT = \"${WRAPPINGS[texture.wrapT]}\"\n\t\t\tfloat outputs:r\n\t\t\tfloat outputs:g\n\t\t\tfloat outputs:b\n\t\t\tfloat3 outputs:rgb\n\t\t\t${material.transparent || material.alphaTest > 0.0 ? 'float outputs:a' : ''}\n\t\t}`;\n  }\n  if (material.side === DoubleSide) {\n    console.warn('THREE.USDZExporter: USDZ does not support double sided materials', material);\n  }\n  if (material.map !== null) {\n    inputs.push(`${pad}color3f inputs:diffuseColor.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:rgb>`);\n    if (material.transparent) {\n      inputs.push(`${pad}float inputs:opacity.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:a>`);\n    } else if (material.alphaTest > 0.0) {\n      inputs.push(`${pad}float inputs:opacity.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:a>`);\n      inputs.push(`${pad}float inputs:opacityThreshold = ${material.alphaTest}`);\n    }\n    samplers.push(buildTexture(material.map, 'diffuse', material.color));\n  } else {\n    inputs.push(`${pad}color3f inputs:diffuseColor = ${buildColor(material.color)}`);\n  }\n  if (material.emissiveMap !== null) {\n    inputs.push(`${pad}color3f inputs:emissiveColor.connect = </Materials/Material_${material.id}/Texture_${material.emissiveMap.id}_emissive.outputs:rgb>`);\n    samplers.push(buildTexture(material.emissiveMap, 'emissive', new Color(material.emissive.r * material.emissiveIntensity, material.emissive.g * material.emissiveIntensity, material.emissive.b * material.emissiveIntensity)));\n  } else if (material.emissive.getHex() > 0) {\n    inputs.push(`${pad}color3f inputs:emissiveColor = ${buildColor(material.emissive)}`);\n  }\n  if (material.normalMap !== null) {\n    inputs.push(`${pad}normal3f inputs:normal.connect = </Materials/Material_${material.id}/Texture_${material.normalMap.id}_normal.outputs:rgb>`);\n    samplers.push(buildTexture(material.normalMap, 'normal'));\n  }\n  if (material.aoMap !== null) {\n    inputs.push(`${pad}float inputs:occlusion.connect = </Materials/Material_${material.id}/Texture_${material.aoMap.id}_occlusion.outputs:r>`);\n    samplers.push(buildTexture(material.aoMap, 'occlusion', new Color(material.aoMapIntensity, material.aoMapIntensity, material.aoMapIntensity)));\n  }\n  if (material.roughnessMap !== null) {\n    inputs.push(`${pad}float inputs:roughness.connect = </Materials/Material_${material.id}/Texture_${material.roughnessMap.id}_roughness.outputs:g>`);\n    samplers.push(buildTexture(material.roughnessMap, 'roughness', new Color(material.roughness, material.roughness, material.roughness)));\n  } else {\n    inputs.push(`${pad}float inputs:roughness = ${material.roughness}`);\n  }\n  if (material.metalnessMap !== null) {\n    inputs.push(`${pad}float inputs:metallic.connect = </Materials/Material_${material.id}/Texture_${material.metalnessMap.id}_metallic.outputs:b>`);\n    samplers.push(buildTexture(material.metalnessMap, 'metallic', new Color(material.metalness, material.metalness, material.metalness)));\n  } else {\n    inputs.push(`${pad}float inputs:metallic = ${material.metalness}`);\n  }\n  if (material.alphaMap !== null) {\n    inputs.push(`${pad}float inputs:opacity.connect = </Materials/Material_${material.id}/Texture_${material.alphaMap.id}_opacity.outputs:r>`);\n    inputs.push(`${pad}float inputs:opacityThreshold = 0.0001`);\n    samplers.push(buildTexture(material.alphaMap, 'opacity'));\n  } else {\n    inputs.push(`${pad}float inputs:opacity = ${material.opacity}`);\n  }\n  if (material.isMeshPhysicalMaterial) {\n    if (material.clearcoatMap !== null) {\n      inputs.push(`${pad}float inputs:clearcoat.connect = </Materials/Material_${material.id}/Texture_${material.clearcoatMap.id}_clearcoat.outputs:r>`);\n      samplers.push(buildTexture(material.clearcoatMap, 'clearcoat', new Color(material.clearcoat, material.clearcoat, material.clearcoat)));\n    } else {\n      inputs.push(`${pad}float inputs:clearcoat = ${material.clearcoat}`);\n    }\n    if (material.clearcoatRoughnessMap !== null) {\n      inputs.push(`${pad}float inputs:clearcoatRoughness.connect = </Materials/Material_${material.id}/Texture_${material.clearcoatRoughnessMap.id}_clearcoatRoughness.outputs:g>`);\n      samplers.push(buildTexture(material.clearcoatRoughnessMap, 'clearcoatRoughness', new Color(material.clearcoatRoughness, material.clearcoatRoughness, material.clearcoatRoughness)));\n    } else {\n      inputs.push(`${pad}float inputs:clearcoatRoughness = ${material.clearcoatRoughness}`);\n    }\n    inputs.push(`${pad}float inputs:ior = ${material.ior}`);\n  }\n  return `\n\tdef Material \"Material_${material.id}\"\n\t{\n\t\tdef Shader \"PreviewSurface\"\n\t\t{\n\t\t\tuniform token info:id = \"UsdPreviewSurface\"\n${inputs.join('\\n')}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${material.id}/PreviewSurface.outputs:surface>\n\n${samplers.join('\\n')}\n\n\t}\n`;\n}\nfunction buildColor(color) {\n  return `(${color.r}, ${color.g}, ${color.b})`;\n}\nfunction buildColor4(color) {\n  return `(${color.r}, ${color.g}, ${color.b}, 1.0)`;\n}\nfunction buildVector2(vector) {\n  return `(${vector.x}, ${vector.y})`;\n}\nfunction buildCamera(camera) {\n  const name = camera.name ? camera.name : 'Camera_' + camera.id;\n  const transform = buildMatrix(camera.matrixWorld);\n  if (camera.matrixWorld.determinant() < 0) {\n    console.warn('THREE.USDZExporter: USDZ does not support negative scales', camera);\n  }\n  if (camera.isOrthographicCamera) {\n    return `def Camera \"${name}\"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${transform}\n\t\t\tuniform token[] xformOpOrder = [\"xformOp:transform\"]\n\n\t\t\tfloat2 clippingRange = (${camera.near.toPrecision(PRECISION)}, ${camera.far.toPrecision(PRECISION)})\n\t\t\tfloat horizontalAperture = ${((Math.abs(camera.left) + Math.abs(camera.right)) * 10).toPrecision(PRECISION)}\n\t\t\tfloat verticalAperture = ${((Math.abs(camera.top) + Math.abs(camera.bottom)) * 10).toPrecision(PRECISION)}\n\t\t\ttoken projection = \"orthographic\"\n\t\t}\n\t\n\t`;\n  } else {\n    return `def Camera \"${name}\"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${transform}\n\t\t\tuniform token[] xformOpOrder = [\"xformOp:transform\"]\n\n\t\t\tfloat2 clippingRange = (${camera.near.toPrecision(PRECISION)}, ${camera.far.toPrecision(PRECISION)})\n\t\t\tfloat focalLength = ${camera.getFocalLength().toPrecision(PRECISION)}\n\t\t\tfloat focusDistance = ${camera.focus.toPrecision(PRECISION)}\n\t\t\tfloat horizontalAperture = ${camera.getFilmWidth().toPrecision(PRECISION)}\n\t\t\ttoken projection = \"perspective\"\n\t\t\tfloat verticalAperture = ${camera.getFilmHeight().toPrecision(PRECISION)}\n\t\t}\n\t\n\t`;\n  }\n}\nexport { USDZExporter };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}