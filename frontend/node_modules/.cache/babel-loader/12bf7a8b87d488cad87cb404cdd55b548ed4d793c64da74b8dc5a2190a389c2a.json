{"ast":null,"code":"import { Loader, FileLoader, Vector3, DataTexture, UnsignedByteType, LinearFilter, ClampToEdgeWrapping } from \"three\";\nimport { Data3DTexture } from \"../_polyfill/Data3DTexture.js\";\nclass LUTCubeLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"text\");\n    loader.load(url, text => {\n      try {\n        onLoad(this.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        this.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(str) {\n    str = str.replace(/^#.*?(\\n|\\r)/gm, \"\").replace(/^\\s*?(\\n|\\r)/gm, \"\").trim();\n    let title = null;\n    let size = null;\n    const domainMin = new Vector3(0, 0, 0);\n    const domainMax = new Vector3(1, 1, 1);\n    const lines = str.split(/[\\n\\r]+/g);\n    let data = null;\n    let currIndex = 0;\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i].trim();\n      const split = line.split(/\\s/g);\n      switch (split[0]) {\n        case \"TITLE\":\n          title = line.substring(7, line.length - 1);\n          break;\n        case \"LUT_3D_SIZE\":\n          const sizeToken = split[1];\n          size = parseFloat(sizeToken);\n          data = new Uint8Array(size * size * size * 4);\n          break;\n        case \"DOMAIN_MIN\":\n          domainMin.x = parseFloat(split[1]);\n          domainMin.y = parseFloat(split[2]);\n          domainMin.z = parseFloat(split[3]);\n          break;\n        case \"DOMAIN_MAX\":\n          domainMax.x = parseFloat(split[1]);\n          domainMax.y = parseFloat(split[2]);\n          domainMax.z = parseFloat(split[3]);\n          break;\n        default:\n          const r = parseFloat(split[0]);\n          const g = parseFloat(split[1]);\n          const b = parseFloat(split[2]);\n          if (r > 1 || r < 0 || g > 1 || g < 0 || b > 1 || b < 0) {\n            throw new Error(\"LUTCubeLoader : Non normalized values not supported.\");\n          }\n          data[currIndex + 0] = r * 255;\n          data[currIndex + 1] = g * 255;\n          data[currIndex + 2] = b * 255;\n          data[currIndex + 3] = 255;\n          currIndex += 4;\n      }\n    }\n    const texture = new DataTexture();\n    texture.image.data = data;\n    texture.image.width = size;\n    texture.image.height = size * size;\n    texture.type = UnsignedByteType;\n    texture.magFilter = LinearFilter;\n    texture.minFilter = LinearFilter;\n    texture.wrapS = ClampToEdgeWrapping;\n    texture.wrapT = ClampToEdgeWrapping;\n    texture.generateMipmaps = false;\n    texture.needsUpdate = true;\n    const texture3D = new Data3DTexture();\n    texture3D.image.data = data;\n    texture3D.image.width = size;\n    texture3D.image.height = size;\n    texture3D.image.depth = size;\n    texture3D.type = UnsignedByteType;\n    texture3D.magFilter = LinearFilter;\n    texture3D.minFilter = LinearFilter;\n    texture3D.wrapS = ClampToEdgeWrapping;\n    texture3D.wrapT = ClampToEdgeWrapping;\n    texture3D.wrapR = ClampToEdgeWrapping;\n    texture3D.generateMipmaps = false;\n    texture3D.needsUpdate = true;\n    return {\n      title,\n      size,\n      domainMin,\n      domainMax,\n      texture,\n      texture3D\n    };\n  }\n}\nexport { LUTCubeLoader };\n//# sourceMappingURL=LUTCubeLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}