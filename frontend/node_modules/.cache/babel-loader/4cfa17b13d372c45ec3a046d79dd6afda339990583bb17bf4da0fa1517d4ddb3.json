{"ast":null,"code":"import { AnimationClip, AnimationMixer, Matrix4, Quaternion, QuaternionKeyframeTrack, SkeletonHelper, Vector3, VectorKeyframeTrack } from 'three';\nfunction getBoneName(bone, options) {\n  if (options.getBoneName !== undefined) {\n    return options.getBoneName(bone);\n  }\n  return options.names[bone.name];\n}\nfunction retarget(target, source, options = {}) {\n  const quat = new Quaternion(),\n    scale = new Vector3(),\n    relativeMatrix = new Matrix4(),\n    globalMatrix = new Matrix4();\n  options.preserveBoneMatrix = options.preserveBoneMatrix !== undefined ? options.preserveBoneMatrix : true;\n  options.preserveBonePositions = options.preserveBonePositions !== undefined ? options.preserveBonePositions : true;\n  options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n  options.hip = options.hip !== undefined ? options.hip : 'hip';\n  options.hipInfluence = options.hipInfluence !== undefined ? options.hipInfluence : new Vector3(1, 1, 1);\n  options.scale = options.scale !== undefined ? options.scale : 1;\n  options.names = options.names || {};\n  const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source),\n    bones = target.isObject3D ? target.skeleton.bones : getBones(target);\n  let bone, name, boneTo, bonesPosition;\n\n  // reset bones\n\n  if (target.isObject3D) {\n    target.skeleton.pose();\n  } else {\n    options.useTargetMatrix = true;\n    options.preserveBoneMatrix = false;\n  }\n  if (options.preserveBonePositions) {\n    bonesPosition = [];\n    for (let i = 0; i < bones.length; i++) {\n      bonesPosition.push(bones[i].position.clone());\n    }\n  }\n  if (options.preserveBoneMatrix) {\n    // reset matrix\n\n    target.updateMatrixWorld();\n    target.matrixWorld.identity();\n\n    // reset children matrix\n\n    for (let i = 0; i < target.children.length; ++i) {\n      target.children[i].updateMatrixWorld(true);\n    }\n  }\n  for (let i = 0; i < bones.length; ++i) {\n    bone = bones[i];\n    name = getBoneName(bone, options);\n    boneTo = getBoneByName(name, sourceBones);\n    globalMatrix.copy(bone.matrixWorld);\n    if (boneTo) {\n      boneTo.updateMatrixWorld();\n      if (options.useTargetMatrix) {\n        relativeMatrix.copy(boneTo.matrixWorld);\n      } else {\n        relativeMatrix.copy(target.matrixWorld).invert();\n        relativeMatrix.multiply(boneTo.matrixWorld);\n      }\n\n      // ignore scale to extract rotation\n\n      scale.setFromMatrixScale(relativeMatrix);\n      relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));\n\n      // apply to global matrix\n\n      globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n      if (target.isObject3D) {\n        if (options.localOffsets) {\n          if (options.localOffsets[bone.name]) {\n            globalMatrix.multiply(options.localOffsets[bone.name]);\n          }\n        }\n      }\n      globalMatrix.copyPosition(relativeMatrix);\n    }\n    if (name === options.hip) {\n      globalMatrix.elements[12] *= options.scale * options.hipInfluence.x;\n      globalMatrix.elements[13] *= options.scale * options.hipInfluence.y;\n      globalMatrix.elements[14] *= options.scale * options.hipInfluence.z;\n      if (options.hipPosition !== undefined) {\n        globalMatrix.elements[12] += options.hipPosition.x * options.scale;\n        globalMatrix.elements[13] += options.hipPosition.y * options.scale;\n        globalMatrix.elements[14] += options.hipPosition.z * options.scale;\n      }\n    }\n    if (bone.parent) {\n      bone.matrix.copy(bone.parent.matrixWorld).invert();\n      bone.matrix.multiply(globalMatrix);\n    } else {\n      bone.matrix.copy(globalMatrix);\n    }\n    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n    bone.updateMatrixWorld();\n  }\n  if (options.preserveBonePositions) {\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = getBoneName(bone, options) || bone.name;\n      if (name !== options.hip) {\n        bone.position.copy(bonesPosition[i]);\n      }\n    }\n  }\n  if (options.preserveBoneMatrix) {\n    // restore matrix\n\n    target.updateMatrixWorld(true);\n  }\n}\nfunction retargetClip(target, source, clip, options = {}) {\n  options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n\n  // Calculate the fps from the source clip based on the track with the most frames, unless fps is already provided.\n  options.fps = options.fps !== undefined ? options.fps : Math.max(...clip.tracks.map(track => track.times.length)) / clip.duration;\n  options.names = options.names || [];\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source);\n  }\n  const numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n    delta = clip.duration / (numFrames - 1),\n    convertedTracks = [],\n    mixer = new AnimationMixer(source),\n    bones = getBones(target.skeleton),\n    boneDatas = [];\n  let positionOffset, bone, boneTo, boneData, name;\n  mixer.clipAction(clip).play();\n\n  // trim\n\n  let start = 0,\n    end = numFrames;\n  if (options.trim !== undefined) {\n    start = Math.round(options.trim[0] * options.fps);\n    end = Math.min(Math.round(options.trim[1] * options.fps), numFrames) - start;\n    mixer.update(options.trim[0]);\n  } else {\n    mixer.update(0);\n  }\n  source.updateMatrixWorld();\n\n  //\n\n  for (let frame = 0; frame < end; ++frame) {\n    const time = frame * delta;\n    retarget(target, source, options);\n    for (let j = 0; j < bones.length; ++j) {\n      bone = bones[j];\n      name = getBoneName(bone, options) || bone.name;\n      boneTo = getBoneByName(name, source.skeleton);\n      if (boneTo) {\n        boneData = boneDatas[j] = boneDatas[j] || {\n          bone: bone\n        };\n        if (options.hip === name) {\n          if (!boneData.pos) {\n            boneData.pos = {\n              times: new Float32Array(end),\n              values: new Float32Array(end * 3)\n            };\n          }\n          if (options.useFirstFramePosition) {\n            if (frame === 0) {\n              positionOffset = bone.position.clone();\n            }\n            bone.position.sub(positionOffset);\n          }\n          boneData.pos.times[frame] = time;\n          bone.position.toArray(boneData.pos.values, frame * 3);\n        }\n        if (!boneData.quat) {\n          boneData.quat = {\n            times: new Float32Array(end),\n            values: new Float32Array(end * 4)\n          };\n        }\n        boneData.quat.times[frame] = time;\n        bone.quaternion.toArray(boneData.quat.values, frame * 4);\n      }\n    }\n    if (frame === end - 2) {\n      // last mixer update before final loop iteration\n      // make sure we do not go over or equal to clip duration\n      mixer.update(delta - 0.0000001);\n    } else {\n      mixer.update(delta);\n    }\n    source.updateMatrixWorld();\n  }\n  for (let i = 0; i < boneDatas.length; ++i) {\n    boneData = boneDatas[i];\n    if (boneData) {\n      if (boneData.pos) {\n        convertedTracks.push(new VectorKeyframeTrack('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));\n      }\n      convertedTracks.push(new QuaternionKeyframeTrack('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));\n    }\n  }\n  mixer.uncacheAction(clip);\n  return new AnimationClip(clip.name, -1, convertedTracks);\n}\nfunction clone(source) {\n  const sourceLookup = new Map();\n  const cloneLookup = new Map();\n  const clone = source.clone();\n  parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n    sourceLookup.set(clonedNode, sourceNode);\n    cloneLookup.set(sourceNode, clonedNode);\n  });\n  clone.traverse(function (node) {\n    if (!node.isSkinnedMesh) return;\n    const clonedMesh = node;\n    const sourceMesh = sourceLookup.get(node);\n    const sourceBones = sourceMesh.skeleton.bones;\n    clonedMesh.skeleton = sourceMesh.skeleton.clone();\n    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n    clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n      return cloneLookup.get(bone);\n    });\n    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n  });\n  return clone;\n}\n\n// internal helper\n\nfunction getBoneByName(name, skeleton) {\n  for (let i = 0, bones = getBones(skeleton); i < bones.length; i++) {\n    if (name === bones[i].name) return bones[i];\n  }\n}\nfunction getBones(skeleton) {\n  return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n}\nfunction getHelperFromSkeleton(skeleton) {\n  const source = new SkeletonHelper(skeleton.bones[0]);\n  source.skeleton = skeleton;\n  return source;\n}\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\nexport { retarget, retargetClip, clone };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}