{"ast":null,"code":"/**\n * NFT.Storage Upload Handler\n * Using hardcoded collection ID for consistency\n */\n\nconst NFT_STORAGE_KEY = process.env.REACT_APP_NFT_STORAGE_KEY;\nconst API_BASE = 'https://preserve.nft.storage/api/v1';\nconst COLLECTION_ID = \"1\"; // Hardcoded collection ID\n\n// Validate API key\nif (!(NFT_STORAGE_KEY !== null && NFT_STORAGE_KEY !== void 0 && NFT_STORAGE_KEY.trim())) {\n  throw new Error('NFT Storage API key is required');\n}\n\n/**\n * Uploads content to IPFS via NFT.Storage\n */\nexport const uploadToIPFS = async (glbUrl, originalNFT) => {\n  try {\n    console.log('Starting upload process...');\n    console.log('Using hardcoded collection ID:', COLLECTION_ID);\n\n    // Fetch GLB\n    const glbResponse = await fetch(glbUrl);\n    if (!glbResponse.ok) {\n      throw new Error(`Failed to fetch GLB: ${glbResponse.status}`);\n    }\n    const glbBlob = await glbResponse.blob();\n    console.log('GLB file fetched:', {\n      size: glbBlob.size,\n      type: glbBlob.type\n    });\n\n    // Create CSV content for token\n    const tokenId = Date.now().toString();\n    const csvContent = `tokenID,cid\\n${tokenId},pending_${tokenId}`;\n\n    // Prepare upload\n    const formData = new FormData();\n    formData.append('collectionID', COLLECTION_ID);\n    formData.append('file', new Blob([csvContent], {\n      type: 'text/csv'\n    }), 'token.csv');\n    console.log('Uploading to collection #1 with tokenId:', tokenId);\n\n    // Upload to NFT.Storage\n    const uploadResponse = await fetch(`${API_BASE}/collection/add_tokens`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${NFT_STORAGE_KEY.trim()}`,\n        'Accept': 'application/json'\n      },\n      body: formData\n    });\n    if (!uploadResponse.ok) {\n      const error = await uploadResponse.json();\n      console.error('Upload failed:', {\n        status: uploadResponse.status,\n        error\n      });\n      throw new Error(`Upload failed: ${JSON.stringify(error)}`);\n    }\n    const result = await uploadResponse.json();\n    console.log('Upload successful:', result);\n    return `ipfs://${result.cid || tokenId}`;\n  } catch (error) {\n    console.error('Upload process failed:', {\n      name: error.name,\n      message: error.message,\n      stack: error.stack\n    });\n    throw error;\n  }\n};","map":{"version":3,"names":["NFT_STORAGE_KEY","process","env","REACT_APP_NFT_STORAGE_KEY","API_BASE","COLLECTION_ID","trim","Error","uploadToIPFS","glbUrl","originalNFT","console","log","glbResponse","fetch","ok","status","glbBlob","blob","size","type","tokenId","Date","now","toString","csvContent","formData","FormData","append","Blob","uploadResponse","method","headers","body","error","json","JSON","stringify","result","cid","name","message","stack"],"sources":["/Users/thomasheindl/Documents/beamitai01/beamitai/frontend/src/utils/ipfsHandler.js"],"sourcesContent":["/**\n * NFT.Storage Upload Handler\n * Using hardcoded collection ID for consistency\n */\n\nconst NFT_STORAGE_KEY = process.env.REACT_APP_NFT_STORAGE_KEY;\nconst API_BASE = 'https://preserve.nft.storage/api/v1';\nconst COLLECTION_ID = \"1\";  // Hardcoded collection ID\n\n// Validate API key\nif (!NFT_STORAGE_KEY?.trim()) {\n    throw new Error('NFT Storage API key is required');\n}\n\n/**\n * Uploads content to IPFS via NFT.Storage\n */\nexport const uploadToIPFS = async (glbUrl, originalNFT) => {\n    try {\n        console.log('Starting upload process...');\n        console.log('Using hardcoded collection ID:', COLLECTION_ID);\n\n        // Fetch GLB\n        const glbResponse = await fetch(glbUrl);\n        if (!glbResponse.ok) {\n            throw new Error(`Failed to fetch GLB: ${glbResponse.status}`);\n        }\n        \n        const glbBlob = await glbResponse.blob();\n        console.log('GLB file fetched:', {\n            size: glbBlob.size,\n            type: glbBlob.type\n        });\n\n        // Create CSV content for token\n        const tokenId = Date.now().toString();\n        const csvContent = `tokenID,cid\\n${tokenId},pending_${tokenId}`;\n        \n        // Prepare upload\n        const formData = new FormData();\n        formData.append('collectionID', COLLECTION_ID);\n        formData.append('file', new Blob([csvContent], { type: 'text/csv' }), 'token.csv');\n\n        console.log('Uploading to collection #1 with tokenId:', tokenId);\n\n        // Upload to NFT.Storage\n        const uploadResponse = await fetch(`${API_BASE}/collection/add_tokens`, {\n            method: 'POST',\n            headers: {\n                'Authorization': `Bearer ${NFT_STORAGE_KEY.trim()}`,\n                'Accept': 'application/json'\n            },\n            body: formData\n        });\n\n        if (!uploadResponse.ok) {\n            const error = await uploadResponse.json();\n            console.error('Upload failed:', {\n                status: uploadResponse.status,\n                error\n            });\n            throw new Error(`Upload failed: ${JSON.stringify(error)}`);\n        }\n\n        const result = await uploadResponse.json();\n        console.log('Upload successful:', result);\n\n        return `ipfs://${result.cid || tokenId}`;\n\n    } catch (error) {\n        console.error('Upload process failed:', {\n            name: error.name,\n            message: error.message,\n            stack: error.stack\n        });\n        throw error;\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,MAAMA,eAAe,GAAGC,OAAO,CAACC,GAAG,CAACC,yBAAyB;AAC7D,MAAMC,QAAQ,GAAG,qCAAqC;AACtD,MAAMC,aAAa,GAAG,GAAG,CAAC,CAAE;;AAE5B;AACA,IAAI,EAACL,eAAe,aAAfA,eAAe,eAAfA,eAAe,CAAEM,IAAI,CAAC,CAAC,GAAE;EAC1B,MAAM,IAAIC,KAAK,CAAC,iCAAiC,CAAC;AACtD;;AAEA;AACA;AACA;AACA,OAAO,MAAMC,YAAY,GAAG,MAAAA,CAAOC,MAAM,EAAEC,WAAW,KAAK;EACvD,IAAI;IACAC,OAAO,CAACC,GAAG,CAAC,4BAA4B,CAAC;IACzCD,OAAO,CAACC,GAAG,CAAC,gCAAgC,EAAEP,aAAa,CAAC;;IAE5D;IACA,MAAMQ,WAAW,GAAG,MAAMC,KAAK,CAACL,MAAM,CAAC;IACvC,IAAI,CAACI,WAAW,CAACE,EAAE,EAAE;MACjB,MAAM,IAAIR,KAAK,CAAC,wBAAwBM,WAAW,CAACG,MAAM,EAAE,CAAC;IACjE;IAEA,MAAMC,OAAO,GAAG,MAAMJ,WAAW,CAACK,IAAI,CAAC,CAAC;IACxCP,OAAO,CAACC,GAAG,CAAC,mBAAmB,EAAE;MAC7BO,IAAI,EAAEF,OAAO,CAACE,IAAI;MAClBC,IAAI,EAAEH,OAAO,CAACG;IAClB,CAAC,CAAC;;IAEF;IACA,MAAMC,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC;IACrC,MAAMC,UAAU,GAAG,gBAAgBJ,OAAO,YAAYA,OAAO,EAAE;;IAE/D;IACA,MAAMK,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;IAC/BD,QAAQ,CAACE,MAAM,CAAC,cAAc,EAAEvB,aAAa,CAAC;IAC9CqB,QAAQ,CAACE,MAAM,CAAC,MAAM,EAAE,IAAIC,IAAI,CAAC,CAACJ,UAAU,CAAC,EAAE;MAAEL,IAAI,EAAE;IAAW,CAAC,CAAC,EAAE,WAAW,CAAC;IAElFT,OAAO,CAACC,GAAG,CAAC,0CAA0C,EAAES,OAAO,CAAC;;IAEhE;IACA,MAAMS,cAAc,GAAG,MAAMhB,KAAK,CAAC,GAAGV,QAAQ,wBAAwB,EAAE;MACpE2B,MAAM,EAAE,MAAM;MACdC,OAAO,EAAE;QACL,eAAe,EAAE,UAAUhC,eAAe,CAACM,IAAI,CAAC,CAAC,EAAE;QACnD,QAAQ,EAAE;MACd,CAAC;MACD2B,IAAI,EAAEP;IACV,CAAC,CAAC;IAEF,IAAI,CAACI,cAAc,CAACf,EAAE,EAAE;MACpB,MAAMmB,KAAK,GAAG,MAAMJ,cAAc,CAACK,IAAI,CAAC,CAAC;MACzCxB,OAAO,CAACuB,KAAK,CAAC,gBAAgB,EAAE;QAC5BlB,MAAM,EAAEc,cAAc,CAACd,MAAM;QAC7BkB;MACJ,CAAC,CAAC;MACF,MAAM,IAAI3B,KAAK,CAAC,kBAAkB6B,IAAI,CAACC,SAAS,CAACH,KAAK,CAAC,EAAE,CAAC;IAC9D;IAEA,MAAMI,MAAM,GAAG,MAAMR,cAAc,CAACK,IAAI,CAAC,CAAC;IAC1CxB,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAE0B,MAAM,CAAC;IAEzC,OAAO,UAAUA,MAAM,CAACC,GAAG,IAAIlB,OAAO,EAAE;EAE5C,CAAC,CAAC,OAAOa,KAAK,EAAE;IACZvB,OAAO,CAACuB,KAAK,CAAC,wBAAwB,EAAE;MACpCM,IAAI,EAAEN,KAAK,CAACM,IAAI;MAChBC,OAAO,EAAEP,KAAK,CAACO,OAAO;MACtBC,KAAK,EAAER,KAAK,CAACQ;IACjB,CAAC,CAAC;IACF,MAAMR,KAAK;EACf;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}