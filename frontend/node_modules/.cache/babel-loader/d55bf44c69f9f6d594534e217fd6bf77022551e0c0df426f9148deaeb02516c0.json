{"ast":null,"code":"import { Object3D, MeshBasicMaterial, MathUtils, Mesh } from \"three\";\nimport { LightningStrike } from \"../geometries/LightningStrike.js\";\nclass LightningStorm extends Object3D {\n  constructor(stormParams = {}) {\n    super();\n    this.isLightningStorm = true;\n    this.stormParams = stormParams;\n    stormParams.size = stormParams.size !== void 0 ? stormParams.size : 1e3;\n    stormParams.minHeight = stormParams.minHeight !== void 0 ? stormParams.minHeight : 80;\n    stormParams.maxHeight = stormParams.maxHeight !== void 0 ? stormParams.maxHeight : 100;\n    stormParams.maxSlope = stormParams.maxSlope !== void 0 ? stormParams.maxSlope : 1.1;\n    stormParams.maxLightnings = stormParams.maxLightnings !== void 0 ? stormParams.maxLightnings : 3;\n    stormParams.lightningMinPeriod = stormParams.lightningMinPeriod !== void 0 ? stormParams.lightningMinPeriod : 3;\n    stormParams.lightningMaxPeriod = stormParams.lightningMaxPeriod !== void 0 ? stormParams.lightningMaxPeriod : 7;\n    stormParams.lightningMinDuration = stormParams.lightningMinDuration !== void 0 ? stormParams.lightningMinDuration : 1;\n    stormParams.lightningMaxDuration = stormParams.lightningMaxDuration !== void 0 ? stormParams.lightningMaxDuration : 2.5;\n    this.lightningParameters = LightningStrike.copyParameters(stormParams.lightningParameters, stormParams.lightningParameters);\n    this.lightningParameters.isEternal = false;\n    this.lightningMaterial = stormParams.lightningMaterial !== void 0 ? stormParams.lightningMaterial : new MeshBasicMaterial({\n      color: 11599871\n    });\n    if (stormParams.onRayPosition !== void 0) {\n      this.onRayPosition = stormParams.onRayPosition;\n    } else {\n      this.onRayPosition = function (source, dest) {\n        dest.set((Math.random() - 0.5) * stormParams.size, 0, (Math.random() - 0.5) * stormParams.size);\n        const height = MathUtils.lerp(stormParams.minHeight, stormParams.maxHeight, Math.random());\n        source.set(stormParams.maxSlope * (2 * Math.random() - 1), 1, stormParams.maxSlope * (2 * Math.random() - 1)).multiplyScalar(height).add(dest);\n      };\n    }\n    this.onLightningDown = stormParams.onLightningDown;\n    this.inited = false;\n    this.nextLightningTime = 0;\n    this.lightningsMeshes = [];\n    this.deadLightningsMeshes = [];\n    for (let i = 0; i < this.stormParams.maxLightnings; i++) {\n      const lightning = new LightningStrike(LightningStrike.copyParameters({}, this.lightningParameters));\n      const mesh = new Mesh(lightning, this.lightningMaterial);\n      this.deadLightningsMeshes.push(mesh);\n    }\n  }\n  update(time) {\n    if (!this.inited) {\n      this.nextLightningTime = this.getNextLightningTime(time) * Math.random();\n      this.inited = true;\n    }\n    if (time >= this.nextLightningTime) {\n      const lightningMesh = this.deadLightningsMeshes.pop();\n      if (lightningMesh) {\n        const lightningParams1 = LightningStrike.copyParameters(lightningMesh.geometry.rayParameters, this.lightningParameters);\n        lightningParams1.birthTime = time;\n        lightningParams1.deathTime = time + MathUtils.lerp(this.stormParams.lightningMinDuration, this.stormParams.lightningMaxDuration, Math.random());\n        this.onRayPosition(lightningParams1.sourceOffset, lightningParams1.destOffset);\n        lightningParams1.noiseSeed = Math.random();\n        this.add(lightningMesh);\n        this.lightningsMeshes.push(lightningMesh);\n      }\n      this.nextLightningTime = this.getNextLightningTime(time);\n    }\n    let i = 0,\n      il = this.lightningsMeshes.length;\n    while (i < il) {\n      const mesh = this.lightningsMeshes[i];\n      const lightning = mesh.geometry;\n      const prevState = lightning.state;\n      lightning.update(time);\n      if (prevState === LightningStrike.RAY_PROPAGATING && lightning.state > prevState) {\n        if (this.onLightningDown) {\n          this.onLightningDown(lightning);\n        }\n      }\n      if (lightning.state === LightningStrike.RAY_EXTINGUISHED) {\n        this.lightningsMeshes.splice(this.lightningsMeshes.indexOf(mesh), 1);\n        this.deadLightningsMeshes.push(mesh);\n        this.remove(mesh);\n        il--;\n      } else {\n        i++;\n      }\n    }\n  }\n  getNextLightningTime(currentTime) {\n    return currentTime + MathUtils.lerp(this.stormParams.lightningMinPeriod, this.stormParams.lightningMaxPeriod, Math.random()) / (this.stormParams.maxLightnings + 1);\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.stormParams.size = source.stormParams.size;\n    this.stormParams.minHeight = source.stormParams.minHeight;\n    this.stormParams.maxHeight = source.stormParams.maxHeight;\n    this.stormParams.maxSlope = source.stormParams.maxSlope;\n    this.stormParams.maxLightnings = source.stormParams.maxLightnings;\n    this.stormParams.lightningMinPeriod = source.stormParams.lightningMinPeriod;\n    this.stormParams.lightningMaxPeriod = source.stormParams.lightningMaxPeriod;\n    this.stormParams.lightningMinDuration = source.stormParams.lightningMinDuration;\n    this.stormParams.lightningMaxDuration = source.stormParams.lightningMaxDuration;\n    this.lightningParameters = LightningStrike.copyParameters({}, source.lightningParameters);\n    this.lightningMaterial = source.stormParams.lightningMaterial;\n    this.onLightningDown = source.onLightningDown;\n    return this;\n  }\n  clone() {\n    return new this.constructor(this.stormParams).copy(this);\n  }\n}\nexport { LightningStorm };\n//# sourceMappingURL=LightningStorm.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}