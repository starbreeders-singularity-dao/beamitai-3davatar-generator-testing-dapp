{"ast":null,"code":"/* @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @param object {THREE.Object3D}\n * @return {boolean}\n */\nconst compatibleObject = object => {\n  // @TODO: Need properer variantMaterials format validation?\n  return object.material !== undefined &&\n  // easier than (!object.isMesh && !object.isLine &&\n  // !object.isPoints)\n  object.userData &&\n  // just in case\n  object.userData.variantMaterials &&\n  // Is this line costly?\n  !!Array.from(object.userData.variantMaterials.values()).filter(m => compatibleMaterial(m.material));\n};\n/**\n * @param material {THREE.Material}\n * @return {boolean}\n */\nconst compatibleMaterial = material => {\n  // @TODO: support multi materials?\n  return material && material.isMaterial && !Array.isArray(material);\n};\nexport default class GLTFExporterMaterialsVariantsExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_variants';\n    this.variantNames = [];\n  }\n  beforeParse(objects) {\n    // Find all variant names and store them to the table\n    const variantNameSet = new Set();\n    for (const object of objects) {\n      object.traverse(o => {\n        if (!compatibleObject(o)) {\n          return;\n        }\n        const variantMaterials = o.userData.variantMaterials;\n        const variantDataMap = o.userData.variantData;\n        for (const [variantName, variantData] of variantDataMap) {\n          const variantMaterial = variantMaterials.get(variantData.index);\n          // Ignore unloaded variant materials\n          if (variantMaterial && compatibleMaterial(variantMaterial.material)) {\n            variantNameSet.add(variantName);\n          }\n        }\n      });\n    }\n    // We may want to sort?\n    variantNameSet.forEach(name => this.variantNames.push(name));\n  }\n  writeMesh(mesh, meshDef) {\n    if (!compatibleObject(mesh)) {\n      return;\n    }\n    const userData = mesh.userData;\n    const variantMaterials = userData.variantMaterials;\n    const variantDataMap = userData.variantData;\n    const mappingTable = new Map();\n    // Removes gaps in the variant indices list (caused by deleting variants).\n    const reIndexedVariants = new Map();\n    const variants = Array.from(variantDataMap.values()).sort((a, b) => {\n      return a.index - b.index;\n    });\n    for (const [i, variantData] of variants.entries()) {\n      reIndexedVariants.set(variantData.index, i);\n    }\n    for (const variantData of variantDataMap.values()) {\n      const variantInstance = variantMaterials.get(variantData.index);\n      if (!variantInstance || !compatibleMaterial(variantInstance.material)) {\n        continue;\n      }\n      const materialIndex = this.writer.processMaterial(variantInstance.material);\n      if (!mappingTable.has(materialIndex)) {\n        mappingTable.set(materialIndex, {\n          material: materialIndex,\n          variants: []\n        });\n      }\n      mappingTable.get(materialIndex).variants.push(reIndexedVariants.get(variantData.index));\n    }\n    const mappingsDef = Array.from(mappingTable.values()).map(m => {\n      return m.variants.sort((a, b) => a - b) && m;\n    }).sort((a, b) => a.material - b.material);\n    if (mappingsDef.length === 0) {\n      return;\n    }\n    const originalMaterialIndex = compatibleMaterial(userData.originalMaterial) ? this.writer.processMaterial(userData.originalMaterial) : -1;\n    for (const primitiveDef of meshDef.primitives) {\n      // Override primitiveDef.material with original material.\n      if (originalMaterialIndex >= 0) {\n        primitiveDef.material = originalMaterialIndex;\n      }\n      primitiveDef.extensions = primitiveDef.extensions || {};\n      primitiveDef.extensions[this.name] = {\n        mappings: mappingsDef\n      };\n    }\n  }\n  afterParse() {\n    if (this.variantNames.length === 0) {\n      return;\n    }\n    const root = this.writer.json;\n    root.extensions = root.extensions || {};\n    const variantsDef = this.variantNames.map(n => {\n      return {\n        name: n\n      };\n    });\n    root.extensions[this.name] = {\n      variants: variantsDef\n    };\n    this.writer.extensionsUsed[this.name] = true;\n  }\n}\n//# sourceMappingURL=VariantMaterialExporterPlugin.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}