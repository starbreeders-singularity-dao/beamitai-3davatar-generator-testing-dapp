{"ast":null,"code":"import { Loader, FileLoader } from \"three\";\nimport { parse as parseBuffer } from \"../libs/opentype.js\";\nclass TTFLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.reversed = false;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (buffer) {\n      try {\n        onLoad(parseBuffer(buffer));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(arraybuffer) {\n    function convert(font, reversed) {\n      const round = Math.round;\n      const glyphs = {};\n      const scale = 1e5 / ((font.unitsPerEm || 2048) * 72);\n      const glyphIndexMap = font.encoding.cmap.glyphIndexMap;\n      const unicodes = Object.keys(glyphIndexMap);\n      for (let i = 0; i < unicodes.length; i++) {\n        const unicode = unicodes[i];\n        const glyph = font.glyphs.glyphs[glyphIndexMap[unicode]];\n        if (unicode !== void 0) {\n          const token = {\n            ha: round(glyph.advanceWidth * scale),\n            x_min: round(glyph.xMin * scale),\n            x_max: round(glyph.xMax * scale),\n            o: \"\"\n          };\n          if (reversed) {\n            glyph.path.commands = reverseCommands(glyph.path.commands);\n          }\n          glyph.path.commands.forEach(function (command) {\n            if (command.type.toLowerCase() === \"c\") {\n              command.type = \"b\";\n            }\n            token.o += command.type.toLowerCase() + \" \";\n            if (command.x !== void 0 && command.y !== void 0) {\n              token.o += round(command.x * scale) + \" \" + round(command.y * scale) + \" \";\n            }\n            if (command.x1 !== void 0 && command.y1 !== void 0) {\n              token.o += round(command.x1 * scale) + \" \" + round(command.y1 * scale) + \" \";\n            }\n            if (command.x2 !== void 0 && command.y2 !== void 0) {\n              token.o += round(command.x2 * scale) + \" \" + round(command.y2 * scale) + \" \";\n            }\n          });\n          glyphs[String.fromCodePoint(glyph.unicode)] = token;\n        }\n      }\n      return {\n        glyphs,\n        familyName: font.getEnglishName(\"fullName\"),\n        ascender: round(font.ascender * scale),\n        descender: round(font.descender * scale),\n        underlinePosition: font.tables.post.underlinePosition,\n        underlineThickness: font.tables.post.underlineThickness,\n        boundingBox: {\n          xMin: font.tables.head.xMin,\n          xMax: font.tables.head.xMax,\n          yMin: font.tables.head.yMin,\n          yMax: font.tables.head.yMax\n        },\n        resolution: 1e3,\n        original_font_information: font.tables.name\n      };\n    }\n    function reverseCommands(commands) {\n      const paths = [];\n      let path;\n      commands.forEach(function (c) {\n        if (c.type.toLowerCase() === \"m\") {\n          path = [c];\n          paths.push(path);\n        } else if (c.type.toLowerCase() !== \"z\") {\n          path.push(c);\n        }\n      });\n      const reversed = [];\n      paths.forEach(function (p) {\n        const result = {\n          type: \"m\",\n          x: p[p.length - 1].x,\n          y: p[p.length - 1].y\n        };\n        reversed.push(result);\n        for (let i = p.length - 1; i > 0; i--) {\n          const command = p[i];\n          const result2 = {\n            type: command.type\n          };\n          if (command.x2 !== void 0 && command.y2 !== void 0) {\n            result2.x1 = command.x2;\n            result2.y1 = command.y2;\n            result2.x2 = command.x1;\n            result2.y2 = command.y1;\n          } else if (command.x1 !== void 0 && command.y1 !== void 0) {\n            result2.x1 = command.x1;\n            result2.y1 = command.y1;\n          }\n          result2.x = p[i - 1].x;\n          result2.y = p[i - 1].y;\n          reversed.push(result2);\n        }\n      });\n      return reversed;\n    }\n    return convert(parseBuffer(arraybuffer), this.reversed);\n  }\n}\nexport { TTFLoader };\n//# sourceMappingURL=TTFLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}