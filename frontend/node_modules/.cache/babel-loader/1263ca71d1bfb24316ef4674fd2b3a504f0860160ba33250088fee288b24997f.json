{"ast":null,"code":"import { InvalidResponseError } from 'web3-errors';\nexport class ChunkResponseParser {\n  constructor(eventEmitter, autoReconnect) {\n    this.eventEmitter = eventEmitter;\n    this.autoReconnect = autoReconnect;\n    this.chunkTimeout = 1000 * 15;\n  }\n  clearQueues() {\n    if (typeof this._clearQueues === 'function') {\n      this._clearQueues();\n    }\n  }\n  onError(clearQueues) {\n    this._clearQueues = clearQueues;\n  }\n  parseResponse(data) {\n    const returnValues = [];\n    // DE-CHUNKER\n    const dechunkedData = data.replace(/\\}[\\n\\r]?\\{/g, '}|--|{') // }{\n    .replace(/\\}\\][\\n\\r]?\\[\\{/g, '}]|--|[{') // }][{\n    .replace(/\\}[\\n\\r]?\\[\\{/g, '}|--|[{') // }[{\n    .replace(/\\}\\][\\n\\r]?\\{/g, '}]|--|{') // }]{\n    .split('|--|');\n    dechunkedData.forEach(_chunkData => {\n      // prepend the last chunk\n      let chunkData = _chunkData;\n      if (this.lastChunk) {\n        chunkData = this.lastChunk + chunkData;\n      }\n      let result;\n      try {\n        result = JSON.parse(chunkData);\n      } catch (e) {\n        this.lastChunk = chunkData;\n        // start timeout to cancel all requests\n        if (this.lastChunkTimeout) {\n          clearTimeout(this.lastChunkTimeout);\n        }\n        this.lastChunkTimeout = setTimeout(() => {\n          if (this.autoReconnect) return;\n          this.clearQueues();\n          this.eventEmitter.emit('error', new InvalidResponseError({\n            id: 1,\n            jsonrpc: '2.0',\n            error: {\n              code: 2,\n              message: 'Chunk timeout'\n            }\n          }));\n        }, this.chunkTimeout);\n        return;\n      }\n      // cancel timeout and set chunk to null\n      clearTimeout(this.lastChunkTimeout);\n      this.lastChunk = undefined;\n      if (result) returnValues.push(result);\n    });\n    return returnValues;\n  }\n}\n//# sourceMappingURL=chunk_response_parser.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}