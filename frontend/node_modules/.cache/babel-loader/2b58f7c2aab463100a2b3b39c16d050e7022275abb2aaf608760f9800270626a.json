{"ast":null,"code":"import { Loader, FileLoader, BufferGeometry, BufferAttribute } from \"three\";\nlet bigEndianPlatform = null;\nfunction isBigEndianPlatform() {\n  if (bigEndianPlatform === null) {\n    const buffer = new ArrayBuffer(2),\n      uint8Array = new Uint8Array(buffer),\n      uint16Array = new Uint16Array(buffer);\n    uint8Array[0] = 170;\n    uint8Array[1] = 187;\n    bigEndianPlatform = uint16Array[0] === 43707;\n  }\n  return bigEndianPlatform;\n}\nconst InvertedEncodingTypes = [null, Float32Array, null, Int8Array, Int16Array, null, Int32Array, Uint8Array, Uint16Array, null, Uint32Array];\nconst getMethods = {\n  Uint16Array: \"getUint16\",\n  Uint32Array: \"getUint32\",\n  Int16Array: \"getInt16\",\n  Int32Array: \"getInt32\",\n  Float32Array: \"getFloat32\",\n  Float64Array: \"getFloat64\"\n};\nfunction copyFromBuffer(sourceArrayBuffer, viewType, position, length, fromBigEndian) {\n  const bytesPerElement = viewType.BYTES_PER_ELEMENT;\n  let result;\n  if (fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1) {\n    result = new viewType(sourceArrayBuffer, position, length);\n  } else {\n    const readView = new DataView(sourceArrayBuffer, position, length * bytesPerElement),\n      getMethod = getMethods[viewType.name],\n      littleEndian = !fromBigEndian;\n    result = new viewType(length);\n    for (let i = 0; i < length; i++) {\n      result[i] = readView[getMethod](i * bytesPerElement, littleEndian);\n    }\n  }\n  return result;\n}\nfunction decodePrwm(buffer) {\n  const array = new Uint8Array(buffer),\n    version = array[0];\n  let flags = array[1];\n  const indexedGeometry = !!(flags >> 7 & 1),\n    indicesType = flags >> 6 & 1,\n    bigEndian = (flags >> 5 & 1) === 1,\n    attributesNumber = flags & 31;\n  let valuesNumber = 0,\n    indicesNumber = 0;\n  if (bigEndian) {\n    valuesNumber = (array[2] << 16) + (array[3] << 8) + array[4];\n    indicesNumber = (array[5] << 16) + (array[6] << 8) + array[7];\n  } else {\n    valuesNumber = array[2] + (array[3] << 8) + (array[4] << 16);\n    indicesNumber = array[5] + (array[6] << 8) + (array[7] << 16);\n  }\n  if (version === 0) {\n    throw new Error(\"PRWM decoder: Invalid format version: 0\");\n  } else if (version !== 1) {\n    throw new Error(\"PRWM decoder: Unsupported format version: \" + version);\n  }\n  if (!indexedGeometry) {\n    if (indicesType !== 0) {\n      throw new Error(\"PRWM decoder: Indices type must be set to 0 for non-indexed geometries\");\n    } else if (indicesNumber !== 0) {\n      throw new Error(\"PRWM decoder: Number of indices must be set to 0 for non-indexed geometries\");\n    }\n  }\n  let pos = 8;\n  const attributes = {};\n  for (let i = 0; i < attributesNumber; i++) {\n    let attributeName = \"\";\n    while (pos < array.length) {\n      const char = array[pos];\n      pos++;\n      if (char === 0) {\n        break;\n      } else {\n        attributeName += String.fromCharCode(char);\n      }\n    }\n    flags = array[pos];\n    const attributeType = flags >> 7 & 1;\n    const cardinality = (flags >> 4 & 3) + 1;\n    const encodingType = flags & 15;\n    const arrayType = InvertedEncodingTypes[encodingType];\n    pos++;\n    pos = Math.ceil(pos / 4) * 4;\n    const values = copyFromBuffer(buffer, arrayType, pos, cardinality * valuesNumber, bigEndian);\n    pos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;\n    attributes[attributeName] = {\n      type: attributeType,\n      cardinality,\n      values\n    };\n  }\n  pos = Math.ceil(pos / 4) * 4;\n  let indices = null;\n  if (indexedGeometry) {\n    indices = copyFromBuffer(buffer, indicesType === 1 ? Uint32Array : Uint16Array, pos, indicesNumber, bigEndian);\n  }\n  return {\n    version,\n    attributes,\n    indices\n  };\n}\nclass PRWMLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    url = url.replace(/\\*/g, isBigEndianPlatform() ? \"be\" : \"le\");\n    loader.load(url, function (arrayBuffer) {\n      try {\n        onLoad(scope.parse(arrayBuffer));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(arrayBuffer) {\n    const data = decodePrwm(arrayBuffer),\n      attributesKey = Object.keys(data.attributes),\n      bufferGeometry = new BufferGeometry();\n    for (let i = 0; i < attributesKey.length; i++) {\n      const attribute = data.attributes[attributesKey[i]];\n      bufferGeometry.setAttribute(attributesKey[i], new BufferAttribute(attribute.values, attribute.cardinality, attribute.normalized));\n    }\n    if (data.indices !== null) {\n      bufferGeometry.setIndex(new BufferAttribute(data.indices, 1));\n    }\n    return bufferGeometry;\n  }\n  static isBigEndianPlatform() {\n    return isBigEndianPlatform();\n  }\n}\nexport { PRWMLoader };\n//# sourceMappingURL=PRWMLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}