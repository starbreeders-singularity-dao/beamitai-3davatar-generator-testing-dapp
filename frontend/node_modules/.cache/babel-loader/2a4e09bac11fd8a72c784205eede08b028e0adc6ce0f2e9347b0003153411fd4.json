{"ast":null,"code":"import { Vector3, Color, SphericalHarmonics3, LightProbe } from \"three\";\nclass LightProbeGenerator {\n  // https://www.ppsloan.org/publications/StupidSH36.pdf\n  static fromCubeTexture(cubeTexture) {\n    let totalWeight = 0;\n    const coord = new Vector3();\n    const dir = new Vector3();\n    const color = new Color();\n    const shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    const sh = new SphericalHarmonics3();\n    const shCoefficients = sh.coefficients;\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      const image = cubeTexture.image[faceIndex];\n      const width = image.width;\n      const height = image.height;\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = width;\n      canvas.height = height;\n      const context = canvas.getContext(\"2d\");\n      context.drawImage(image, 0, 0, width, height);\n      const imageData = context.getImageData(0, 0, width, height);\n      const data = imageData.data;\n      const imageWidth = imageData.width;\n      const pixelSize = 2 / imageWidth;\n      for (let i = 0, il = data.length; i < il; i += 4) {\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255);\n        if (\"colorSpace\" in cubeTexture) {\n          if (cubeTexture.colorSpace === \"srgb\") {\n            color.convertSRGBToLinear();\n          }\n        } else if (cubeTexture.encoding === 3001) {\n          color.convertSRGBToLinear();\n        }\n        const pixelIndex = i / 4;\n        const col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;\n        const row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\n        switch (faceIndex) {\n          case 0:\n            coord.set(-1, row, -col);\n            break;\n          case 1:\n            coord.set(1, row, col);\n            break;\n          case 2:\n            coord.set(-col, 1, -row);\n            break;\n          case 3:\n            coord.set(-col, -1, row);\n            break;\n          case 4:\n            coord.set(-col, row, 1);\n            break;\n          case 5:\n            coord.set(col, row, -1);\n            break;\n        }\n        const lengthSq = coord.lengthSq();\n        const weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\n        totalWeight += weight;\n        dir.copy(coord).normalize();\n        SphericalHarmonics3.getBasisAt(dir, shBasis);\n        for (let j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight;\n          shCoefficients[j].y += shBasis[j] * color.g * weight;\n          shCoefficients[j].z += shBasis[j] * color.b * weight;\n        }\n      }\n    }\n    const norm = 4 * Math.PI / totalWeight;\n    for (let j = 0; j < 9; j++) {\n      shCoefficients[j].x *= norm;\n      shCoefficients[j].y *= norm;\n      shCoefficients[j].z *= norm;\n    }\n    return new LightProbe(sh);\n  }\n  static fromCubeRenderTarget(renderer, cubeRenderTarget) {\n    let totalWeight = 0;\n    const coord = new Vector3();\n    const dir = new Vector3();\n    const color = new Color();\n    const shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    const sh = new SphericalHarmonics3();\n    const shCoefficients = sh.coefficients;\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      const imageWidth = cubeRenderTarget.width;\n      const data = new Uint8Array(imageWidth * imageWidth * 4);\n      renderer.readRenderTargetPixels(cubeRenderTarget, 0, 0, imageWidth, imageWidth, data, faceIndex);\n      const pixelSize = 2 / imageWidth;\n      for (let i = 0, il = data.length; i < il; i += 4) {\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255);\n        if (\"colorSpace\" in cubeRenderTarget.texture) {\n          if (cubeRenderTarget.texture.colorSpace === \"srgb\") {\n            color.convertSRGBToLinear();\n          }\n        } else if (cubeRenderTarget.texture.encoding === 3001) {\n          color.convertSRGBToLinear();\n        }\n        const pixelIndex = i / 4;\n        const col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;\n        const row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\n        switch (faceIndex) {\n          case 0:\n            coord.set(1, row, -col);\n            break;\n          case 1:\n            coord.set(-1, row, col);\n            break;\n          case 2:\n            coord.set(col, 1, -row);\n            break;\n          case 3:\n            coord.set(col, -1, row);\n            break;\n          case 4:\n            coord.set(col, row, 1);\n            break;\n          case 5:\n            coord.set(-col, row, -1);\n            break;\n        }\n        const lengthSq = coord.lengthSq();\n        const weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\n        totalWeight += weight;\n        dir.copy(coord).normalize();\n        SphericalHarmonics3.getBasisAt(dir, shBasis);\n        for (let j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight;\n          shCoefficients[j].y += shBasis[j] * color.g * weight;\n          shCoefficients[j].z += shBasis[j] * color.b * weight;\n        }\n      }\n    }\n    const norm = 4 * Math.PI / totalWeight;\n    for (let j = 0; j < 9; j++) {\n      shCoefficients[j].x *= norm;\n      shCoefficients[j].y *= norm;\n      shCoefficients[j].z *= norm;\n    }\n    return new LightProbe(sh);\n  }\n}\nexport { LightProbeGenerator };\n//# sourceMappingURL=LightProbeGenerator.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}