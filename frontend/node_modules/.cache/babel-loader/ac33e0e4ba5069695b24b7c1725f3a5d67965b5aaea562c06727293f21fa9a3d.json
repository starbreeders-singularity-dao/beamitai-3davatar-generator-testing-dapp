{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { isHexPrefixed, isHexString } from 'web3-validator';\nimport { bytesToHex, hexToBytes, isUint8Array, numberToHex } from 'web3-utils';\nimport { secp256k1 } from '../tx/constants.js';\nimport { Hardfork } from './enums.js';\nimport { TypeOutput } from './types.js';\n/**\n * Removes '0x' from a given `String` if present\n * @param str the string value\n * @returns the string without 0x prefix\n */\nexport const stripHexPrefix = str => {\n  if (typeof str !== 'string') throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);\n  return isHexPrefixed(str) ? str.slice(2) : str;\n};\n/**\n * Transforms Geth formatted nonce (i.e. hex string) to 8 byte 0x-prefixed string used internally\n * @param nonce string parsed from the Geth genesis file\n * @returns nonce as a 0x-prefixed 8 byte string\n */\nfunction formatNonce(nonce) {\n  if (!nonce || nonce === '0x0') {\n    return '0x0000000000000000';\n  }\n  if (isHexPrefixed(nonce)) {\n    return `0x${stripHexPrefix(nonce).padStart(16, '0')}`;\n  }\n  return `0x${nonce.padStart(16, '0')}`;\n}\n/**\n * Converts a `Number` into a hex `String`\n * @param {Number} i\n * @return {String}\n */\nconst intToHex = function (i) {\n  if (!Number.isSafeInteger(i) || i < 0) {\n    throw new Error(`Received an invalid integer type: ${i}`);\n  }\n  return `0x${i.toString(16)}`;\n};\n/**\n * Converts Geth genesis parameters to an EthereumJS compatible `CommonOpts` object\n * @param json object representing the Geth genesis file\n * @param optional mergeForkIdPostMerge which clarifies the placement of MergeForkIdTransition\n * hardfork, which by default is post merge as with the merged eth networks but could also come\n * before merge like in kiln genesis\n * @returns genesis parameters in a `CommonOpts` compliant object\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction parseGethParams(json, mergeForkIdPostMerge = true) {\n  var _a, _b;\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const {\n    name,\n    config,\n    difficulty,\n    mixHash,\n    gasLimit,\n    coinbase,\n    baseFeePerGas\n  } = json;\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  let {\n    extraData,\n    timestamp,\n    nonce\n  } = json;\n  const genesisTimestamp = Number(timestamp);\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const {\n    chainId\n  } = config;\n  // geth is not strictly putting empty fields with a 0x prefix\n  if (extraData === '') {\n    extraData = '0x';\n  }\n  // geth may use number for timestamp\n  if (!isHexPrefixed(timestamp)) {\n    // eslint-disable-next-line radix\n    timestamp = intToHex(parseInt(timestamp));\n  }\n  // geth may not give us a nonce strictly formatted to an 8 byte hex string\n  if (nonce.length !== 18) {\n    nonce = formatNonce(nonce);\n  }\n  // EIP155 and EIP158 are both part of Spurious Dragon hardfork and must occur at the same time\n  // but have different configuration parameters in geth genesis parameters\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  if (config.eip155Block !== config.eip158Block) {\n    throw new Error('EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork');\n  }\n  const params = {\n    name,\n    chainId,\n    networkId: chainId,\n    genesis: {\n      timestamp,\n      // eslint-disable-next-line radix\n      gasLimit: parseInt(gasLimit),\n      // geth gasLimit and difficulty are hex strings while ours are `number`s\n      // eslint-disable-next-line radix\n      difficulty: parseInt(difficulty),\n      nonce,\n      extraData,\n      mixHash,\n      coinbase,\n      baseFeePerGas\n    },\n    hardfork: undefined,\n    hardforks: [],\n    bootstrapNodes: [],\n    consensus:\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    config.clique !== undefined ? {\n      type: 'poa',\n      algorithm: 'clique',\n      clique: {\n        // The recent geth genesis seems to be using blockperiodseconds\n        // and epochlength for clique specification\n        // see: https://hackmd.io/PqZgMpnkSWCWv5joJoFymQ\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment\n        period: (_a = config.clique.period) !== null && _a !== void 0 ? _a : config.clique.blockperiodseconds,\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,  @typescript-eslint/no-unsafe-assignment\n        epoch: (_b = config.clique.epoch) !== null && _b !== void 0 ? _b : config.clique.epochlength\n      }\n    } : {\n      type: 'pow',\n      algorithm: 'ethash',\n      ethash: {}\n    }\n  };\n  const forkMap = {\n    [Hardfork.Homestead]: {\n      name: 'homesteadBlock'\n    },\n    [Hardfork.Dao]: {\n      name: 'daoForkBlock'\n    },\n    [Hardfork.TangerineWhistle]: {\n      name: 'eip150Block'\n    },\n    [Hardfork.SpuriousDragon]: {\n      name: 'eip155Block'\n    },\n    [Hardfork.Byzantium]: {\n      name: 'byzantiumBlock'\n    },\n    [Hardfork.Constantinople]: {\n      name: 'constantinopleBlock'\n    },\n    [Hardfork.Petersburg]: {\n      name: 'petersburgBlock'\n    },\n    [Hardfork.Istanbul]: {\n      name: 'istanbulBlock'\n    },\n    [Hardfork.MuirGlacier]: {\n      name: 'muirGlacierBlock'\n    },\n    [Hardfork.Berlin]: {\n      name: 'berlinBlock'\n    },\n    [Hardfork.London]: {\n      name: 'londonBlock'\n    },\n    [Hardfork.MergeForkIdTransition]: {\n      name: 'mergeForkBlock',\n      postMerge: mergeForkIdPostMerge\n    },\n    [Hardfork.Shanghai]: {\n      name: 'shanghaiTime',\n      postMerge: true,\n      isTimestamp: true\n    },\n    [Hardfork.ShardingForkDev]: {\n      name: 'shardingForkTime',\n      postMerge: true,\n      isTimestamp: true\n    }\n  };\n  // forkMapRev is the map from config field name to Hardfork\n  const forkMapRev = Object.keys(forkMap).reduce((acc, elem) => {\n    acc[forkMap[elem].name] = elem;\n    return acc;\n  }, {});\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n  const configHardforkNames = Object.keys(config).filter(\n  // eslint-disable-next-line no-null/no-null, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/prefer-optional-chain\n  key => forkMapRev[key] !== undefined && config[key] !== undefined && config[key] !== null);\n  params.hardforks = configHardforkNames.map(nameBlock => ({\n    name: forkMapRev[nameBlock],\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    block:\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    forkMap[forkMapRev[nameBlock]].isTimestamp === true ||\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    typeof config[nameBlock] !== 'number' ?\n    // eslint-disable-next-line no-null/no-null\n    null :\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    config[nameBlock],\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    timestamp:\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    forkMap[forkMapRev[nameBlock]].isTimestamp === true &&\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    typeof config[nameBlock] === 'number' ?\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    config[nameBlock] : undefined\n  }))\n  // eslint-disable-next-line no-null/no-null\n  .filter(fork => fork.block !== null || fork.timestamp !== undefined);\n  params.hardforks.sort((a, b) => {\n    var _a, _b;\n    return ((_a = a.block) !== null && _a !== void 0 ? _a : Infinity) - ((_b = b.block) !== null && _b !== void 0 ? _b : Infinity);\n  });\n  params.hardforks.sort((a, b) => {\n    var _a, _b;\n    return ((_a = a.timestamp) !== null && _a !== void 0 ? _a : genesisTimestamp) - ((_b = b.timestamp) !== null && _b !== void 0 ? _b : genesisTimestamp);\n  });\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  if (config.terminalTotalDifficulty !== undefined) {\n    // Following points need to be considered for placement of merge hf\n    // - Merge hardfork can't be placed at genesis\n    // - Place merge hf before any hardforks that require CL participation for e.g. withdrawals\n    // - Merge hardfork has to be placed just after genesis if any of the genesis hardforks make CL\n    //   necessary for e.g. withdrawals\n    const mergeConfig = {\n      name: Hardfork.Merge,\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment\n      ttd: config.terminalTotalDifficulty,\n      // eslint-disable-next-line no-null/no-null\n      block: null\n    };\n    // Merge hardfork has to be placed before first hardfork that is dependent on merge\n    const postMergeIndex = params.hardforks.findIndex(\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    hf => {\n      var _a;\n      return ((_a = forkMap[hf.name]) === null || _a === void 0 ? void 0 : _a.postMerge) === true;\n    });\n    if (postMergeIndex !== -1) {\n      params.hardforks.splice(postMergeIndex, 0, mergeConfig);\n    } else {\n      params.hardforks.push(mergeConfig);\n    }\n  }\n  const latestHardfork = params.hardforks.length > 0 ? params.hardforks.slice(-1)[0] : undefined;\n  params.hardfork = latestHardfork === null || latestHardfork === void 0 ? void 0 : latestHardfork.name;\n  params.hardforks.unshift({\n    name: Hardfork.Chainstart,\n    block: 0\n  });\n  return params;\n}\n/**\n * Parses a genesis.json exported from Geth into parameters for Common instance\n * @param json representing the Geth genesis file\n * @param name optional chain name\n * @returns parsed params\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function parseGethGenesis(json, name, mergeForkIdPostMerge) {\n  try {\n    if (['config', 'difficulty', 'gasLimit', 'alloc'].some(field => !(field in json))) {\n      throw new Error('Invalid format, expected geth genesis fields missing');\n    }\n    if (name !== undefined) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-param-reassign\n      json.name = name;\n    }\n    return parseGethParams(json, mergeForkIdPostMerge);\n  } catch (e) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/restrict-template-expressions\n    throw new Error(`Error parsing parameters file: ${e.message}`);\n  }\n}\n/**\n * Pads a `String` to have an even length\n * @param value\n * @return output\n */\nexport function padToEven(value) {\n  let a = value;\n  if (typeof a !== 'string') {\n    throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);\n  }\n  if (a.length % 2) a = `0${a}`;\n  return a;\n}\n/**\n * Converts an `Number` to a `Uint8Array`\n * @param {Number} i\n * @return {Uint8Array}\n */\nexport const intToUint8Array = function (i) {\n  const hex = intToHex(i);\n  return hexToBytes(`0x${padToEven(hex.slice(2))}`);\n};\n/**\n * Attempts to turn a value into a `Uint8Array`.\n * Inputs supported: `Uint8Array` `String` (hex-prefixed), `Number`, null/undefined, `BigInt` and other objects\n * with a `toArray()` or `toUint8Array()` method.\n * @param v the value\n */\nexport const toUint8Array = function (v) {\n  var _a;\n  // eslint-disable-next-line no-null/no-null\n  if (v === null || v === undefined) {\n    return new Uint8Array();\n  }\n  if (v instanceof Uint8Array) {\n    return v;\n  }\n  if (((_a = v === null || v === void 0 ? void 0 : v.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'Uint8Array') {\n    return Uint8Array.from(v);\n  }\n  if (Array.isArray(v)) {\n    return Uint8Array.from(v);\n  }\n  if (typeof v === 'string') {\n    if (!isHexString(v)) {\n      throw new Error(`Cannot convert string to Uint8Array. only supports 0x-prefixed hex strings and this string was given: ${v}`);\n    }\n    return hexToBytes(padToEven(stripHexPrefix(v)));\n  }\n  if (typeof v === 'number') {\n    return toUint8Array(numberToHex(v));\n  }\n  if (typeof v === 'bigint') {\n    if (v < BigInt(0)) {\n      throw new Error(`Cannot convert negative bigint to Uint8Array. Given: ${v}`);\n    }\n    let n = v.toString(16);\n    if (n.length % 2) n = `0${n}`;\n    return toUint8Array(`0x${n}`);\n  }\n  if (v.toArray) {\n    // converts a BN to a Uint8Array\n    return Uint8Array.from(v.toArray());\n  }\n  throw new Error('invalid type');\n};\n/**\n * Converts a {@link Uint8Array} to a {@link bigint}\n */\nexport function uint8ArrayToBigInt(buf) {\n  const hex = bytesToHex(buf);\n  if (hex === '0x') {\n    return BigInt(0);\n  }\n  return BigInt(hex);\n}\n/**\n * Converts a {@link bigint} to a {@link Uint8Array}\n */\nexport function bigIntToUint8Array(num) {\n  return toUint8Array(`0x${num.toString(16)}`);\n}\n/**\n * Returns a Uint8Array filled with 0s.\n * @param bytes the number of bytes the Uint8Array should be\n */\nexport const zeros = function (bytes) {\n  return new Uint8Array(bytes).fill(0);\n};\n/**\n * Pads a `Uint8Array` with zeros till it has `length` bytes.\n * Truncates the beginning or end of input if its length exceeds `length`.\n * @param msg the value to pad (Uint8Array)\n * @param length the number of bytes the output should be\n * @param right whether to start padding form the left or right\n * @return (Uint8Array)\n */\nconst setLength = function (msg, length, right) {\n  const buf = zeros(length);\n  if (right) {\n    if (msg.length < length) {\n      buf.set(msg);\n      return buf;\n    }\n    return msg.subarray(0, length);\n  }\n  if (msg.length < length) {\n    buf.set(msg, length - msg.length);\n    return buf;\n  }\n  return msg.subarray(-length);\n};\n/**\n * Throws if input is not a Uint8Array\n * @param {Uint8Array} input value to check\n */\nexport function assertIsUint8Array(input) {\n  if (!isUint8Array(input)) {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    const msg = `This method only supports Uint8Array but input was: ${input}`;\n    throw new Error(msg);\n  }\n}\n/**\n * Left Pads a `Uint8Array` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param msg the value to pad (Uint8Array)\n * @param length the number of bytes the output should be\n * @return (Uint8Array)\n */\nexport const setLengthLeft = function (msg, length) {\n  assertIsUint8Array(msg);\n  return setLength(msg, length, false);\n};\n/**\n * Trims leading zeros from a `Uint8Array`, `String` or `Number[]`.\n * @param a (Uint8Array|Array|String)\n * @return (Uint8Array|Array|String)\n */\nexport function stripZeros(a) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment\n  let first = a[0];\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n  while (a.length > 0 && first.toString() === '0') {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment, prefer-destructuring, @typescript-eslint/no-unsafe-call, no-param-reassign\n    a = a.slice(1);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, prefer-destructuring, @typescript-eslint/no-unsafe-member-access\n    first = a[0];\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  return a;\n}\n/**\n * Trims leading zeros from a `Uint8Array`.\n * @param a (Uint8Array)\n * @return (Uint8Array)\n */\nexport const unpadUint8Array = function (a) {\n  assertIsUint8Array(a);\n  return stripZeros(a);\n};\n/**\n * Converts a {@link bigint} to a `0x` prefixed hex string\n */\nexport const bigIntToHex = num => `0x${num.toString(16)}`;\n/**\n * Convert value from bigint to an unpadded Uint8Array\n * (useful for RLP transport)\n * @param value value to convert\n */\nexport function bigIntToUnpaddedUint8Array(value) {\n  return unpadUint8Array(bigIntToUint8Array(value));\n}\nfunction calculateSigRecovery(v, chainId) {\n  if (v === BigInt(0) || v === BigInt(1)) return v;\n  if (chainId === undefined) {\n    return v - BigInt(27);\n  }\n  return v - (chainId * BigInt(2) + BigInt(35));\n}\nfunction isValidSigRecovery(recovery) {\n  return recovery === BigInt(0) || recovery === BigInt(1);\n}\n/**\n * ECDSA public key recovery from signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Recovered public key\n */\nexport const ecrecover = function (msgHash, v, r, s, chainId) {\n  const recovery = calculateSigRecovery(v, chainId);\n  if (!isValidSigRecovery(recovery)) {\n    throw new Error('Invalid signature v value');\n  }\n  const senderPubKey = new secp256k1.Signature(uint8ArrayToBigInt(r), uint8ArrayToBigInt(s)).addRecoveryBit(Number(recovery)).recoverPublicKey(msgHash).toRawBytes(false);\n  return senderPubKey.slice(1);\n};\nexport function toType(input, outputType) {\n  // eslint-disable-next-line no-null/no-null\n  if (input === null) {\n    // eslint-disable-next-line no-null/no-null\n    return null;\n  }\n  if (input === undefined) {\n    return undefined;\n  }\n  if (typeof input === 'string' && !isHexString(input)) {\n    throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);\n  } else if (typeof input === 'number' && !Number.isSafeInteger(input)) {\n    throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\n  }\n  const output = toUint8Array(input);\n  switch (outputType) {\n    case TypeOutput.Uint8Array:\n      return output;\n    case TypeOutput.BigInt:\n      return uint8ArrayToBigInt(output);\n    case TypeOutput.Number:\n      {\n        const bigInt = uint8ArrayToBigInt(output);\n        if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {\n          throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');\n        }\n        return Number(bigInt);\n      }\n    case TypeOutput.PrefixedHexString:\n      return bytesToHex(output);\n    default:\n      throw new Error('unknown outputType');\n  }\n}\n//# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}