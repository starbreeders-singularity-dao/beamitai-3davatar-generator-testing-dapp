{"ast":null,"code":"import { BufferAttribute, BufferGeometry, Vector3, Vector4, Matrix4, Matrix3 } from 'three';\nconst _positionVector = /*@__PURE__*/new Vector3();\nconst _normalVector = /*@__PURE__*/new Vector3();\nconst _tangentVector = /*@__PURE__*/new Vector3();\nconst _tangentVector4 = /*@__PURE__*/new Vector4();\nconst _morphVector = /*@__PURE__*/new Vector3();\nconst _temp = /*@__PURE__*/new Vector3();\nconst _skinIndex = /*@__PURE__*/new Vector4();\nconst _skinWeight = /*@__PURE__*/new Vector4();\nconst _matrix = /*@__PURE__*/new Matrix4();\nconst _boneMatrix = /*@__PURE__*/new Matrix4();\n\n// Confirms that the two provided attributes are compatible\nfunction validateAttributes(attr1, attr2) {\n  if (!attr1 && !attr2) {\n    return;\n  }\n  const sameCount = attr1.count === attr2.count;\n  const sameNormalized = attr1.normalized === attr2.normalized;\n  const sameType = attr1.array.constructor === attr2.array.constructor;\n  const sameItemSize = attr1.itemSize === attr2.itemSize;\n  if (!sameCount || !sameNormalized || !sameType || !sameItemSize) {\n    throw new Error();\n  }\n}\n\n// Clones the given attribute with a new compatible buffer attribute but no data\nfunction createAttributeClone(attr, countOverride = null) {\n  const cons = attr.array.constructor;\n  const normalized = attr.normalized;\n  const itemSize = attr.itemSize;\n  const count = countOverride === null ? attr.count : countOverride;\n  return new BufferAttribute(new cons(itemSize * count), itemSize, normalized);\n}\n\n// target offset is the number of elements in the target buffer stride to skip before copying the\n// attributes contents in to.\nfunction copyAttributeContents(attr, target, targetOffset = 0) {\n  if (attr.isInterleavedBufferAttribute) {\n    const itemSize = attr.itemSize;\n    for (let i = 0, l = attr.count; i < l; i++) {\n      const io = i + targetOffset;\n      target.setX(io, attr.getX(i));\n      if (itemSize >= 2) target.setY(io, attr.getY(i));\n      if (itemSize >= 3) target.setZ(io, attr.getZ(i));\n      if (itemSize >= 4) target.setW(io, attr.getW(i));\n    }\n  } else {\n    const array = target.array;\n    const cons = array.constructor;\n    const byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n    const temp = new cons(array.buffer, byteOffset, attr.array.length);\n    temp.set(attr.array);\n  }\n}\n\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\nfunction addScaledMatrix(target, matrix, scale) {\n  const targetArray = target.elements;\n  const matrixArray = matrix.elements;\n  for (let i = 0, l = matrixArray.length; i < l; i++) {\n    targetArray[i] += matrixArray[i] * scale;\n  }\n}\n\n// A version of \"SkinnedMesh.boneTransform\" for normals\nfunction boneNormalTransform(mesh, index, target) {\n  const skeleton = mesh.skeleton;\n  const geometry = mesh.geometry;\n  const bones = skeleton.bones;\n  const boneInverses = skeleton.boneInverses;\n  _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);\n  _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);\n  _matrix.elements.fill(0);\n  for (let i = 0; i < 4; i++) {\n    const weight = _skinWeight.getComponent(i);\n    if (weight !== 0) {\n      const boneIndex = _skinIndex.getComponent(i);\n      _boneMatrix.multiplyMatrices(bones[boneIndex].matrixWorld, boneInverses[boneIndex]);\n      addScaledMatrix(_matrix, _boneMatrix, weight);\n    }\n  }\n  _matrix.multiply(mesh.bindMatrix).premultiply(mesh.bindMatrixInverse);\n  target.transformDirection(_matrix);\n  return target;\n}\n\n// Applies the morph target data to the target vector\nfunction applyMorphTarget(morphData, morphInfluences, morphTargetsRelative, i, target) {\n  _morphVector.set(0, 0, 0);\n  for (let j = 0, jl = morphData.length; j < jl; j++) {\n    const influence = morphInfluences[j];\n    const morphAttribute = morphData[j];\n    if (influence === 0) continue;\n    _temp.fromBufferAttribute(morphAttribute, i);\n    if (morphTargetsRelative) {\n      _morphVector.addScaledVector(_temp, influence);\n    } else {\n      _morphVector.addScaledVector(_temp.sub(target), influence);\n    }\n  }\n  target.add(_morphVector);\n}\n\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\nfunction mergeBufferGeometries(geometries, options = {\n  useGroups: false,\n  updateIndex: false,\n  skipAttributes: []\n}, targetGeometry = new BufferGeometry()) {\n  const isIndexed = geometries[0].index !== null;\n  const {\n    useGroups = false,\n    updateIndex = false,\n    skipAttributes = []\n  } = options;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const attributes = {};\n  let offset = 0;\n  targetGeometry.clearGroups();\n  for (let i = 0; i < geometries.length; ++i) {\n    const geometry = geometries[i];\n    let attributesCount = 0;\n\n    // ensure that all geometries are indexed, or none\n    if (isIndexed !== (geometry.index !== null)) {\n      throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n    }\n\n    // gather attributes, exit early if they're different\n    for (const name in geometry.attributes) {\n      if (!attributesUsed.has(name)) {\n        throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n      }\n      if (attributes[name] === undefined) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geometry.attributes[name]);\n      attributesCount++;\n    }\n\n    // ensure geometries have the same number of attributes\n    if (attributesCount !== attributesUsed.size) {\n      throw new Error('StaticGeometryGenerator: Make sure all geometries have the same number of attributes.');\n    }\n    if (useGroups) {\n      let count;\n      if (isIndexed) {\n        count = geometry.index.count;\n      } else if (geometry.attributes.position !== undefined) {\n        count = geometry.attributes.position.count;\n      } else {\n        throw new Error('StaticGeometryGenerator: The geometry must have either an index or a position attribute');\n      }\n      targetGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  }\n\n  // merge indices\n  if (isIndexed) {\n    let forceUpdateIndex = false;\n    if (!targetGeometry.index) {\n      let indexCount = 0;\n      for (let i = 0; i < geometries.length; ++i) {\n        indexCount += geometries[i].index.count;\n      }\n      targetGeometry.setIndex(new BufferAttribute(new Uint32Array(indexCount), 1, false));\n      forceUpdateIndex = true;\n    }\n    if (updateIndex || forceUpdateIndex) {\n      const targetIndex = targetGeometry.index;\n      let targetOffset = 0;\n      let indexOffset = 0;\n      for (let i = 0; i < geometries.length; ++i) {\n        const geometry = geometries[i];\n        const index = geometry.index;\n        if (skipAttributes[i] !== true) {\n          for (let j = 0; j < index.count; ++j) {\n            targetIndex.setX(targetOffset, index.getX(j) + indexOffset);\n            targetOffset++;\n          }\n        }\n        indexOffset += geometry.attributes.position.count;\n      }\n    }\n  }\n\n  // merge attributes\n  for (const name in attributes) {\n    const attrList = attributes[name];\n    if (!(name in targetGeometry.attributes)) {\n      let count = 0;\n      for (const key in attrList) {\n        count += attrList[key].count;\n      }\n      targetGeometry.setAttribute(name, createAttributeClone(attributes[name][0], count));\n    }\n    const targetAttribute = targetGeometry.attributes[name];\n    let offset = 0;\n    for (let i = 0, l = attrList.length; i < l; i++) {\n      const attr = attrList[i];\n      if (skipAttributes[i] !== true) {\n        copyAttributeContents(attr, targetAttribute, offset);\n      }\n      offset += attr.count;\n    }\n  }\n  return targetGeometry;\n}\nfunction checkTypedArrayEquality(a, b) {\n  if (a === null || b === null) {\n    return a === b;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0, l = a.length; i < l; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction invertGeometry(geometry) {\n  const {\n    index,\n    attributes\n  } = geometry;\n  if (index) {\n    for (let i = 0, l = index.count; i < l; i += 3) {\n      const v0 = index.getX(i);\n      const v2 = index.getX(i + 2);\n      index.setX(i, v2);\n      index.setX(i + 2, v0);\n    }\n  } else {\n    for (const key in attributes) {\n      const attr = attributes[key];\n      const itemSize = attr.itemSize;\n      for (let i = 0, l = attr.count; i < l; i += 3) {\n        for (let j = 0; j < itemSize; j++) {\n          const v0 = attr.getComponent(i, j);\n          const v2 = attr.getComponent(i + 2, j);\n          attr.setComponent(i, j, v2);\n          attr.setComponent(i + 2, j, v0);\n        }\n      }\n    }\n  }\n  return geometry;\n}\n\n// Checks whether the geometry changed between this and last evaluation\nclass GeometryDiff {\n  constructor(mesh) {\n    this.matrixWorld = new Matrix4();\n    this.geometryHash = null;\n    this.boneMatrices = null;\n    this.primitiveCount = -1;\n    this.mesh = mesh;\n    this.update();\n  }\n  update() {\n    const mesh = this.mesh;\n    const geometry = mesh.geometry;\n    const skeleton = mesh.skeleton;\n    const primitiveCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n    this.matrixWorld.copy(mesh.matrixWorld);\n    this.geometryHash = geometry.attributes.position.version;\n    this.primitiveCount = primitiveCount;\n    if (skeleton) {\n      // ensure the bone matrix array is updated to the appropriate length\n      if (!skeleton.boneTexture) {\n        skeleton.computeBoneTexture();\n      }\n      skeleton.update();\n\n      // copy data if possible otherwise clone it\n      const boneMatrices = skeleton.boneMatrices;\n      if (!this.boneMatrices || this.boneMatrices.length !== boneMatrices.length) {\n        this.boneMatrices = boneMatrices.slice();\n      } else {\n        this.boneMatrices.set(boneMatrices);\n      }\n    } else {\n      this.boneMatrices = null;\n    }\n  }\n  didChange() {\n    const mesh = this.mesh;\n    const geometry = mesh.geometry;\n    const primitiveCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n    const identical = this.matrixWorld.equals(mesh.matrixWorld) && this.geometryHash === geometry.attributes.position.version && checkTypedArrayEquality(mesh.skeleton && mesh.skeleton.boneMatrices || null, this.boneMatrices) && this.primitiveCount === primitiveCount;\n    return !identical;\n  }\n}\nexport class StaticGeometryGenerator {\n  constructor(meshes) {\n    if (!Array.isArray(meshes)) {\n      meshes = [meshes];\n    }\n    const finalMeshes = [];\n    meshes.forEach(object => {\n      object.traverseVisible(c => {\n        if (c.isMesh) {\n          finalMeshes.push(c);\n        }\n      });\n    });\n    this.meshes = finalMeshes;\n    this.useGroups = true;\n    this.applyWorldTransforms = true;\n    this.attributes = ['position', 'normal', 'color', 'tangent', 'uv', 'uv2'];\n    this._intermediateGeometry = new Array(finalMeshes.length).fill().map(() => new BufferGeometry());\n    this._diffMap = new WeakMap();\n  }\n  getMaterials() {\n    const materials = [];\n    this.meshes.forEach(mesh => {\n      if (Array.isArray(mesh.material)) {\n        materials.push(...mesh.material);\n      } else {\n        materials.push(mesh.material);\n      }\n    });\n    return materials;\n  }\n  generate(targetGeometry = new BufferGeometry()) {\n    // track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n    let skipAttributes = [];\n    const {\n      meshes,\n      useGroups,\n      _intermediateGeometry,\n      _diffMap\n    } = this;\n    for (let i = 0, l = meshes.length; i < l; i++) {\n      const mesh = meshes[i];\n      const geom = _intermediateGeometry[i];\n      const diff = _diffMap.get(mesh);\n      if (!diff || diff.didChange(mesh)) {\n        this._convertToStaticGeometry(mesh, geom);\n        skipAttributes.push(false);\n        if (!diff) {\n          _diffMap.set(mesh, new GeometryDiff(mesh));\n        } else {\n          diff.update();\n        }\n      } else {\n        skipAttributes.push(true);\n      }\n    }\n    if (_intermediateGeometry.length === 0) {\n      // if there are no geometries then just create a fake empty geometry to provide\n      targetGeometry.setIndex(null);\n\n      // remove all geometry\n      const attrs = targetGeometry.attributes;\n      for (const key in attrs) {\n        targetGeometry.deleteAttribute(key);\n      }\n\n      // create dummy attributes\n      for (const key in this.attributes) {\n        targetGeometry.setAttribute(this.attributes[key], new BufferAttribute(new Float32Array(0), 4, false));\n      }\n    } else {\n      mergeBufferGeometries(_intermediateGeometry, {\n        useGroups,\n        skipAttributes\n      }, targetGeometry);\n    }\n    for (const key in targetGeometry.attributes) {\n      targetGeometry.attributes[key].needsUpdate = true;\n    }\n    return targetGeometry;\n  }\n  _convertToStaticGeometry(mesh, targetGeometry = new BufferGeometry()) {\n    const geometry = mesh.geometry;\n    const applyWorldTransforms = this.applyWorldTransforms;\n    const includeNormal = this.attributes.includes('normal');\n    const includeTangent = this.attributes.includes('tangent');\n    const attributes = geometry.attributes;\n    const targetAttributes = targetGeometry.attributes;\n\n    // initialize the attributes if they don't exist\n    if (!targetGeometry.index && geometry.index) {\n      targetGeometry.index = geometry.index.clone();\n    }\n    if (!targetAttributes.position) {\n      targetGeometry.setAttribute('position', createAttributeClone(attributes.position));\n    }\n    if (includeNormal && !targetAttributes.normal && attributes.normal) {\n      targetGeometry.setAttribute('normal', createAttributeClone(attributes.normal));\n    }\n    if (includeTangent && !targetAttributes.tangent && attributes.tangent) {\n      targetGeometry.setAttribute('tangent', createAttributeClone(attributes.tangent));\n    }\n\n    // ensure the attributes are consistent\n    validateAttributes(geometry.index, targetGeometry.index);\n    validateAttributes(attributes.position, targetAttributes.position);\n    if (includeNormal) {\n      validateAttributes(attributes.normal, targetAttributes.normal);\n    }\n    if (includeTangent) {\n      validateAttributes(attributes.tangent, targetAttributes.tangent);\n    }\n\n    // generate transformed vertex attribute data\n    const position = attributes.position;\n    const normal = includeNormal ? attributes.normal : null;\n    const tangent = includeTangent ? attributes.tangent : null;\n    const morphPosition = geometry.morphAttributes.position;\n    const morphNormal = geometry.morphAttributes.normal;\n    const morphTangent = geometry.morphAttributes.tangent;\n    const morphTargetsRelative = geometry.morphTargetsRelative;\n    const morphInfluences = mesh.morphTargetInfluences;\n    const normalMatrix = new Matrix3();\n    normalMatrix.getNormalMatrix(mesh.matrixWorld);\n\n    // copy the index\n    if (geometry.index) {\n      targetGeometry.index.array.set(geometry.index.array);\n    }\n\n    // copy and apply other attributes\n    for (let i = 0, l = attributes.position.count; i < l; i++) {\n      _positionVector.fromBufferAttribute(position, i);\n      if (normal) {\n        _normalVector.fromBufferAttribute(normal, i);\n      }\n      if (tangent) {\n        _tangentVector4.fromBufferAttribute(tangent, i);\n        _tangentVector.fromBufferAttribute(tangent, i);\n      }\n\n      // apply morph target transform\n      if (morphInfluences) {\n        if (morphPosition) {\n          applyMorphTarget(morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector);\n        }\n        if (morphNormal) {\n          applyMorphTarget(morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector);\n        }\n        if (morphTangent) {\n          applyMorphTarget(morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector);\n        }\n      }\n\n      // apply bone transform\n      if (mesh.isSkinnedMesh) {\n        mesh.applyBoneTransform(i, _positionVector);\n        if (normal) {\n          boneNormalTransform(mesh, i, _normalVector);\n        }\n        if (tangent) {\n          boneNormalTransform(mesh, i, _tangentVector);\n        }\n      }\n\n      // update the vectors of the attributes\n      if (applyWorldTransforms) {\n        _positionVector.applyMatrix4(mesh.matrixWorld);\n      }\n      targetAttributes.position.setXYZ(i, _positionVector.x, _positionVector.y, _positionVector.z);\n      if (normal) {\n        if (applyWorldTransforms) {\n          _normalVector.applyNormalMatrix(normalMatrix);\n        }\n        targetAttributes.normal.setXYZ(i, _normalVector.x, _normalVector.y, _normalVector.z);\n      }\n      if (tangent) {\n        if (applyWorldTransforms) {\n          _tangentVector.transformDirection(mesh.matrixWorld);\n        }\n        targetAttributes.tangent.setXYZW(i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w);\n      }\n    }\n\n    // copy other attributes over\n    for (const i in this.attributes) {\n      const key = this.attributes[i];\n      if (key === 'position' || key === 'tangent' || key === 'normal' || !(key in attributes)) {\n        continue;\n      }\n      if (!targetAttributes[key]) {\n        targetGeometry.setAttribute(key, createAttributeClone(attributes[key]));\n      }\n      validateAttributes(attributes[key], targetAttributes[key]);\n      copyAttributeContents(attributes[key], targetAttributes[key]);\n    }\n    if (mesh.matrixWorld.determinant() < 0) {\n      invertGeometry(targetGeometry);\n    }\n    return targetGeometry;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}