{"ast":null,"code":"import { Triangle, Vector3, Line3, Sphere, Plane } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\nconst ZERO_EPSILON = 1e-15;\nfunction isNearZero(value) {\n  return Math.abs(value) < ZERO_EPSILON;\n}\nexport class ExtendedTriangle extends Triangle {\n  constructor(...args) {\n    super(...args);\n    this.isExtendedTriangle = true;\n    this.satAxes = new Array(4).fill().map(() => new Vector3());\n    this.satBounds = new Array(4).fill().map(() => new SeparatingAxisBounds());\n    this.points = [this.a, this.b, this.c];\n    this.sphere = new Sphere();\n    this.plane = new Plane();\n    this.needsUpdate = true;\n  }\n  intersectsSphere(sphere) {\n    return sphereIntersectTriangle(sphere, this);\n  }\n  update() {\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const points = this.points;\n    const satAxes = this.satAxes;\n    const satBounds = this.satBounds;\n    const axis0 = satAxes[0];\n    const sab0 = satBounds[0];\n    this.getNormal(axis0);\n    sab0.setFromPoints(axis0, points);\n    const axis1 = satAxes[1];\n    const sab1 = satBounds[1];\n    axis1.subVectors(a, b);\n    sab1.setFromPoints(axis1, points);\n    const axis2 = satAxes[2];\n    const sab2 = satBounds[2];\n    axis2.subVectors(b, c);\n    sab2.setFromPoints(axis2, points);\n    const axis3 = satAxes[3];\n    const sab3 = satBounds[3];\n    axis3.subVectors(c, a);\n    sab3.setFromPoints(axis3, points);\n    this.sphere.setFromPoints(this.points);\n    this.plane.setFromNormalAndCoplanarPoint(axis0, a);\n    this.needsUpdate = false;\n  }\n}\nExtendedTriangle.prototype.closestPointToSegment = function () {\n  const point1 = new Vector3();\n  const point2 = new Vector3();\n  const edge = new Line3();\n  return function distanceToSegment(segment, target1 = null, target2 = null) {\n    const {\n      start,\n      end\n    } = segment;\n    const points = this.points;\n    let distSq;\n    let closestDistanceSq = Infinity;\n\n    // check the triangle edges\n    for (let i = 0; i < 3; i++) {\n      const nexti = (i + 1) % 3;\n      edge.start.copy(points[i]);\n      edge.end.copy(points[nexti]);\n      closestPointsSegmentToSegment(edge, segment, point1, point2);\n      distSq = point1.distanceToSquared(point2);\n      if (distSq < closestDistanceSq) {\n        closestDistanceSq = distSq;\n        if (target1) target1.copy(point1);\n        if (target2) target2.copy(point2);\n      }\n    }\n\n    // check end points\n    this.closestPointToPoint(start, point1);\n    distSq = start.distanceToSquared(point1);\n    if (distSq < closestDistanceSq) {\n      closestDistanceSq = distSq;\n      if (target1) target1.copy(point1);\n      if (target2) target2.copy(start);\n    }\n    this.closestPointToPoint(end, point1);\n    distSq = end.distanceToSquared(point1);\n    if (distSq < closestDistanceSq) {\n      closestDistanceSq = distSq;\n      if (target1) target1.copy(point1);\n      if (target2) target2.copy(end);\n    }\n    return Math.sqrt(closestDistanceSq);\n  };\n}();\nExtendedTriangle.prototype.intersectsTriangle = function () {\n  const saTri2 = new ExtendedTriangle();\n  const arr1 = new Array(3);\n  const arr2 = new Array(3);\n  const cachedSatBounds = new SeparatingAxisBounds();\n  const cachedSatBounds2 = new SeparatingAxisBounds();\n  const cachedAxis = new Vector3();\n  const dir = new Vector3();\n  const dir1 = new Vector3();\n  const dir2 = new Vector3();\n  const tempDir = new Vector3();\n  const edge = new Line3();\n  const edge1 = new Line3();\n  const edge2 = new Line3();\n  const tempPoint = new Vector3();\n  function triIntersectPlane(tri, plane, targetEdge) {\n    // find the edge that intersects the other triangle plane\n    const points = tri.points;\n    let count = 0;\n    let startPointIntersection = -1;\n    for (let i = 0; i < 3; i++) {\n      const {\n        start,\n        end\n      } = edge;\n      start.copy(points[i]);\n      end.copy(points[(i + 1) % 3]);\n      edge.delta(dir);\n      const startIntersects = isNearZero(plane.distanceToPoint(start));\n      if (isNearZero(plane.normal.dot(dir)) && startIntersects) {\n        // if the edge lies on the plane then take the line\n        targetEdge.copy(edge);\n        count = 2;\n        break;\n      }\n\n      // check if the start point is near the plane because \"intersectLine\" is not robust to that case\n      const doesIntersect = plane.intersectLine(edge, tempPoint);\n      if (!doesIntersect && startIntersects) {\n        tempPoint.copy(start);\n      }\n\n      // ignore the end point\n      if ((doesIntersect || startIntersects) && !isNearZero(tempPoint.distanceTo(end))) {\n        if (count <= 1) {\n          // assign to the start or end point and save which index was snapped to\n          // the start point if necessary\n          const point = count === 1 ? targetEdge.start : targetEdge.end;\n          point.copy(tempPoint);\n          if (startIntersects) {\n            startPointIntersection = count;\n          }\n        } else if (count >= 2) {\n          // if we're here that means that there must have been one point that had\n          // snapped to the start point so replace it here\n          const point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;\n          point.copy(tempPoint);\n          count = 2;\n          break;\n        }\n        count++;\n        if (count === 2 && startPointIntersection === -1) {\n          break;\n        }\n      }\n    }\n    return count;\n  }\n\n  // TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n  // be a line contained by both triangles if not a different special case somehow represented in the return result.\n  return function intersectsTriangle(other, target = null, suppressLog = false) {\n    if (this.needsUpdate) {\n      this.update();\n    }\n    if (!other.isExtendedTriangle) {\n      saTri2.copy(other);\n      saTri2.update();\n      other = saTri2;\n    } else if (other.needsUpdate) {\n      other.update();\n    }\n    const plane1 = this.plane;\n    const plane2 = other.plane;\n    if (Math.abs(plane1.normal.dot(plane2.normal)) > 1.0 - 1e-10) {\n      // perform separating axis intersection test only for coplanar triangles\n      const satBounds1 = this.satBounds;\n      const satAxes1 = this.satAxes;\n      arr2[0] = other.a;\n      arr2[1] = other.b;\n      arr2[2] = other.c;\n      for (let i = 0; i < 4; i++) {\n        const sb = satBounds1[i];\n        const sa = satAxes1[i];\n        cachedSatBounds.setFromPoints(sa, arr2);\n        if (sb.isSeparated(cachedSatBounds)) return false;\n      }\n      const satBounds2 = other.satBounds;\n      const satAxes2 = other.satAxes;\n      arr1[0] = this.a;\n      arr1[1] = this.b;\n      arr1[2] = this.c;\n      for (let i = 0; i < 4; i++) {\n        const sb = satBounds2[i];\n        const sa = satAxes2[i];\n        cachedSatBounds.setFromPoints(sa, arr1);\n        if (sb.isSeparated(cachedSatBounds)) return false;\n      }\n\n      // check crossed axes\n      for (let i = 0; i < 4; i++) {\n        const sa1 = satAxes1[i];\n        for (let i2 = 0; i2 < 4; i2++) {\n          const sa2 = satAxes2[i2];\n          cachedAxis.crossVectors(sa1, sa2);\n          cachedSatBounds.setFromPoints(cachedAxis, arr1);\n          cachedSatBounds2.setFromPoints(cachedAxis, arr2);\n          if (cachedSatBounds.isSeparated(cachedSatBounds2)) return false;\n        }\n      }\n      if (target) {\n        // TODO find two points that intersect on the edges and make that the result\n        if (!suppressLog) {\n          console.warn('ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.');\n        }\n        target.start.set(0, 0, 0);\n        target.end.set(0, 0, 0);\n      }\n      return true;\n    } else {\n      // find the edge that intersects the other triangle plane\n      const count1 = triIntersectPlane(this, plane2, edge1);\n      if (count1 === 1 && other.containsPoint(edge1.end)) {\n        if (target) {\n          target.start.copy(edge1.end);\n          target.end.copy(edge1.end);\n        }\n        return true;\n      } else if (count1 !== 2) {\n        return false;\n      }\n\n      // find the other triangles edge that intersects this plane\n      const count2 = triIntersectPlane(other, plane1, edge2);\n      if (count2 === 1 && this.containsPoint(edge2.end)) {\n        if (target) {\n          target.start.copy(edge2.end);\n          target.end.copy(edge2.end);\n        }\n        return true;\n      } else if (count2 !== 2) {\n        return false;\n      }\n\n      // find swap the second edge so both lines are running the same direction\n      edge1.delta(dir1);\n      edge2.delta(dir2);\n      if (dir1.dot(dir2) < 0) {\n        let tmp = edge2.start;\n        edge2.start = edge2.end;\n        edge2.end = tmp;\n      }\n\n      // check if the edges are overlapping\n      const s1 = edge1.start.dot(dir1);\n      const e1 = edge1.end.dot(dir1);\n      const s2 = edge2.start.dot(dir1);\n      const e2 = edge2.end.dot(dir1);\n      const separated1 = e1 < s2;\n      const separated2 = s1 < e2;\n      if (s1 !== e2 && s2 !== e1 && separated1 === separated2) {\n        return false;\n      }\n\n      // assign the target output\n      if (target) {\n        tempDir.subVectors(edge1.start, edge2.start);\n        if (tempDir.dot(dir1) > 0) {\n          target.start.copy(edge1.start);\n        } else {\n          target.start.copy(edge2.start);\n        }\n        tempDir.subVectors(edge1.end, edge2.end);\n        if (tempDir.dot(dir1) < 0) {\n          target.end.copy(edge1.end);\n        } else {\n          target.end.copy(edge2.end);\n        }\n      }\n      return true;\n    }\n  };\n}();\nExtendedTriangle.prototype.distanceToPoint = function () {\n  const target = new Vector3();\n  return function distanceToPoint(point) {\n    this.closestPointToPoint(point, target);\n    return point.distanceTo(target);\n  };\n}();\nExtendedTriangle.prototype.distanceToTriangle = function () {\n  const point = new Vector3();\n  const point2 = new Vector3();\n  const cornerFields = ['a', 'b', 'c'];\n  const line1 = new Line3();\n  const line2 = new Line3();\n  return function distanceToTriangle(other, target1 = null, target2 = null) {\n    const lineTarget = target1 || target2 ? line1 : null;\n    if (this.intersectsTriangle(other, lineTarget)) {\n      if (target1 || target2) {\n        if (target1) lineTarget.getCenter(target1);\n        if (target2) lineTarget.getCenter(target2);\n      }\n      return 0;\n    }\n    let closestDistanceSq = Infinity;\n\n    // check all point distances\n    for (let i = 0; i < 3; i++) {\n      let dist;\n      const field = cornerFields[i];\n      const otherVec = other[field];\n      this.closestPointToPoint(otherVec, point);\n      dist = otherVec.distanceToSquared(point);\n      if (dist < closestDistanceSq) {\n        closestDistanceSq = dist;\n        if (target1) target1.copy(point);\n        if (target2) target2.copy(otherVec);\n      }\n      const thisVec = this[field];\n      other.closestPointToPoint(thisVec, point);\n      dist = thisVec.distanceToSquared(point);\n      if (dist < closestDistanceSq) {\n        closestDistanceSq = dist;\n        if (target1) target1.copy(thisVec);\n        if (target2) target2.copy(point);\n      }\n    }\n    for (let i = 0; i < 3; i++) {\n      const f11 = cornerFields[i];\n      const f12 = cornerFields[(i + 1) % 3];\n      line1.set(this[f11], this[f12]);\n      for (let i2 = 0; i2 < 3; i2++) {\n        const f21 = cornerFields[i2];\n        const f22 = cornerFields[(i2 + 1) % 3];\n        line2.set(other[f21], other[f22]);\n        closestPointsSegmentToSegment(line1, line2, point, point2);\n        const dist = point.distanceToSquared(point2);\n        if (dist < closestDistanceSq) {\n          closestDistanceSq = dist;\n          if (target1) target1.copy(point);\n          if (target2) target2.copy(point2);\n        }\n      }\n    }\n    return Math.sqrt(closestDistanceSq);\n  };\n}();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}