{"ast":null,"code":"import { NFTStorage } from 'nft.storage';\nconst NFT_STORAGE_KEY = process.env.REACT_APP_NFT_STORAGE_KEY;\nconsole.log('Starting NFT.Storage setup with new API format...');\nif (!NFT_STORAGE_KEY) {\n  throw new Error('NFT Storage API key not found');\n}\n\n// Add the 'Bearer' prefix to the API key\nconst authHeader = `Bearer ${NFT_STORAGE_KEY.trim()}`;\nexport const uploadToIPFS = async (glbUrl, originalNFT) => {\n  try {\n    var _uploadData$value, _metadataData$value;\n    console.log('Starting upload process...');\n\n    // First get the GLB file\n    console.log('Fetching GLB from:', glbUrl);\n    const response = await fetch(glbUrl);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch GLB: ${response.status}`);\n    }\n    const glbBlob = await response.blob();\n    console.log('GLB file fetched:', {\n      size: glbBlob.size,\n      type: glbBlob.type\n    });\n\n    // Create form data for upload\n    const formData = new FormData();\n    formData.append('file', glbBlob, 'model.glb');\n\n    // Direct API call with proper headers\n    const uploadResponse = await fetch('https://preserve.nft.storage/api/v1/collection/add_tokens', {\n      method: 'POST',\n      headers: {\n        'Authorization': authHeader,\n        'Accept': 'application/json'\n      },\n      body: formData\n    });\n    if (!uploadResponse.ok) {\n      const error = await uploadResponse.json();\n      console.error('Upload response:', error);\n      throw new Error(`Upload failed: ${JSON.stringify(error)}`);\n    }\n    const uploadData = await uploadResponse.json();\n    console.log('Upload response:', uploadData);\n    const cid = uploadData.cid || ((_uploadData$value = uploadData.value) === null || _uploadData$value === void 0 ? void 0 : _uploadData$value.cid);\n    if (!cid) {\n      throw new Error('No CID returned from upload');\n    }\n    console.log('File uploaded to IPFS:', cid);\n\n    // Create metadata\n    const metadata = {\n      name: `Beamit AI Avatar #${Date.now()}`,\n      description: \"AI-Generated 3D Avatar from Beamit\",\n      image: `ipfs://${cid}`,\n      animation_url: `ipfs://${cid}`,\n      attributes: [{\n        trait_type: \"Original NFT ID\",\n        value: originalNFT.tokenId\n      }, {\n        trait_type: \"Original Chain ID\",\n        value: originalNFT.chainId\n      }]\n    };\n\n    // Upload metadata\n    const metadataBlob = new Blob([JSON.stringify(metadata)], {\n      type: 'application/json'\n    });\n    const metadataFormData = new FormData();\n    metadataFormData.append('file', metadataBlob, 'metadata.json');\n    const metadataResponse = await fetch('https://preserve.nft.storage/api/v1/collection/add_tokens', {\n      method: 'POST',\n      headers: {\n        'Authorization': authHeader,\n        'Accept': 'application/json'\n      },\n      body: metadataFormData\n    });\n    if (!metadataResponse.ok) {\n      const error = await metadataResponse.json();\n      console.error('Metadata response:', error);\n      throw new Error(`Metadata upload failed: ${JSON.stringify(error)}`);\n    }\n    const metadataData = await metadataResponse.json();\n    const metadataCid = metadataData.cid || ((_metadataData$value = metadataData.value) === null || _metadataData$value === void 0 ? void 0 : _metadataData$value.cid);\n    if (!metadataCid) {\n      throw new Error('No CID returned from metadata upload');\n    }\n    console.log('Metadata uploaded:', metadataCid);\n    return `ipfs://${metadataCid}`;\n  } catch (error) {\n    console.error('Upload error:', {\n      message: error.message,\n      name: error.name,\n      response: error.response\n    });\n    throw error;\n  }\n};","map":{"version":3,"names":["NFTStorage","NFT_STORAGE_KEY","process","env","REACT_APP_NFT_STORAGE_KEY","console","log","Error","authHeader","trim","uploadToIPFS","glbUrl","originalNFT","_uploadData$value","_metadataData$value","response","fetch","ok","status","glbBlob","blob","size","type","formData","FormData","append","uploadResponse","method","headers","body","error","json","JSON","stringify","uploadData","cid","value","metadata","name","Date","now","description","image","animation_url","attributes","trait_type","tokenId","chainId","metadataBlob","Blob","metadataFormData","metadataResponse","metadataData","metadataCid","message"],"sources":["/Users/thomasheindl/Documents/beamitai01/beamitai/frontend/src/utils/ipfsHandler.js"],"sourcesContent":["import { NFTStorage } from 'nft.storage';\n\nconst NFT_STORAGE_KEY = process.env.REACT_APP_NFT_STORAGE_KEY;\n\nconsole.log('Starting NFT.Storage setup with new API format...');\n\nif (!NFT_STORAGE_KEY) {\n    throw new Error('NFT Storage API key not found');\n}\n\n// Add the 'Bearer' prefix to the API key\nconst authHeader = `Bearer ${NFT_STORAGE_KEY.trim()}`;\n\nexport const uploadToIPFS = async (glbUrl, originalNFT) => {\n    try {\n        console.log('Starting upload process...');\n        \n        // First get the GLB file\n        console.log('Fetching GLB from:', glbUrl);\n        const response = await fetch(glbUrl);\n        if (!response.ok) {\n            throw new Error(`Failed to fetch GLB: ${response.status}`);\n        }\n        const glbBlob = await response.blob();\n        console.log('GLB file fetched:', {\n            size: glbBlob.size,\n            type: glbBlob.type\n        });\n\n        // Create form data for upload\n        const formData = new FormData();\n        formData.append('file', glbBlob, 'model.glb');\n\n        // Direct API call with proper headers\n        const uploadResponse = await fetch('https://preserve.nft.storage/api/v1/collection/add_tokens', {\n            method: 'POST',\n            headers: {\n                'Authorization': authHeader,\n                'Accept': 'application/json'\n            },\n            body: formData\n        });\n\n        if (!uploadResponse.ok) {\n            const error = await uploadResponse.json();\n            console.error('Upload response:', error);\n            throw new Error(`Upload failed: ${JSON.stringify(error)}`);\n        }\n\n        const uploadData = await uploadResponse.json();\n        console.log('Upload response:', uploadData);\n\n        const cid = uploadData.cid || uploadData.value?.cid;\n        if (!cid) {\n            throw new Error('No CID returned from upload');\n        }\n\n        console.log('File uploaded to IPFS:', cid);\n\n        // Create metadata\n        const metadata = {\n            name: `Beamit AI Avatar #${Date.now()}`,\n            description: \"AI-Generated 3D Avatar from Beamit\",\n            image: `ipfs://${cid}`,\n            animation_url: `ipfs://${cid}`,\n            attributes: [\n                {\n                    trait_type: \"Original NFT ID\",\n                    value: originalNFT.tokenId\n                },\n                {\n                    trait_type: \"Original Chain ID\",\n                    value: originalNFT.chainId\n                }\n            ]\n        };\n\n        // Upload metadata\n        const metadataBlob = new Blob([JSON.stringify(metadata)], { \n            type: 'application/json' \n        });\n        \n        const metadataFormData = new FormData();\n        metadataFormData.append('file', metadataBlob, 'metadata.json');\n\n        const metadataResponse = await fetch('https://preserve.nft.storage/api/v1/collection/add_tokens', {\n            method: 'POST',\n            headers: {\n                'Authorization': authHeader,\n                'Accept': 'application/json'\n            },\n            body: metadataFormData\n        });\n\n        if (!metadataResponse.ok) {\n            const error = await metadataResponse.json();\n            console.error('Metadata response:', error);\n            throw new Error(`Metadata upload failed: ${JSON.stringify(error)}`);\n        }\n\n        const metadataData = await metadataResponse.json();\n        const metadataCid = metadataData.cid || metadataData.value?.cid;\n        \n        if (!metadataCid) {\n            throw new Error('No CID returned from metadata upload');\n        }\n\n        console.log('Metadata uploaded:', metadataCid);\n        return `ipfs://${metadataCid}`;\n    } catch (error) {\n        console.error('Upload error:', {\n            message: error.message,\n            name: error.name,\n            response: error.response\n        });\n        throw error;\n    }\n};\n"],"mappings":"AAAA,SAASA,UAAU,QAAQ,aAAa;AAExC,MAAMC,eAAe,GAAGC,OAAO,CAACC,GAAG,CAACC,yBAAyB;AAE7DC,OAAO,CAACC,GAAG,CAAC,mDAAmD,CAAC;AAEhE,IAAI,CAACL,eAAe,EAAE;EAClB,MAAM,IAAIM,KAAK,CAAC,+BAA+B,CAAC;AACpD;;AAEA;AACA,MAAMC,UAAU,GAAG,UAAUP,eAAe,CAACQ,IAAI,CAAC,CAAC,EAAE;AAErD,OAAO,MAAMC,YAAY,GAAG,MAAAA,CAAOC,MAAM,EAAEC,WAAW,KAAK;EACvD,IAAI;IAAA,IAAAC,iBAAA,EAAAC,mBAAA;IACAT,OAAO,CAACC,GAAG,CAAC,4BAA4B,CAAC;;IAEzC;IACAD,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAEK,MAAM,CAAC;IACzC,MAAMI,QAAQ,GAAG,MAAMC,KAAK,CAACL,MAAM,CAAC;IACpC,IAAI,CAACI,QAAQ,CAACE,EAAE,EAAE;MACd,MAAM,IAAIV,KAAK,CAAC,wBAAwBQ,QAAQ,CAACG,MAAM,EAAE,CAAC;IAC9D;IACA,MAAMC,OAAO,GAAG,MAAMJ,QAAQ,CAACK,IAAI,CAAC,CAAC;IACrCf,OAAO,CAACC,GAAG,CAAC,mBAAmB,EAAE;MAC7Be,IAAI,EAAEF,OAAO,CAACE,IAAI;MAClBC,IAAI,EAAEH,OAAO,CAACG;IAClB,CAAC,CAAC;;IAEF;IACA,MAAMC,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;IAC/BD,QAAQ,CAACE,MAAM,CAAC,MAAM,EAAEN,OAAO,EAAE,WAAW,CAAC;;IAE7C;IACA,MAAMO,cAAc,GAAG,MAAMV,KAAK,CAAC,2DAA2D,EAAE;MAC5FW,MAAM,EAAE,MAAM;MACdC,OAAO,EAAE;QACL,eAAe,EAAEpB,UAAU;QAC3B,QAAQ,EAAE;MACd,CAAC;MACDqB,IAAI,EAAEN;IACV,CAAC,CAAC;IAEF,IAAI,CAACG,cAAc,CAACT,EAAE,EAAE;MACpB,MAAMa,KAAK,GAAG,MAAMJ,cAAc,CAACK,IAAI,CAAC,CAAC;MACzC1B,OAAO,CAACyB,KAAK,CAAC,kBAAkB,EAAEA,KAAK,CAAC;MACxC,MAAM,IAAIvB,KAAK,CAAC,kBAAkByB,IAAI,CAACC,SAAS,CAACH,KAAK,CAAC,EAAE,CAAC;IAC9D;IAEA,MAAMI,UAAU,GAAG,MAAMR,cAAc,CAACK,IAAI,CAAC,CAAC;IAC9C1B,OAAO,CAACC,GAAG,CAAC,kBAAkB,EAAE4B,UAAU,CAAC;IAE3C,MAAMC,GAAG,GAAGD,UAAU,CAACC,GAAG,MAAAtB,iBAAA,GAAIqB,UAAU,CAACE,KAAK,cAAAvB,iBAAA,uBAAhBA,iBAAA,CAAkBsB,GAAG;IACnD,IAAI,CAACA,GAAG,EAAE;MACN,MAAM,IAAI5B,KAAK,CAAC,6BAA6B,CAAC;IAClD;IAEAF,OAAO,CAACC,GAAG,CAAC,wBAAwB,EAAE6B,GAAG,CAAC;;IAE1C;IACA,MAAME,QAAQ,GAAG;MACbC,IAAI,EAAE,qBAAqBC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;MACvCC,WAAW,EAAE,oCAAoC;MACjDC,KAAK,EAAE,UAAUP,GAAG,EAAE;MACtBQ,aAAa,EAAE,UAAUR,GAAG,EAAE;MAC9BS,UAAU,EAAE,CACR;QACIC,UAAU,EAAE,iBAAiB;QAC7BT,KAAK,EAAExB,WAAW,CAACkC;MACvB,CAAC,EACD;QACID,UAAU,EAAE,mBAAmB;QAC/BT,KAAK,EAAExB,WAAW,CAACmC;MACvB,CAAC;IAET,CAAC;;IAED;IACA,MAAMC,YAAY,GAAG,IAAIC,IAAI,CAAC,CAACjB,IAAI,CAACC,SAAS,CAACI,QAAQ,CAAC,CAAC,EAAE;MACtDf,IAAI,EAAE;IACV,CAAC,CAAC;IAEF,MAAM4B,gBAAgB,GAAG,IAAI1B,QAAQ,CAAC,CAAC;IACvC0B,gBAAgB,CAACzB,MAAM,CAAC,MAAM,EAAEuB,YAAY,EAAE,eAAe,CAAC;IAE9D,MAAMG,gBAAgB,GAAG,MAAMnC,KAAK,CAAC,2DAA2D,EAAE;MAC9FW,MAAM,EAAE,MAAM;MACdC,OAAO,EAAE;QACL,eAAe,EAAEpB,UAAU;QAC3B,QAAQ,EAAE;MACd,CAAC;MACDqB,IAAI,EAAEqB;IACV,CAAC,CAAC;IAEF,IAAI,CAACC,gBAAgB,CAAClC,EAAE,EAAE;MACtB,MAAMa,KAAK,GAAG,MAAMqB,gBAAgB,CAACpB,IAAI,CAAC,CAAC;MAC3C1B,OAAO,CAACyB,KAAK,CAAC,oBAAoB,EAAEA,KAAK,CAAC;MAC1C,MAAM,IAAIvB,KAAK,CAAC,2BAA2ByB,IAAI,CAACC,SAAS,CAACH,KAAK,CAAC,EAAE,CAAC;IACvE;IAEA,MAAMsB,YAAY,GAAG,MAAMD,gBAAgB,CAACpB,IAAI,CAAC,CAAC;IAClD,MAAMsB,WAAW,GAAGD,YAAY,CAACjB,GAAG,MAAArB,mBAAA,GAAIsC,YAAY,CAAChB,KAAK,cAAAtB,mBAAA,uBAAlBA,mBAAA,CAAoBqB,GAAG;IAE/D,IAAI,CAACkB,WAAW,EAAE;MACd,MAAM,IAAI9C,KAAK,CAAC,sCAAsC,CAAC;IAC3D;IAEAF,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAE+C,WAAW,CAAC;IAC9C,OAAO,UAAUA,WAAW,EAAE;EAClC,CAAC,CAAC,OAAOvB,KAAK,EAAE;IACZzB,OAAO,CAACyB,KAAK,CAAC,eAAe,EAAE;MAC3BwB,OAAO,EAAExB,KAAK,CAACwB,OAAO;MACtBhB,IAAI,EAAER,KAAK,CAACQ,IAAI;MAChBvB,QAAQ,EAAEe,KAAK,CAACf;IACpB,CAAC,CAAC;IACF,MAAMe,KAAK;EACf;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}