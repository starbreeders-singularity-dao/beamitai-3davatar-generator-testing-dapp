{"ast":null,"code":"import { Vector3, Vector2, Plane, Line3 } from 'three';\nexport const closestPointLineToLine = function () {\n  // https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n  const dir1 = new Vector3();\n  const dir2 = new Vector3();\n  const v02 = new Vector3();\n  return function closestPointLineToLine(l1, l2, result) {\n    const v0 = l1.start;\n    const v10 = dir1;\n    const v2 = l2.start;\n    const v32 = dir2;\n    v02.subVectors(v0, v2);\n    dir1.subVectors(l1.end, l1.start);\n    dir2.subVectors(l2.end, l2.start);\n\n    // float d0232 = v02.Dot(v32);\n    const d0232 = v02.dot(v32);\n\n    // float d3210 = v32.Dot(v10);\n    const d3210 = v32.dot(v10);\n\n    // float d3232 = v32.Dot(v32);\n    const d3232 = v32.dot(v32);\n\n    // float d0210 = v02.Dot(v10);\n    const d0210 = v02.dot(v10);\n\n    // float d1010 = v10.Dot(v10);\n    const d1010 = v10.dot(v10);\n\n    // float denom = d1010*d3232 - d3210*d3210;\n    const denom = d1010 * d3232 - d3210 * d3210;\n    let d, d2;\n    if (denom !== 0) {\n      d = (d0232 * d3210 - d0210 * d3232) / denom;\n    } else {\n      d = 0;\n    }\n    d2 = (d0232 + d * d3210) / d3232;\n    result.x = d;\n    result.y = d2;\n  };\n}();\nexport const closestPointsSegmentToSegment = function () {\n  // https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n  const paramResult = new Vector2();\n  const temp1 = new Vector3();\n  const temp2 = new Vector3();\n  return function closestPointsSegmentToSegment(l1, l2, target1, target2) {\n    closestPointLineToLine(l1, l2, paramResult);\n    let d = paramResult.x;\n    let d2 = paramResult.y;\n    if (d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1) {\n      l1.at(d, target1);\n      l2.at(d2, target2);\n      return;\n    } else if (d >= 0 && d <= 1) {\n      // Only d2 is out of bounds.\n      if (d2 < 0) {\n        l2.at(0, target2);\n      } else {\n        l2.at(1, target2);\n      }\n      l1.closestPointToPoint(target2, true, target1);\n      return;\n    } else if (d2 >= 0 && d2 <= 1) {\n      // Only d is out of bounds.\n      if (d < 0) {\n        l1.at(0, target1);\n      } else {\n        l1.at(1, target1);\n      }\n      l2.closestPointToPoint(target1, true, target2);\n      return;\n    } else {\n      // Both u and u2 are out of bounds.\n      let p;\n      if (d < 0) {\n        p = l1.start;\n      } else {\n        p = l1.end;\n      }\n      let p2;\n      if (d2 < 0) {\n        p2 = l2.start;\n      } else {\n        p2 = l2.end;\n      }\n      const closestPoint = temp1;\n      const closestPoint2 = temp2;\n      l1.closestPointToPoint(p2, true, temp1);\n      l2.closestPointToPoint(p, true, temp2);\n      if (closestPoint.distanceToSquared(p2) <= closestPoint2.distanceToSquared(p)) {\n        target1.copy(closestPoint);\n        target2.copy(p2);\n        return;\n      } else {\n        target1.copy(p);\n        target2.copy(closestPoint2);\n        return;\n      }\n    }\n  };\n}();\nexport const sphereIntersectTriangle = function () {\n  // https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n  const closestPointTemp = new Vector3();\n  const projectedPointTemp = new Vector3();\n  const planeTemp = new Plane();\n  const lineTemp = new Line3();\n  return function sphereIntersectTriangle(sphere, triangle) {\n    const {\n      radius,\n      center\n    } = sphere;\n    const {\n      a,\n      b,\n      c\n    } = triangle;\n\n    // phase 1\n    lineTemp.start = a;\n    lineTemp.end = b;\n    const closestPoint1 = lineTemp.closestPointToPoint(center, true, closestPointTemp);\n    if (closestPoint1.distanceTo(center) <= radius) return true;\n    lineTemp.start = a;\n    lineTemp.end = c;\n    const closestPoint2 = lineTemp.closestPointToPoint(center, true, closestPointTemp);\n    if (closestPoint2.distanceTo(center) <= radius) return true;\n    lineTemp.start = b;\n    lineTemp.end = c;\n    const closestPoint3 = lineTemp.closestPointToPoint(center, true, closestPointTemp);\n    if (closestPoint3.distanceTo(center) <= radius) return true;\n\n    // phase 2\n    const plane = triangle.getPlane(planeTemp);\n    const dp = Math.abs(plane.distanceToPoint(center));\n    if (dp <= radius) {\n      const pp = plane.projectPoint(center, projectedPointTemp);\n      const cp = triangle.containsPoint(pp);\n      if (cp) return true;\n    }\n    return false;\n  };\n}();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}