{"ast":null,"code":"import { PerspectiveCamera, ShaderMaterial, Scene, OrthographicCamera, WebGLRenderTarget, UniformsUtils, Mesh, PlaneGeometry } from \"three\";\nimport { BokehDepthShader, BokehShader2 } from \"../shaders/BokehShader2.js\";\nclass CinematicCamera extends PerspectiveCamera {\n  constructor(fov, aspect, near, far) {\n    super(fov, aspect, near, far);\n    this.type = \"CinematicCamera\";\n    this.postprocessing = {\n      enabled: true\n    };\n    this.shaderSettings = {\n      rings: 3,\n      samples: 4\n    };\n    const depthShader = BokehDepthShader;\n    this.materialDepth = new ShaderMaterial({\n      uniforms: depthShader.uniforms,\n      vertexShader: depthShader.vertexShader,\n      fragmentShader: depthShader.fragmentShader\n    });\n    this.materialDepth.uniforms[\"mNear\"].value = near;\n    this.materialDepth.uniforms[\"mFar\"].value = far;\n    this.setLens();\n    this.initPostProcessing();\n  }\n  // providing fnumber and coc(Circle of Confusion) as extra arguments\n  setLens(focalLength, filmGauge, fNumber, coc) {\n    if (focalLength === void 0) focalLength = 35;\n    if (filmGauge !== void 0) this.filmGauge = filmGauge;\n    this.setFocalLength(focalLength);\n    if (fNumber === void 0) fNumber = 8;\n    if (coc === void 0) coc = 0.019;\n    this.fNumber = fNumber;\n    this.coc = coc;\n    this.aperture = focalLength / this.fNumber;\n    this.hyperFocal = focalLength * focalLength / (this.aperture * this.coc);\n  }\n  linearize(depth) {\n    const zfar = this.far;\n    const znear = this.near;\n    return -zfar * znear / (depth * (zfar - znear) - zfar);\n  }\n  smoothstep(near, far, depth) {\n    const x = this.saturate((depth - near) / (far - near));\n    return x * x * (3 - 2 * x);\n  }\n  saturate(x) {\n    return Math.max(0, Math.min(1, x));\n  }\n  // function for focusing at a distance from the camera\n  focusAt(focusDistance) {\n    if (focusDistance === void 0) focusDistance = 20;\n    const focalLength = this.getFocalLength();\n    this.focus = focusDistance;\n    this.nearPoint = this.hyperFocal * this.focus / (this.hyperFocal + (this.focus - focalLength));\n    this.farPoint = this.hyperFocal * this.focus / (this.hyperFocal - (this.focus - focalLength));\n    this.depthOfField = this.farPoint - this.nearPoint;\n    if (this.depthOfField < 0) this.depthOfField = 0;\n    this.sdistance = this.smoothstep(this.near, this.far, this.focus);\n    this.ldistance = this.linearize(1 - this.sdistance);\n    this.postprocessing.bokeh_uniforms[\"focalDepth\"].value = this.ldistance;\n  }\n  initPostProcessing() {\n    if (this.postprocessing.enabled) {\n      this.postprocessing.scene = new Scene();\n      this.postprocessing.camera = new OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, -1e4, 1e4);\n      this.postprocessing.scene.add(this.postprocessing.camera);\n      this.postprocessing.rtTextureDepth = new WebGLRenderTarget(window.innerWidth, window.innerHeight);\n      this.postprocessing.rtTextureColor = new WebGLRenderTarget(window.innerWidth, window.innerHeight);\n      const bokeh_shader = BokehShader2;\n      this.postprocessing.bokeh_uniforms = UniformsUtils.clone(bokeh_shader.uniforms);\n      this.postprocessing.bokeh_uniforms[\"tColor\"].value = this.postprocessing.rtTextureColor.texture;\n      this.postprocessing.bokeh_uniforms[\"tDepth\"].value = this.postprocessing.rtTextureDepth.texture;\n      this.postprocessing.bokeh_uniforms[\"manualdof\"].value = 0;\n      this.postprocessing.bokeh_uniforms[\"shaderFocus\"].value = 0;\n      this.postprocessing.bokeh_uniforms[\"fstop\"].value = 2.8;\n      this.postprocessing.bokeh_uniforms[\"showFocus\"].value = 1;\n      this.postprocessing.bokeh_uniforms[\"focalDepth\"].value = 0.1;\n      this.postprocessing.bokeh_uniforms[\"znear\"].value = this.near;\n      this.postprocessing.bokeh_uniforms[\"zfar\"].value = this.near;\n      this.postprocessing.bokeh_uniforms[\"textureWidth\"].value = window.innerWidth;\n      this.postprocessing.bokeh_uniforms[\"textureHeight\"].value = window.innerHeight;\n      this.postprocessing.materialBokeh = new ShaderMaterial({\n        uniforms: this.postprocessing.bokeh_uniforms,\n        vertexShader: bokeh_shader.vertexShader,\n        fragmentShader: bokeh_shader.fragmentShader,\n        defines: {\n          RINGS: this.shaderSettings.rings,\n          SAMPLES: this.shaderSettings.samples,\n          DEPTH_PACKING: 1\n        }\n      });\n      this.postprocessing.quad = new Mesh(new PlaneGeometry(window.innerWidth, window.innerHeight), this.postprocessing.materialBokeh);\n      this.postprocessing.quad.position.z = -500;\n      this.postprocessing.scene.add(this.postprocessing.quad);\n    }\n  }\n  renderCinematic(scene, renderer) {\n    if (this.postprocessing.enabled) {\n      const currentRenderTarget = renderer.getRenderTarget();\n      renderer.clear();\n      scene.overrideMaterial = null;\n      renderer.setRenderTarget(this.postprocessing.rtTextureColor);\n      renderer.clear();\n      renderer.render(scene, this);\n      scene.overrideMaterial = this.materialDepth;\n      renderer.setRenderTarget(this.postprocessing.rtTextureDepth);\n      renderer.clear();\n      renderer.render(scene, this);\n      renderer.setRenderTarget(null);\n      renderer.render(this.postprocessing.scene, this.postprocessing.camera);\n      renderer.setRenderTarget(currentRenderTarget);\n    }\n  }\n}\nexport { CinematicCamera };\n//# sourceMappingURL=CinematicCamera.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}