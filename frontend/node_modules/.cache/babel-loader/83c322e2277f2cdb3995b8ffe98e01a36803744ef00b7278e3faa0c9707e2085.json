{"ast":null,"code":"import { pack } from 'ipfs-car/pack';\nimport { CID } from 'multiformats/cid';\nimport * as Block from 'multiformats/block';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport * as dagCbor from '@ipld/dag-cbor';\nimport { Blob, FormData, Blockstore } from './platform.js';\nimport { toGatewayURL, GATEWAY } from './gateway.js';\nimport { BlockstoreCarReader } from './bs-car-reader.js';\n\n/**\n * @typedef {import('./gateway.js').GatewayURLOptions} EmbedOptions\n * @typedef {import('./lib/interface.js').TokenInput} TokenInput\n * @typedef {import('ipfs-car/blockstore').Blockstore} Blockstore\n */\n\n/**\n * @template T\n * @typedef {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} EncodedBlobUrl\n */\n\n/**\n * @template G\n * @typedef {import('./lib/interface.js').Encoded<G, [[Blob, Blob]]>} EncodedBlobBlob\n */\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @template {TokenInput} T\n * @implements {TokenType<T>}\n */\nexport class Token {\n  /**\n   * @param {import('./lib/interface.js').CIDString} ipnft\n   * @param {import('./lib/interface.js').EncodedURL} url\n   * @param {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} data\n   */\n  constructor(ipnft, url, data) {\n    /** @readonly */\n    this.ipnft = ipnft;\n    /** @readonly */\n    this.url = url;\n    /** @readonly */\n    this.data = data;\n    Object.defineProperties(this, {\n      ipnft: {\n        enumerable: true,\n        writable: false\n      },\n      url: {\n        enumerable: true,\n        writable: false\n      },\n      data: {\n        enumerable: false,\n        writable: false\n      }\n    });\n  }\n  /**\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n  embed() {\n    return Token.embed(this);\n  }\n\n  /**\n   * @template {TokenInput} T\n   * @param {{data: import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}} token\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n  static embed({\n    data\n  }) {\n    return embed(data, {\n      gateway: GATEWAY\n    });\n  }\n\n  /**\n   * Takes token input, encodes it as a DAG, wraps it in a CAR and creates a new\n   * Token instance from it. Where values are discovered `Blob` (or `File`)\n   * objects in the given input, they are replaced with IPFS URLs (an `ipfs://`\n   * prefixed CID with an optional path).\n   *\n   * @example\n   * ```js\n   * const cat = new File(['...'], 'cat.png')\n   * const kitty = new File(['...'], 'kitty.png')\n   * const { token, car } = await Token.encode({\n   *   name: 'hello'\n   *   image: cat\n   *   properties: {\n   *     extra: {\n   *       image: kitty\n   *     }\n   *   }\n   * })\n   * ```\n   *\n   * @template {TokenInput} T\n   * @param {T} input\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: import('./lib/interface.js').CarReader }>}\n   */\n  static async encode(input) {\n    const blockstore = new Blockstore();\n    const [blobs, meta] = mapTokenInputBlobs(input);\n    /** @type {EncodedBlobUrl<T>} */\n    const data = JSON.parse(JSON.stringify(meta));\n    /** @type {import('./lib/interface.js').Encoded<T, [[Blob, CID]]>} */\n    const dag = JSON.parse(JSON.stringify(meta));\n    for (const [dotPath, blob] of blobs.entries()) {\n      /** @type {string|undefined} */\n      // @ts-ignore blob may be a File!\n      const name = blob.name || 'blob';\n      /** @type {import('./platform.js').ReadableStream} */\n      let content;\n      // FIXME: should not be necessary to await arrayBuffer()!\n      // Node.js 20 hangs reading the stream (it never ends) but in\n      // older node versions and the browser it is fine to use blob.stream().\n      /* c8 ignore next 5 */\n      if (parseInt(globalThis.process?.versions?.node) > 18) {\n        content = new Uint8Array(await blob.arrayBuffer());\n      } else {\n        content = blob.stream();\n      }\n      const {\n        root: cid\n      } = await pack({\n        input: [{\n          path: name,\n          content\n        }],\n        blockstore,\n        wrapWithDirectory: true\n      });\n      const href = new URL(`ipfs://${cid}/${name}`);\n      const path = dotPath.split('.');\n      setIn(data, path, href);\n      setIn(dag, path, cid);\n    }\n    const {\n      root: metadataJsonCid\n    } = await pack({\n      input: [{\n        path: 'metadata.json',\n        content: JSON.stringify(data)\n      }],\n      blockstore,\n      wrapWithDirectory: false\n    });\n    const block = await Block.encode({\n      value: {\n        ...dag,\n        'metadata.json': metadataJsonCid,\n        type: 'nft'\n      },\n      codec: dagCbor,\n      hasher: sha256\n    });\n    await blockstore.put(block.cid, block.bytes);\n    return {\n      cid: block.cid,\n      token: new Token(block.cid.toString(), `ipfs://${block.cid}/metadata.json`, data),\n      car: new BlockstoreCarReader(1, [block.cid], blockstore)\n    };\n  }\n}\n\n/**\n * @template T\n * @param {EncodedBlobUrl<T>} input\n * @param {EmbedOptions} options\n * @returns {EncodedBlobUrl<T>}\n */\nexport const embed = (input, options) => mapWith(input, isURL, embedURL, options);\n\n/**\n * @template {TokenInput} T\n * @param {import('./lib/interface.js').EncodedToken<T>} value\n * @param {Set<string>} paths - Paths were to expect EncodedURLs\n * @returns {Token<T>}\n */\nexport const decode = ({\n  ipnft,\n  url,\n  data\n}, paths) => new Token(ipnft, url, mapWith(data, isEncodedURL, decodeURL, paths));\n\n/**\n * @param {any} value\n * @returns {value is URL}\n */\nconst isURL = value => value instanceof URL;\n\n/**\n * @template State\n * @param {State} state\n * @param {import('./lib/interface.js').EncodedURL} url\n * @returns {[State, URL]}\n */\nconst decodeURL = (state, url) => [state, new URL(url)];\n\n/**\n * @param {EmbedOptions} context\n * @param {URL} url\n * @returns {[EmbedOptions, URL]}\n */\nconst embedURL = (context, url) => [context, toGatewayURL(url, context)];\n\n/**\n * @param {any} value\n * @returns {value is object}\n */\nconst isObject = value => typeof value === 'object' && value != null;\n\n/**\n * @param {any} value\n * @param {Set<string>} assetPaths\n * @param {PropertyKey[]} path\n * @returns {value is import('./lib/interface.js').EncodedURL}\n */\nconst isEncodedURL = (value, assetPaths, path) => typeof value === 'string' && assetPaths.has(path.join('.'));\n\n/**\n * Takes token input and encodes it into\n * [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n * object where form field values are discovered `Blob` (or `File`) objects in\n * the given token and field keys are `.` joined paths where they were discoverd\n * in the token. Additionally encoded `FormData` will also have a field\n * named `meta` containing JSON serialized token with blobs and file values\n * `null` set to null (this allows backend to injest all of the files from\n * `multipart/form-data` request and update provided \"meta\" data with\n * corresponding file ipfs:// URLs)\n *\n * @example\n * ```js\n * const cat = new File([], 'cat.png')\n * const kitty = new File([], 'kitty.png')\n * const form = encode({\n *   name: 'hello'\n *   image: cat\n *   properties: {\n *     extra: {\n *       image: kitty\n *     }\n *   }\n * })\n * [...form.entries()] //>\n * // [\n * //   ['image', cat],\n * //   ['properties.extra.image', kitty],\n * //   ['meta', '{\"name\":\"hello\",image:null,\"properties\":{\"extra\":{\"kitty\": null}}}']\n * // ]\n * ```\n *\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n * @returns {FormData}\n */\nexport const encode = input => {\n  const [map, meta] = mapValueWith(input, isBlob, encodeBlob, new Map(), []);\n  const form = new FormData();\n  for (const [k, v] of map.entries()) {\n    form.set(k, v);\n  }\n  form.set('meta', JSON.stringify(meta));\n  return form;\n};\n\n/**\n * @param {Map<string, Blob>} data\n * @param {Blob} blob\n * @param {PropertyKey[]} path\n * @returns {[Map<string, Blob>, void]}\n */\nconst encodeBlob = (data, blob, path) => {\n  data.set(path.join('.'), blob);\n  return [data, undefined];\n};\n\n/**\n * @param {any} value\n * @returns {value is Blob}\n */\nconst isBlob = value => value instanceof Blob;\n\n/**\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n */\nconst mapTokenInputBlobs = input => {\n  return mapValueWith(input, isBlob, encodeBlob, new Map(), []);\n};\n\n/**\n * Substitues values in the given `input` that match `p(value) == true` with\n * `f(value, context, path)` where `context` is whatever you pass (usually\n * a mutable state) and `path` is a array of keys / indexes where the value\n * was encountered.\n *\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * likey you'll start with `[]`.\n * @returns {import('./lib/interface.js').Encoded<T, [[I, O]]>}\n */\nexport const mapWith = (input, p, f, state) => {\n  const [, output] = mapValueWith(input, p, f, state, []);\n  return output;\n};\n\n/**\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * @param {PropertyKey[]} path - Path where the value was encountered. Most\n * likey you'll start with `[]`.\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapValueWith = (input, p, f, state, path) => p(input, state, path) ? f(state, input, path) : Array.isArray(input) ? mapArrayWith(input, p, f, state, path) : isObject(input) ? mapObjectWith(input, p, f, state, path) : [state, (/** @type {any} */input)];\n\n/**\n * Just like `mapWith` except\n *\n * @template State, T, I, X, O\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapObjectWith = (input, p, f, init, path) => {\n  let state = init;\n  const output = /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */{};\n  for (const [key, value] of Object.entries(input)) {\n    const [next, out] = mapValueWith(value, p, f, state, [...path, key]);\n    // @ts-ignore\n    output[key] = out;\n    state = next;\n  }\n  return [state, output];\n};\n\n/**\n * Just like `mapWith` except for Arrays.\n *\n * @template I, X, O, State\n * @template {any[]} T\n * @param {T} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapArrayWith = (input, p, f, init, path) => {\n  const output = /** @type {unknown[]} */[];\n  let state = init;\n  for (const [index, element] of input.entries()) {\n    const [next, out] = mapValueWith(element, p, f, state, [...path, index]);\n    output[index] = out;\n    state = next;\n  }\n  return [state, (/** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */output)];\n};\n\n/**\n * Sets a given `value` at the given `path` on a passed `object`.\n *\n * @example\n * ```js\n * const obj = { a: { b: { c: 1 }}}\n * setIn(obj, ['a', 'b', 'c'], 5)\n * obj.a.b.c //> 5\n * ```\n *\n * @template V\n * @param {any} object\n * @param {string[]} path\n * @param {V} value\n */\nconst setIn = (object, path, value) => {\n  const n = path.length - 1;\n  let target = object;\n  for (let [index, key] of path.entries()) {\n    if (index === n) {\n      target[key] = value;\n    } else {\n      target = target[key];\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}