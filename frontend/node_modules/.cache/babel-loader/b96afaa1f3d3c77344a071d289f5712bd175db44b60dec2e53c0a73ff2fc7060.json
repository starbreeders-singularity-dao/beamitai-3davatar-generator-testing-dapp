{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;\nimport { ReactiveElement } from 'lit';\nimport { property } from 'lit/decorators.js';\nimport { HAS_INTERSECTION_OBSERVER, HAS_RESIZE_OBSERVER } from './constants.js';\nimport { $updateEnvironment } from './features/environment.js';\nimport { makeTemplate } from './template.js';\nimport { $evictionPolicy, CachingGLTFLoader } from './three-components/CachingGLTFLoader.js';\nimport { ModelScene } from './three-components/ModelScene.js';\nimport { Renderer } from './three-components/Renderer.js';\nimport { clamp, debounce } from './utilities.js';\nimport { ProgressTracker } from './utilities/progress-tracker.js';\nconst CLEAR_MODEL_TIMEOUT_MS = 10;\nconst FALLBACK_SIZE_UPDATE_THRESHOLD_MS = 50;\nconst ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD = 0;\nconst UNSIZED_MEDIA_WIDTH = 300;\nconst UNSIZED_MEDIA_HEIGHT = 150;\nexport const blobCanvas = document.createElement('canvas');\nconst $fallbackResizeHandler = Symbol('fallbackResizeHandler');\nconst $defaultAriaLabel = Symbol('defaultAriaLabel');\nconst $resizeObserver = Symbol('resizeObserver');\nconst $clearModelTimeout = Symbol('clearModelTimeout');\nconst $onContextLost = Symbol('onContextLost');\nconst $loaded = Symbol('loaded');\nconst $status = Symbol('status');\nconst $onFocus = Symbol('onFocus');\nconst $onBlur = Symbol('onBlur');\nexport const $updateSize = Symbol('updateSize');\nexport const $intersectionObserver = Symbol('intersectionObserver');\nexport const $isElementInViewport = Symbol('isElementInViewport');\nexport const $announceModelVisibility = Symbol('announceModelVisibility');\nexport const $ariaLabel = Symbol('ariaLabel');\nexport const $altDefaulted = Symbol('altDefaulted');\nexport const $statusElement = Symbol('statusElement');\nexport const $updateStatus = Symbol('updateStatus');\nexport const $loadedTime = Symbol('loadedTime');\nexport const $updateSource = Symbol('updateSource');\nexport const $markLoaded = Symbol('markLoaded');\nexport const $container = Symbol('container');\nexport const $userInputElement = Symbol('input');\nexport const $canvas = Symbol('canvas');\nexport const $scene = Symbol('scene');\nexport const $needsRender = Symbol('needsRender');\nexport const $tick = Symbol('tick');\nexport const $onModelLoad = Symbol('onModelLoad');\nexport const $onResize = Symbol('onResize');\nexport const $renderer = Symbol('renderer');\nexport const $progressTracker = Symbol('progressTracker');\nexport const $getLoaded = Symbol('getLoaded');\nexport const $getModelIsVisible = Symbol('getModelIsVisible');\nexport const $shouldAttemptPreload = Symbol('shouldAttemptPreload');\nexport const toVector3D = v => {\n  return {\n    x: v.x,\n    y: v.y,\n    z: v.z,\n    toString() {\n      return `${this.x}m ${this.y}m ${this.z}m`;\n    }\n  };\n};\nexport const toVector2D = v => {\n  return {\n    u: v.x,\n    v: v.y,\n    toString() {\n      return `${this.u} ${this.v}`;\n    }\n  };\n};\n/**\n * Definition for a basic <model-viewer> element.\n */\nexport default class ModelViewerElementBase extends ReactiveElement {\n  /**\n   * Creates a new ModelViewerElement.\n   */\n  constructor() {\n    super();\n    this.alt = null;\n    this.src = null;\n    this.withCredentials = false;\n    /**\n     * Generates a 3D model schema https://schema.org/3DModel associated with\n     * the loaded src and inserts it into the header of the page for search\n     * engines to crawl.\n     */\n    this.generateSchema = false;\n    this[_a] = false;\n    this[_b] = false;\n    this[_c] = 0;\n    this[_d] = '';\n    this[_e] = null;\n    this[_f] = debounce(() => {\n      const boundingRect = this.getBoundingClientRect();\n      this[$updateSize](boundingRect);\n    }, FALLBACK_SIZE_UPDATE_THRESHOLD_MS);\n    this[_g] = debounce(oldVisibility => {\n      const newVisibility = this.modelIsVisible;\n      if (newVisibility !== oldVisibility) {\n        this.dispatchEvent(new CustomEvent('model-visibility', {\n          detail: {\n            visible: newVisibility\n          }\n        }));\n      }\n    }, ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD);\n    this[_h] = null;\n    this[_j] = null;\n    this[_k] = new ProgressTracker();\n    this[_l] = () => {\n      this[$statusElement].textContent = this[$status];\n    };\n    this[_m] = () => {\n      this[$statusElement].textContent = '';\n    };\n    this[_o] = event => {\n      this.dispatchEvent(new CustomEvent('error', {\n        detail: {\n          type: 'webglcontextlost',\n          sourceError: event.sourceEvent\n        }\n      }));\n    };\n    this.attachShadow({\n      mode: 'open'\n    });\n    const shadowRoot = this.shadowRoot;\n    makeTemplate(shadowRoot);\n    this[$container] = shadowRoot.querySelector('.container');\n    this[$userInputElement] = shadowRoot.querySelector('.userInput');\n    this[$canvas] = shadowRoot.querySelector('canvas');\n    this[$statusElement] = shadowRoot.querySelector('#status');\n    this[$defaultAriaLabel] = this[$userInputElement].getAttribute('aria-label');\n    // Because of potential race conditions related to invoking the constructor\n    // we only use the bounding rect to set the initial size if the element is\n    // already connected to the document:\n    let width, height;\n    if (this.isConnected) {\n      const rect = this.getBoundingClientRect();\n      width = rect.width;\n      height = rect.height;\n    } else {\n      width = UNSIZED_MEDIA_WIDTH;\n      height = UNSIZED_MEDIA_HEIGHT;\n    }\n    // Create the underlying ModelScene.\n    this[$scene] = new ModelScene({\n      canvas: this[$canvas],\n      element: this,\n      width,\n      height\n    });\n    // Update initial size on microtask timing so that subclasses have a\n    // chance to initialize\n    Promise.resolve().then(() => {\n      this[$updateSize](this.getBoundingClientRect());\n    });\n    if (HAS_RESIZE_OBSERVER) {\n      // Set up a resize observer so we can scale our canvas\n      // if our <model-viewer> changes\n      this[$resizeObserver] = new ResizeObserver(entries => {\n        // Don't resize anything if in AR mode; otherwise the canvas\n        // scaling to fullscreen on entering AR will clobber the flat/2d\n        // dimensions of the element.\n        if (this[$renderer].isPresenting) {\n          return;\n        }\n        for (let entry of entries) {\n          if (entry.target === this) {\n            this[$updateSize](entry.contentRect);\n          }\n        }\n      });\n    }\n    if (HAS_INTERSECTION_OBSERVER) {\n      this[$intersectionObserver] = new IntersectionObserver(entries => {\n        for (let entry of entries) {\n          if (entry.target === this) {\n            const oldVisibility = this.modelIsVisible;\n            this[$isElementInViewport] = entry.isIntersecting;\n            this[$announceModelVisibility](oldVisibility);\n            if (this[$isElementInViewport] && !this.loaded) {\n              this[$updateSource]();\n            }\n          }\n        }\n      }, {\n        root: null,\n        // We used to have margin here, but it was causing animated models below\n        // the fold to steal the frame budget. Weirder still, it would also\n        // cause input events to be swallowed, sometimes for seconds on the\n        // model above the fold, but only when the animated model was completely\n        // below. Setting this margin to zero fixed it.\n        rootMargin: '0px',\n        // With zero threshold, an element adjacent to but not intersecting the\n        // viewport will be reported as intersecting, which will cause\n        // unnecessary rendering. Any slight positive threshold alleviates this.\n        threshold: 0.00001\n      });\n    } else {\n      // If there is no intersection observer, then all models should be visible\n      // at all times:\n      this[$isElementInViewport] = true;\n    }\n  }\n  static get is() {\n    return 'model-viewer';\n  }\n  /** @export */\n  static set modelCacheSize(value) {\n    CachingGLTFLoader[$evictionPolicy].evictionThreshold = value;\n  }\n  /** @export */\n  static get modelCacheSize() {\n    return CachingGLTFLoader[$evictionPolicy].evictionThreshold;\n  }\n  /** @export */\n  static set minimumRenderScale(value) {\n    if (value > 1) {\n      console.warn('<model-viewer> minimumRenderScale has been clamped to a maximum value of 1.');\n    }\n    if (value <= 0) {\n      console.warn('<model-viewer> minimumRenderScale has been clamped to a minimum value of 0.25.');\n    }\n    Renderer.singleton.minScale = value;\n  }\n  /** @export */\n  static get minimumRenderScale() {\n    return Renderer.singleton.minScale;\n  }\n  /** @export */\n  get loaded() {\n    return this[$getLoaded]();\n  }\n  get [(_a = $isElementInViewport, _b = $loaded, _c = $loadedTime, _d = $status, _e = $clearModelTimeout, _f = $fallbackResizeHandler, _g = $announceModelVisibility, _h = $resizeObserver, _j = $intersectionObserver, _k = $progressTracker, $renderer)]() {\n    return Renderer.singleton;\n  }\n  /** @export */\n  get modelIsVisible() {\n    return this[$getModelIsVisible]();\n  }\n  connectedCallback() {\n    super.connectedCallback && super.connectedCallback();\n    if (HAS_RESIZE_OBSERVER) {\n      this[$resizeObserver].observe(this);\n    } else {\n      self.addEventListener('resize', this[$fallbackResizeHandler]);\n    }\n    if (HAS_INTERSECTION_OBSERVER) {\n      this[$intersectionObserver].observe(this);\n    }\n    this.addEventListener('focus', this[$onFocus]);\n    this.addEventListener('blur', this[$onBlur]);\n    const renderer = this[$renderer];\n    renderer.addEventListener('contextlost', this[$onContextLost]);\n    renderer.registerScene(this[$scene]);\n    if (this[$clearModelTimeout] != null) {\n      self.clearTimeout(this[$clearModelTimeout]);\n      this[$clearModelTimeout] = null;\n      // Force an update in case the model has been evicted from our GLTF cache\n      // @see https://lit-element.polymer-project.org/guide/lifecycle#requestupdate\n      this.requestUpdate('src', null);\n    }\n  }\n  disconnectedCallback() {\n    super.disconnectedCallback && super.disconnectedCallback();\n    if (HAS_RESIZE_OBSERVER) {\n      this[$resizeObserver].unobserve(this);\n    } else {\n      self.removeEventListener('resize', this[$fallbackResizeHandler]);\n    }\n    if (HAS_INTERSECTION_OBSERVER) {\n      this[$intersectionObserver].unobserve(this);\n    }\n    this.removeEventListener('focus', this[$onFocus]);\n    this.removeEventListener('blur', this[$onBlur]);\n    const renderer = this[$renderer];\n    renderer.removeEventListener('contextlost', this[$onContextLost]);\n    renderer.unregisterScene(this[$scene]);\n    this[$clearModelTimeout] = self.setTimeout(() => {\n      this[$scene].dispose();\n      this[$clearModelTimeout] = null;\n    }, CLEAR_MODEL_TIMEOUT_MS);\n  }\n  updated(changedProperties) {\n    super.updated(changedProperties);\n    // NOTE(cdata): If a property changes from values A -> B -> A in the space\n    // of a microtask, LitElement/UpdatingElement will notify of a change even\n    // though the value has effectively not changed, so we need to check to make\n    // sure that the value has actually changed before changing the loaded flag.\n    if (changedProperties.has('src')) {\n      if (this.src == null) {\n        this[$loaded] = false;\n        this[$loadedTime] = 0;\n        this[$scene].reset();\n      } else if (this.src !== this[$scene].url) {\n        this[$loaded] = false;\n        this[$loadedTime] = 0;\n        this[$updateSource]();\n      }\n    }\n    if (changedProperties.has('alt')) {\n      this[$userInputElement].setAttribute('aria-label', this[$ariaLabel]);\n    }\n    if (changedProperties.has('generateSchema')) {\n      if (this.generateSchema) {\n        this[$scene].updateSchema(this.src);\n      } else {\n        this[$scene].updateSchema(null);\n      }\n    }\n  }\n  /** @export */\n  toDataURL(type, encoderOptions) {\n    return this[$renderer].displayCanvas(this[$scene]).toDataURL(type, encoderOptions);\n  }\n  /** @export */\n  async toBlob(options) {\n    const mimeType = options ? options.mimeType : undefined;\n    const qualityArgument = options ? options.qualityArgument : undefined;\n    const useIdealAspect = options ? options.idealAspect : undefined;\n    const {\n      width,\n      height,\n      idealAspect,\n      aspect\n    } = this[$scene];\n    const {\n      dpr,\n      scaleFactor\n    } = this[$renderer];\n    let outputWidth = width * scaleFactor * dpr;\n    let outputHeight = height * scaleFactor * dpr;\n    let offsetX = 0;\n    let offsetY = 0;\n    if (useIdealAspect === true) {\n      if (idealAspect > aspect) {\n        const oldHeight = outputHeight;\n        outputHeight = Math.round(outputWidth / idealAspect);\n        offsetY = (oldHeight - outputHeight) / 2;\n      } else {\n        const oldWidth = outputWidth;\n        outputWidth = Math.round(outputHeight * idealAspect);\n        offsetX = (oldWidth - outputWidth) / 2;\n      }\n    }\n    blobCanvas.width = outputWidth;\n    blobCanvas.height = outputHeight;\n    try {\n      return new Promise(async (resolve, reject) => {\n        blobCanvas.getContext('2d').drawImage(this[$renderer].displayCanvas(this[$scene]), offsetX, offsetY, outputWidth, outputHeight, 0, 0, outputWidth, outputHeight);\n        blobCanvas.toBlob(blob => {\n          if (!blob) {\n            return reject(new Error('Unable to retrieve canvas blob'));\n          }\n          resolve(blob);\n        }, mimeType, qualityArgument);\n      });\n    } finally {\n      this[$updateSize]({\n        width,\n        height\n      });\n    }\n    ;\n  }\n  /**\n   * Registers a new EffectComposer as the main rendering pipeline,\n   * instead of the default ThreeJs renderer.\n   * This method also calls setRenderer, setMainScene, and setMainCamera on\n   * your effectComposer.\n   * @param effectComposer An EffectComposer from `pmndrs/postprocessing`\n   */\n  registerEffectComposer(effectComposer) {\n    effectComposer.setRenderer(this[$renderer].threeRenderer);\n    effectComposer.setMainCamera(this[$scene].getCamera());\n    effectComposer.setMainScene(this[$scene]);\n    this[$scene].effectRenderer = effectComposer;\n  }\n  /**\n   * Removes the registered EffectComposer\n   */\n  unregisterEffectComposer() {\n    this[$scene].effectRenderer = null;\n  }\n  registerRenderer(renderer) {\n    this[$scene].externalRenderer = renderer;\n  }\n  unregisterRenderer() {\n    this[$scene].externalRenderer = null;\n  }\n  get [$ariaLabel]() {\n    return this[$altDefaulted];\n  }\n  get [$altDefaulted]() {\n    return this.alt == null || this.alt === 'null' ? this[$defaultAriaLabel] : this.alt;\n  }\n  // NOTE(cdata): Although this may seem extremely redundant, it is required in\n  // order to support overloading when TypeScript is compiled to ES5\n  // @see https://github.com/Polymer/lit-element/pull/745\n  // @see https://github.com/microsoft/TypeScript/issues/338\n  [$getLoaded]() {\n    return this[$loaded];\n  }\n  // @see [$getLoaded]\n  [$getModelIsVisible]() {\n    return this.loaded && this[$isElementInViewport];\n  }\n  [$shouldAttemptPreload]() {\n    return !!this.src && this[$isElementInViewport];\n  }\n  /**\n   * Called on initialization and when the resize observer fires.\n   */\n  [$updateSize]({\n    width,\n    height\n  }) {\n    if (width === 0 || height === 0) {\n      return;\n    }\n    this[$container].style.width = `${width}px`;\n    this[$container].style.height = `${height}px`;\n    this[$onResize]({\n      width,\n      height\n    });\n  }\n  [$tick](time, delta) {\n    var _p;\n    (_p = this[$scene].effectRenderer) === null || _p === void 0 ? void 0 : _p.beforeRender(time, delta);\n  }\n  [$markLoaded]() {\n    if (this[$loaded]) {\n      return;\n    }\n    this[$loaded] = true;\n    this[$loadedTime] = performance.now();\n  }\n  [$needsRender]() {\n    this[$scene].queueRender();\n  }\n  [$onModelLoad]() {}\n  [$updateStatus](status) {\n    this[$status] = status;\n    const rootNode = this.getRootNode();\n    // Only change the aria-label if <model-viewer> is currently focused:\n    if (rootNode != null && rootNode.activeElement === this && this[$statusElement].textContent != status) {\n      this[$statusElement].textContent = status;\n    }\n  }\n  [(_l = $onFocus, _m = $onBlur, $onResize)](e) {\n    this[$scene].setSize(e.width, e.height);\n  }\n  /**\n   * Parses the element for an appropriate source URL and\n   * sets the views to use the new model based.\n   */\n  async [(_o = $onContextLost, $updateSource)]() {\n    const scene = this[$scene];\n    if (this.loaded || !this[$shouldAttemptPreload]() || this.src === scene.url) {\n      return;\n    }\n    if (this.generateSchema) {\n      scene.updateSchema(this.src);\n    }\n    this[$updateStatus]('Loading');\n    // If we are loading a new model, we need to stop the animation of\n    // the current one (if any is playing). Otherwise, we might lose\n    // the reference to the scene root and running actions start to\n    // throw exceptions and/or behave in unexpected ways:\n    scene.stopAnimation();\n    const updateSourceProgress = this[$progressTracker].beginActivity('model-load');\n    const source = this.src;\n    try {\n      const srcUpdated = scene.setSource(source, progress => updateSourceProgress(clamp(progress, 0, 1) * 0.95));\n      const envUpdated = this[$updateEnvironment]();\n      await Promise.all([srcUpdated, envUpdated]);\n      this[$markLoaded]();\n      this[$onModelLoad]();\n      this.updateComplete.then(() => {\n        this.dispatchEvent(new CustomEvent('before-render'));\n      });\n      // Wait for shaders to compile and pixels to be drawn.\n      await new Promise(resolve => {\n        requestAnimationFrame(() => {\n          requestAnimationFrame(() => {\n            this.dispatchEvent(new CustomEvent('load', {\n              detail: {\n                url: source\n              }\n            }));\n            resolve();\n          });\n        });\n      });\n    } catch (error) {\n      this.dispatchEvent(new CustomEvent('error', {\n        detail: {\n          type: 'loadfailure',\n          sourceError: error\n        }\n      }));\n    } finally {\n      updateSourceProgress(1.0);\n    }\n  }\n}\n__decorate([property({\n  type: String\n})], ModelViewerElementBase.prototype, \"alt\", void 0);\n__decorate([property({\n  type: String\n})], ModelViewerElementBase.prototype, \"src\", void 0);\n__decorate([property({\n  type: Boolean,\n  attribute: 'with-credentials'\n})], ModelViewerElementBase.prototype, \"withCredentials\", void 0);\n__decorate([property({\n  type: Boolean,\n  attribute: 'generate-schema'\n})], ModelViewerElementBase.prototype, \"generateSchema\", void 0);\n//# sourceMappingURL=model-viewer-base.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}