{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b;\nimport { Color, DoubleSide, FrontSide, Vector2 } from 'three';\nimport { PBRMetallicRoughness } from './pbr-metallic-roughness.js';\nimport { TextureInfo, TextureUsage } from './texture-info.js';\nimport { $correlatedObjects, $onUpdate, ThreeDOMElement } from './three-dom-element.js';\nconst $pbrMetallicRoughness = Symbol('pbrMetallicRoughness');\nconst $normalTexture = Symbol('normalTexture');\nconst $occlusionTexture = Symbol('occlusionTexture');\nconst $emissiveTexture = Symbol('emissiveTexture');\nconst $backingThreeMaterial = Symbol('backingThreeMaterial');\nconst $applyAlphaCutoff = Symbol('applyAlphaCutoff');\nconst $getAlphaMode = Symbol('getAlphaMode');\nexport const $lazyLoadGLTFInfo = Symbol('lazyLoadGLTFInfo');\nconst $initialize = Symbol('initialize');\nexport const $getLoadedMaterial = Symbol('getLoadedMaterial');\nexport const $ensureMaterialIsLoaded = Symbol('ensureMaterialIsLoaded');\nexport const $gltfIndex = Symbol('gltfIndex');\nexport const $setActive = Symbol('setActive');\nexport const $variantIndices = Symbol('variantIndices');\nconst $isActive = Symbol('isActive');\nconst $modelVariants = Symbol('modelVariants');\nconst $name = Symbol('name');\nconst $pbrTextures = Symbol('pbrTextures');\n/**\n * Material facade implementation for Three.js materials\n */\nexport class Material extends ThreeDOMElement {\n  constructor(onUpdate, gltfIndex, isActive, modelVariants, correlatedMaterials, name, lazyLoadInfo = undefined) {\n    super(onUpdate, correlatedMaterials);\n    this[_a] = new Set();\n    this[_b] = new Map();\n    this[$gltfIndex] = gltfIndex;\n    this[$isActive] = isActive;\n    this[$modelVariants] = modelVariants;\n    this[$name] = name;\n    if (lazyLoadInfo == null) {\n      this[$initialize]();\n    } else {\n      this[$lazyLoadGLTFInfo] = lazyLoadInfo;\n    }\n  }\n  get [(_a = $variantIndices, _b = $pbrTextures, $backingThreeMaterial)]() {\n    return this[$correlatedObjects].values().next().value;\n  }\n  [$initialize]() {\n    const onUpdate = this[$onUpdate];\n    const correlatedMaterials = this[$correlatedObjects];\n    this[$pbrMetallicRoughness] = new PBRMetallicRoughness(onUpdate, correlatedMaterials);\n    const {\n      normalMap,\n      aoMap,\n      emissiveMap\n    } = correlatedMaterials.values().next().value;\n    this[$normalTexture] = new TextureInfo(onUpdate, TextureUsage.Normal, normalMap, correlatedMaterials);\n    this[$occlusionTexture] = new TextureInfo(onUpdate, TextureUsage.Occlusion, aoMap, correlatedMaterials);\n    this[$emissiveTexture] = new TextureInfo(onUpdate, TextureUsage.Emissive, emissiveMap, correlatedMaterials);\n    const createTextureInfo = usage => {\n      this[$pbrTextures].set(usage, new TextureInfo(onUpdate, usage, null, correlatedMaterials));\n    };\n    createTextureInfo(TextureUsage.Clearcoat);\n    createTextureInfo(TextureUsage.ClearcoatRoughness);\n    createTextureInfo(TextureUsage.ClearcoatNormal);\n    createTextureInfo(TextureUsage.SheenColor);\n    createTextureInfo(TextureUsage.SheenRoughness);\n    createTextureInfo(TextureUsage.Transmission);\n    createTextureInfo(TextureUsage.Thickness);\n    createTextureInfo(TextureUsage.Specular);\n    createTextureInfo(TextureUsage.SpecularColor);\n    createTextureInfo(TextureUsage.Iridescence);\n    createTextureInfo(TextureUsage.IridescenceThickness);\n    createTextureInfo(TextureUsage.Anisotropy);\n  }\n  async [$getLoadedMaterial]() {\n    if (this[$lazyLoadGLTFInfo] != null) {\n      const material = await this[$lazyLoadGLTFInfo].doLazyLoad();\n      this[$initialize]();\n      // Releases lazy load info.\n      this[$lazyLoadGLTFInfo] = undefined;\n      // Redefines the method as a noop method.\n      this.ensureLoaded = async () => {};\n      return material;\n    }\n    return null;\n  }\n  colorFromRgb(rgb) {\n    const color = new Color();\n    if (rgb instanceof Array) {\n      color.fromArray(rgb);\n    } else {\n      color.set(rgb);\n    }\n    return color;\n  }\n  [$ensureMaterialIsLoaded]() {\n    if (this[$lazyLoadGLTFInfo] == null) {\n      return;\n    }\n    throw new Error(`Material \"${this.name}\" has not been loaded, call 'await\n    myMaterial.ensureLoaded()' before using an unloaded material.`);\n  }\n  async ensureLoaded() {\n    await this[$getLoadedMaterial]();\n  }\n  get isLoaded() {\n    return this[$lazyLoadGLTFInfo] == null;\n  }\n  get isActive() {\n    return this[$isActive];\n  }\n  [$setActive](isActive) {\n    this[$isActive] = isActive;\n  }\n  get name() {\n    return this[$name] || '';\n  }\n  set name(name) {\n    this[$name] = name;\n    if (this[$correlatedObjects] != null) {\n      for (const threeMaterial of this[$correlatedObjects]) {\n        threeMaterial.name = name;\n      }\n    }\n  }\n  get pbrMetallicRoughness() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrMetallicRoughness];\n  }\n  get normalTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$normalTexture];\n  }\n  get occlusionTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$occlusionTexture];\n  }\n  get emissiveTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$emissiveTexture];\n  }\n  get emissiveFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].emissive.toArray();\n  }\n  get index() {\n    return this[$gltfIndex];\n  }\n  hasVariant(name) {\n    const variantData = this[$modelVariants].get(name);\n    return variantData != null && this[$variantIndices].has(variantData.index);\n  }\n  setEmissiveFactor(rgb) {\n    this[$ensureMaterialIsLoaded]();\n    const color = this.colorFromRgb(rgb);\n    for (const material of this[$correlatedObjects]) {\n      material.emissive.set(color);\n    }\n    this[$onUpdate]();\n  }\n  [$getAlphaMode]() {\n    // Follows implementation of GLTFExporter from three.js\n    if (this[$backingThreeMaterial].transparent) {\n      return 'BLEND';\n    } else {\n      if (this[$backingThreeMaterial].alphaTest > 0.0) {\n        return 'MASK';\n      }\n    }\n    return 'OPAQUE';\n  }\n  [$applyAlphaCutoff]() {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      if (this[$getAlphaMode]() === 'MASK') {\n        if (material.alphaTest == undefined) {\n          material.alphaTest = 0.5;\n        }\n      } else {\n        material.alphaTest = undefined;\n      }\n      material.needsUpdate = true;\n    }\n  }\n  setAlphaCutoff(cutoff) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.alphaTest = cutoff;\n      material.needsUpdate = true;\n    }\n    // Set AlphaCutoff to undefined if AlphaMode is not MASK.\n    this[$applyAlphaCutoff]();\n    this[$onUpdate]();\n  }\n  getAlphaCutoff() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].alphaTest;\n  }\n  setDoubleSided(doubleSided) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      // When double-sided is disabled gltf spec dictates that Back-Face culling\n      // must be disabled, in three.js parlance that would mean FrontSide\n      // rendering only.\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#double-sided\n      material.side = doubleSided ? DoubleSide : FrontSide;\n      material.needsUpdate = true;\n    }\n    this[$onUpdate]();\n  }\n  getDoubleSided() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].side == DoubleSide;\n  }\n  setAlphaMode(alphaMode) {\n    this[$ensureMaterialIsLoaded]();\n    const enableTransparency = (material, enabled) => {\n      material.transparent = enabled;\n      material.depthWrite = !enabled;\n    };\n    for (const material of this[$correlatedObjects]) {\n      enableTransparency(material, alphaMode === 'BLEND');\n      if (alphaMode === 'MASK') {\n        material.alphaTest = 0.5;\n      } else {\n        material.alphaTest = undefined;\n      }\n      material.needsUpdate = true;\n    }\n    this[$onUpdate]();\n  }\n  getAlphaMode() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$getAlphaMode]();\n  }\n  /**\n   * PBR Next properties.\n   */\n  // KHR_materials_emissive_strength\n  get emissiveStrength() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].emissiveIntensity;\n  }\n  setEmissiveStrength(emissiveStrength) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.emissiveIntensity = emissiveStrength;\n    }\n    this[$onUpdate]();\n  }\n  // KHR_materials_clearcoat\n  get clearcoatFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].clearcoat;\n  }\n  get clearcoatRoughnessFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].clearcoatRoughness;\n  }\n  get clearcoatTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.Clearcoat);\n  }\n  get clearcoatRoughnessTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.ClearcoatRoughness);\n  }\n  get clearcoatNormalTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.ClearcoatNormal);\n  }\n  get clearcoatNormalScale() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].clearcoatNormalScale.x;\n  }\n  setClearcoatFactor(clearcoatFactor) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.clearcoat = clearcoatFactor;\n    }\n    this[$onUpdate]();\n  }\n  setClearcoatRoughnessFactor(clearcoatRoughnessFactor) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.clearcoatRoughness = clearcoatRoughnessFactor;\n    }\n    this[$onUpdate]();\n  }\n  setClearcoatNormalScale(clearcoatNormalScale) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.clearcoatNormalScale = new Vector2(clearcoatNormalScale, clearcoatNormalScale);\n    }\n    this[$onUpdate]();\n  }\n  // KHR_materials_ior\n  get ior() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].ior;\n  }\n  setIor(ior) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.ior = ior;\n    }\n    this[$onUpdate]();\n  }\n  // KHR_materials_sheen\n  get sheenColorFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].sheenColor.toArray();\n  }\n  get sheenColorTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.SheenColor);\n  }\n  get sheenRoughnessFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].sheenRoughness;\n  }\n  get sheenRoughnessTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.SheenRoughness);\n  }\n  setSheenColorFactor(rgb) {\n    this[$ensureMaterialIsLoaded]();\n    const color = this.colorFromRgb(rgb);\n    for (const material of this[$correlatedObjects]) {\n      material.sheenColor.set(color);\n      // Three.js GLTFExporter checks for internal sheen value.\n      material.sheen = 1;\n    }\n    this[$onUpdate]();\n  }\n  setSheenRoughnessFactor(roughness) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.sheenRoughness = roughness;\n      // Three.js GLTFExporter checks for internal sheen value.\n      material.sheen = 1;\n    }\n    this[$onUpdate]();\n  }\n  // KHR_materials_transmission\n  get transmissionFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].transmission;\n  }\n  get transmissionTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.Transmission);\n  }\n  setTransmissionFactor(transmission) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.transmission = transmission;\n    }\n    this[$onUpdate]();\n  }\n  // KHR_materials_volume\n  get thicknessFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].thickness;\n  }\n  get thicknessTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.Thickness);\n  }\n  get attenuationDistance() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].attenuationDistance;\n  }\n  get attenuationColor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].attenuationColor.toArray();\n  }\n  setThicknessFactor(thickness) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.thickness = thickness;\n    }\n    this[$onUpdate]();\n  }\n  setAttenuationDistance(attenuationDistance) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.attenuationDistance = attenuationDistance;\n    }\n    this[$onUpdate]();\n  }\n  setAttenuationColor(rgb) {\n    this[$ensureMaterialIsLoaded]();\n    const color = this.colorFromRgb(rgb);\n    for (const material of this[$correlatedObjects]) {\n      material.attenuationColor.set(color);\n    }\n    this[$onUpdate]();\n  }\n  // KHR_materials_specular\n  get specularFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].specularIntensity;\n  }\n  get specularTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.Specular);\n  }\n  get specularColorFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].specularColor.toArray();\n  }\n  get specularColorTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.SheenColor);\n  }\n  setSpecularFactor(specularFactor) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.specularIntensity = specularFactor;\n    }\n    this[$onUpdate]();\n  }\n  setSpecularColorFactor(rgb) {\n    this[$ensureMaterialIsLoaded]();\n    const color = this.colorFromRgb(rgb);\n    for (const material of this[$correlatedObjects]) {\n      material.specularColor.set(color);\n    }\n    this[$onUpdate]();\n  }\n  // KHR_materials_iridescence\n  get iridescenceFactor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].iridescence;\n  }\n  get iridescenceTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.Iridescence);\n  }\n  get iridescenceIor() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].iridescenceIOR;\n  }\n  get iridescenceThicknessMinimum() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].iridescenceThicknessRange[0];\n  }\n  get iridescenceThicknessMaximum() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].iridescenceThicknessRange[1];\n  }\n  get iridescenceThicknessTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.IridescenceThickness);\n  }\n  setIridescenceFactor(iridescence) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.iridescence = iridescence;\n    }\n    this[$onUpdate]();\n  }\n  setIridescenceIor(ior) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.iridescenceIOR = ior;\n    }\n    this[$onUpdate]();\n  }\n  setIridescenceThicknessMinimum(thicknessMin) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.iridescenceThicknessRange[0] = thicknessMin;\n    }\n    this[$onUpdate]();\n  }\n  setIridescenceThicknessMaximum(thicknessMax) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.iridescenceThicknessRange[1] = thicknessMax;\n    }\n    this[$onUpdate]();\n  }\n  // KHR_materials_anisotropy\n  get anisotropyStrength() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].anisotropy;\n  }\n  get anisotropyRotation() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$backingThreeMaterial].anisotropyRotation;\n  }\n  get anisotropyTexture() {\n    this[$ensureMaterialIsLoaded]();\n    return this[$pbrTextures].get(TextureUsage.Anisotropy);\n  }\n  setAnisotropyStrength(strength) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.anisotropy = strength;\n    }\n    this[$onUpdate]();\n  }\n  setAnisotropyRotation(rotation) {\n    this[$ensureMaterialIsLoaded]();\n    for (const material of this[$correlatedObjects]) {\n      material.anisotropyRotation = rotation;\n    }\n    this[$onUpdate]();\n  }\n}\n//# sourceMappingURL=material.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}